<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xreflabel="[view]" xml:id="view"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Views</title>

  <titleabbrev>view</titleabbrev>

  <orderedlist>
    <listitem>
      <para>This clause describes components that VSIPL++ programs may use to
      store and use data. A block is an interface to a logically contiguous
      array of data. The Dense class is a block. A view is an interface
      supporting data-parallel operations. Vector, Matrix, and Tensor classes
      satisfy this interface.</para>
    </listitem>

    <listitem>
      <para>A map specifies how a block can be divided into subblocks.
      [<emphasis>Note: </emphasis> For a program executing on a single
      processor, there should be no need to indicate any particular map since
      default template arguments and default function arguments should
      suffice. A VSIPL++ implementation restricted to supporting only a single
      processor will probably just define empty map classes and will probably
      not define the view constructors in <olink targetdoc="vsiplxx-par"
      targetptr="view.vector.constructors"/>, <olink targetdoc="vsiplxx-par"
      targetptr="view.matrix.constructors"/>, and <olink
      targetdoc="vsiplxx-par" targetptr="view.tensor.constructors"/>. ]</para>
    </listitem>
  </orderedlist>

  <section xml:id="view.view">
    <title>View definitions</title>

    <titleabbrev>view.view</titleabbrev>

    <orderedlist>
      <listitem>
        <para>Every <emphasis>view</emphasis> is logically a contiguous array
        with dimension D between one and
        <constant>VSIP_MAX_DIMENSIONS</constant>, inclusive. The
        Domain&lt;D&gt; associated with a view indicates the set of
        Index&lt;D&gt;es that can be used to access the view. The dimension of
        a view does not change during its lifetime.</para>
      </listitem>

      <listitem>
        <para>Views support data-parallel operations, such as the assignment
        of one view to another or the element-wise addition of two
        views.</para>
      </listitem>

      <listitem>
        <para>Every view has an associated block which is responsible for
        storing or computing the data in the view. More than one view may be
        associated with the same block.</para>
      </listitem>

      <listitem>
        <para>Views may be modifiable or non-modifiable. The interface of a
        <emphasis>modifiable view</emphasis> supports changing the view’s
        data; the interface of a <emphasis>non-modifiable view</emphasis> does
        not support changing its data. [<emphasis>Note: </emphasis> The data
        of a non-modifiable view may be changed by another modifiable view
        accessing the same data. ]</para>
      </listitem>

      <listitem>
        <para>The type of objects stored in these components must meet the
        same requirements as specified for blocks.</para>
      </listitem>

      <listitem>
        <para>Every view meets the requirements in <xref linkend="viewreq"/>.
        In <xref linkend="viewreq"/>, V denotes a view class of dimension D
        containing objects of type T with an underlying D-dimensional block of
        type B, v denotes a value of type V, b denotes a value of type B&amp;,
        d denotes a value of type dimension_type, and i1, i2, . . . , iD
        denote D values of type index_type .</para>

        <table xml:id="viewreq">
          <caption>View requirements</caption>

          <tr>
            <th>expression</th>

            <th>return type</th>

            <th>assertion/note pre/post-condition</th>
          </tr>

          <tr>
            <td>V::dim</td>

            <td>dimension_type</td>

            <td>V::dim == D</td>
          </tr>

          <tr>
            <td>V::block_type</td>

            <td>B</td>

            <td>B is a block</td>
          </tr>

          <tr>
            <td>V::value_type</td>

            <td>B::value_type</td>

            <td/>
          </tr>

          <tr>
            <td>V::reference_type</td>

            <td>B::reference_type</td>

            <td/>
          </tr>

          <tr>
            <td>V::const_reference_type</td>

            <td>B::const_reference_type</td>

            <td/>
          </tr>

          <tr>
            <td>V(b)</td>

            <td/>

            <td>Constructs V object</td>
          </tr>

          <tr>
            <td>v.block()</td>

            <td>B const &amp;</td>

            <td/>
          </tr>

          <tr>
            <td>v.get(i1,i2,...,iD)</td>

            <td>value_type</td>

            <td/>
          </tr>

          <tr>
            <td>v.size()</td>

            <td>length_type</td>

            <td>post: product of size(d) over all 0 &lt;= d &lt; D</td>
          </tr>

          <tr>
            <td>v.size(d)</td>

            <td>length_type</td>

            <td>pre: 0 &lt;= d &lt; D</td>
          </tr>
        </table>
      </listitem>

      <listitem>
        <para>Two views <emphasis>overlap</emphasis> if their domains overlap.
        Two views <emphasis>exactly overlap</emphasis> if their domains
        exactly overlap.</para>
      </listitem>

      <listitem>
        <para>Two views are <emphasis>element conformant</emphasis> if their
        domains are element conformant.</para>
      </listitem>

      <listitem>
        <para>Two values in separate views <emphasis>correspond</emphasis> if
        the values have corresponding Index&lt;D&gt;es.</para>
      </listitem>

      <listitem>
        <para>Every modifiable view meets the requirements in <xref
        linkend="modviewreq"/> in addition to the requirements in <xref
        linkend="viewreq"/>. In <xref linkend="modviewreq"/>, <type>V</type>
        denotes a modifiable view class, v denotes an object of type
        <type>V</type>, t denotes a value of type <type>T</type> and v2 denote
        a view object (possibly of a type other than V).</para>

        <table xml:id="modviewreq">
          <caption>Modifiable view requirements</caption>

          <tr>
            <th>expression</th>

            <th>return type</th>

            <th>assertion/note pre/post-condition</th>
          </tr>

          <tr>
            <td><code>v.put(i1, i2,..., iD, t)</code></td>

            <td>implementation-defined</td>

            <td>post: <code>a.get(i1, ..., iD) == t</code></td>
          </tr>

          <tr>
            <td><code>v = v2</code></td>

            <td><code>const V &amp;</code></td>

            <td>pre: v, v2 element-conformant</td>
          </tr>
        </table>
      </listitem>

      <listitem>
        <para>A <emphasis>subview</emphasis> of a view object v refers to
        (possibly a subset of) v’s block.</para>
      </listitem>

      <listitem>
        <para>Subviews use reference semantics. Consider a view v and a
        subview subv of v, an Index&lt;D&gt; position idx in subv’s domain,
        and its associated value val. Since subv is a subview, there is an
        associated Index in v’s Domain&lt;D&gt;. Changing the value at index
        position idx to a new value val2 changes the value for both v and
        subv.</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Note: </emphasis> A subview’s domain is not required
        to be a subset of its referenced view’s domain. For example, the
        transpose of a non-square matrix will have one dimension longer than
        the original matrix. ]</para>
      </listitem>

      <listitem>
        <para>To help blocks implement reference counting, a view’s
        constructor that does not allocate the block must call its block’s
        increment_count member function exactly once. A constructor that does
        allocate its block must not invoke its block’s increment_count member
        function. A view’s destructor must call its block’s decrement_count
        exactly once.</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Note: </emphasis> Subviews use reference semantics so
        subviews, including entire copies, of views refer to the same block.
        Many views, e.g., Vector, Matrix, and Tensor, support modification of
        values via assignment. Users who are new to C++ should note that any
        statement beginning with a type specifier and involving an existing
        object with the same type is almost always a copy, not an assignment,
        even if an equal sign is present. ]</para>
      </listitem>
    </orderedlist>

    <section xml:id="view.view.assign">
      <title>View assignments</title>

      <titleabbrev>view.view.assign</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Some views support assignment operations. A single view
          assignment may modify multiple values in the view. Each individual
          view value modification is an <emphasis>individual
          assignment</emphasis>. All individual assignments specified by a
          single assignment are collectively called the <emphasis>collective
          assignment</emphasis>.</para>
        </listitem>

        <listitem>
          <para>The order of individual assignments within a single collective
          assignment can affect the collective result. [<emphasis>Example:
          </emphasis> Consider a collective assignment to a view v
          incorporating two individual assignments <code>v.put(0,
          v.get(1))</code> and<code> v.put(1, v.get(2))</code>. Let
          <code>v.get(1) == t1</code> and <code>v.get(2) == t2</code>. If the
          put to index 0 occurs before the put to 1, then, after the
          collective assignment, <code>v.get(0) == t1</code>. If the put to
          index 1 occurs before the put to 0, then, after the collective
          assignment, <code>v.get(0) == t2</code>. ]</para>
        </listitem>

        <listitem>
          <para>An <emphasis>order-dependent assignment</emphasis> is a
          collective assignment for which the order of individual assignments
          affects the collective result. An <emphasis>order-independent
          assignment</emphasis> is a collective assignment for which the order
          of individual assignments does not affect the collective
          result.</para>
        </listitem>

        <listitem>
          <para>Assignments must be order-independent. It is the user’s
          responsibility to ensure that assignments are
          order-independent.</para>
        </listitem>

        <listitem>
          <para>Given an assignment statement, <emphasis>order-independent
          assignment operands</emphasis> are a left-hand side view v and
          right-hand side views w0, … such that the assignment is
          order-independent.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section xml:id="view.vector">
    <title>Vector</title>

    <titleabbrev>view.vector</titleabbrev>

    <orderedlist>
      <listitem>
        <para>The const_Vector and Vector classes are views implementing the
        mathematical idea of vectors, i.e., one-dimensional storage and access
        to values. A const_Vector view is not modifiable, but a Vector view is
        modifiable.</para>
      </listitem>

      <listitem>
        <para>The interfaces for const_Vector and Vector are similar so they
        are simultaneously specified except where noted. For these,
        <emphasis>Vector</emphasis> indicates both const_Vector and Vector.
        The term “vector” refers to a const_Vector or Vector object.</para>

        <para>Header <emphasis>&lt;vsip/vector.hpp&gt;</emphasis>
        synopsis</para>

        <xi:include href="code/vector.hpp"/>
      </listitem>
    </orderedlist>

    <section xml:id="view.vector.template">
      <title>Template parameters</title>

      <titleabbrev>view.vector.template</titleabbrev>

      <orderedlist>
        <listitem>
          <para>T specifies the type of values stored in the
          <emphasis>Vector</emphasis> object which has an associated block
          with type Block for storing the values. The only specializations
          which must be supported have T the same as scalar_f, scalar_i,
          cscalar_f, cscalar_i, bool, index_type, Index&lt;1&gt;,
          Index&lt;2&gt;, or Index&lt;3&gt;. An implementation is permitted to
          prevent instantiation for other choices of T.</para>
        </listitem>

        <listitem>
          <para>Block <variablelist>
              <varlistentry>
                <term>Requires:</term>

                <listitem>
                  <para>T must be Block::value_type. Block must be a
                  one-dimensional block.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Note:</term>

                <listitem>
                  <para>Block need not be modifiable.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.vector.subview_types">
      <title>Subview types</title>

      <titleabbrev>view.vector.subview_types</titleabbrev>

      <orderedlist>
        <listitem>
          <para>subview_type specifies the type of a subview of a
          <emphasis>Vector</emphasis>. The type is a
          <emphasis>Vector</emphasis> with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para>const_subview_type specifies the type of a non-modifiable
          subview of a <emphasis>Vector</emphasis>. The type is a const_Vector
          with value type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para>realview_type specifies the type of a subview of a
          <emphasis>Vector</emphasis> containing only the real parts of the
          <emphasis>Vector</emphasis>’s values. This type is defined only if T
          is a complex type complex&lt;Tp&gt;. The type is a
          <emphasis>Vector</emphasis> with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para>const_realview_type specifies the type of a non-modifiable
          subview of a <emphasis>Vector</emphasis> containing only the real
          parts of the <emphasis>Vector</emphasis>’s values. This type is
          defined only if T is a complex type complex&lt;Tp&gt;. The type is a
          const_Vector with value type Tp and an unspecified block
          type.</para>
        </listitem>

        <listitem>
          <para>imagview_type specifies the type of a subview of a
          <emphasis>Vector</emphasis> containing only the imaginary parts of
          the <emphasis>Vector</emphasis>’s values. This type is defined only
          if T is a complex type complex&lt;Tp&gt;. The type is a
          <emphasis>Vector</emphasis> with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para>const_imagview_type specifies the type of a non-modifiable
          subview of a <emphasis>Vector</emphasis> containing only the
          imaginary parts of the <emphasis>Vector</emphasis>’s values. This
          type is defined only if T is a complex type complex&lt;Tp&gt;. The
          type is a const_Vector with value type Tp and an unspecified block
          type.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.vector.constructors">
      <title>Constructors, copy, assignment, and destructor</title>

      <titleabbrev>view.vector.constructors</titleabbrev>

      <synopsis><emphasis role="bold">Vector</emphasis>(length_type len, T const &amp;value);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>len &gt; 0. Block must be allocatable. Block::map_type must
            have a default constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to
            <emphasis>Vector</emphasis>(Block(Domain&lt;1&gt;(len), value,
            Block::map_type())).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes:</term>

          <listitem>
            <para>Blocks are created with the effect of increment_count,
            Vector does not invoke increment_count again for blocks it
            allocates.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold"><emphasis>Vector</emphasis></emphasis>(length_type len);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>Block must be allocatable. Block::map_type must have a
            default constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to
            <emphasis>Vector</emphasis>(Block(Domain&lt;1&gt;(len),
            Block::map_type())).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes:</term>

          <listitem>
            <para>Blocks are created with the effect of increment_count,
            Vector does not invoke increment_count again for blocks it
            allocates.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Vector</emphasis>(Block &amp;block) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>1-dimensional modifiable block.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a Vector v with associated block block. v.size(0)
            == block.size(1,0).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">const_Vector</emphasis>(Block &amp;block) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>1-dimensional block.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a const_Vector v with associated block block.
            v.size(0) == block.size(1,0).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold"><emphasis>Vector</emphasis></emphasis>(<emphasis>Vector</emphasis> const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a subview <emphasis>Vector</emphasis> object of v
            such that its domain is the same as v’s domain.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>*this and v are functionally equivalent.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">const_Vector</emphasis>(Vector const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a subview const_Vector object of v such that its
            domain is the same as v’s domain.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
<emphasis role="bold">Vector</emphasis>(Vector&lt;T0, Block0&gt; const &amp;v);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>Block must be allocatable. The only specializations which
            must be supported are for T0 the same as T. An implementation is
            permitted to prevent instantiation for other choices of T0. Type
            T0 must be assignable to T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Equivalent to <code>Vector(Block(Domain&lt;1&gt;(v.size()),
            Block::map_type())); *this = v;</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Vector&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(const_Vector&lt;T0,Block0&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>v must be element-conformant with *this. *this and v must be
            order-independent assignment operands. The only specializations
            which must be supported are for T0 the same as T. An
            implementation is permitted to prevent instantiation for other
            choices of T0. Type T0 must be assignable to T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all index positions idx in the domain, v.get(idx) ==
            this-&gt;get(idx).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>Vector&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(const_reference_type val) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation if T
            is not scalar_f, scalar_i, or cscalar_f.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all index positions idx in the domain, this-&gt;get(idx)
            == val.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_vfill_i,
            vsip_vfill_f, and vsip_cvfill_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Vector&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(T0 const &amp;val) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation for
            T0 different than T. An implementation is permitted to prevent
            instantiation if T is not scalar_f, scalar_i, or cscalar_f. Type
            T0 must be assignable to T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all index positions idx in the domain,
            <code>this-&gt;get(idx) == val</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">~Vector</emphasis>() VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>If this object is the only one using its block, the block is
            deleted. Otherwise, its block’s use count is decremented by one.
            Regardless, the object is deallocated.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.vector.assign">
      <title>Assignment operators</title>

      <titleabbrev>view.vector.assign</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Vector, but not const_Vector, has assignment operators.</para>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator+=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>For T the same as scalar_f or scalar_i, the only
                specializations which must be supported are for T0 the same as
                T. For T the same as cscalar_f, the only specializations which
                must be supported are for T0 the same as scalar_f or
                cscalar_f. An implementation is permitted to prevent other
                instantiations. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) + v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This function corresponds to some of the functionality
                of VSIPL functions vsip_svadd_i, vsip_svadd_f, vsip_rscvadd_f,
                and vsip_csvadd_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator+=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator+=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. The only
                specializations which must be supported are for T0 the same as
                T. An implementation is permitted to prevent instantiation for
                other choices of T0. An implementation is permitted to prevent
                instantiation for T not the same as scalar_i, scalar_f, or
                cscalar_f. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) +
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator-=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>For T the same as scalar_f or scalar_i, the only
                specializations which must be supported are for T0 the same as
                T. For T the same as cscalar_f, the only specializations which
                must be supported are for T0 the same as scalar_f or
                cscalar_f. An implementation is permitted to prevent other
                instantiations. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) - v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator-=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator-=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. The only
                specializations which must be supported are for T0 the same as
                T. An implementation is permitted to prevent instantiation for
                other choices of T0. An implementation is permitted to prevent
                instantiation for T not the same as scalar_i, scalar_f, or
                cscalar_f. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) -
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator*=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>For T equal to scalar_f, the only specialization which
                must be supported is for T0 the same as T. For T the same as
                cscalar_f, the only specializations which must be supported
                are for T0 the same as scalar_f or cscalar_f. An
                implementation is permitted to prevent other instantiations.
                T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) * v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator*=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator*=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. The only
                specializations which must be supported are for T0 the same as
                T. An implementation is permitted to prevent instantiation for
                other choices of T0. An implementation is permitted to prevent
                instantiation for T not the same as scalar_i, scalar_f, or
                cscalar_f. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,<code>
                this-&gt;put(idx, this-&gt;get(idx) *
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator/=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>For T equal to scalar_f, the only specialization which
                must be supported is for T0 the same as T. For T the same as
                cscalar_f, the only specialization which must be supported is
                for T0 the same as scalar_f. An implementation is permitted to
                prevent other instantiations. T0 must be assignable to
                T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                this-&gt;put(idx, this-&gt;g<code>et(idx) / v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator/=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator/=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. The only
                specializations which must be supported are for T0 the same as
                T. An implementation is permitted to prevent instantiation for
                other choices of T0. An implementation is permitted to prevent
                instantiation for T not the same as scalar_i, scalar_f, or
                cscalar_f. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) /
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator&amp;=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                this-&gt;put(idx, this-&gt;get(idx) &amp; v).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator&amp;=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator&amp;=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation for any
                choice of T0. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,<code>
                this-&gt;put(idx, this-&gt;get(idx) &amp;
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator|=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) | v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator|=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator|=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation for any
                choice of T0. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,<code>
                this-&gt;put(idx, this-&gt;get(idx) |
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Vector &amp;<emphasis role="bold">operator^=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx)^ v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><code>*this</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator^=</emphasis>(const_Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Vector &amp;<emphasis role="bold">operator^=</emphasis>(Vector&lt;T0, Block0&gt; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v must be element-conformant with *this. *this and v
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation for any
                choice of T0. T0 must be assignable to T.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions idx in *this’s domain,
                <code>this-&gt;put(idx, this-&gt;get(idx) ^
                v.get(idx))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.vector.valaccess">
      <title>Value accessors</title>

      <titleabbrev>view.vector.valaccess</titleabbrev>

      <synopsis>reference_type <emphasis role="bold">operator()</emphasis>(index_type idx) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>This value accessor is provided only by Vector, not
            const_Vector. idx &lt; size(). An implementation should provide
            this accessor but is not required to do so.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The value at the index position idx.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>A VSIPL++ Library implemented using a VSIPL implementation
            cannot provide this accessor because VSIPL does not provide such
            functionality.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>const_reference_type <emphasis role="bold">operator()</emphasis>(index_type idx) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>idx &lt; size(). An implementation should provide this
            accessor but is not required to do so.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Value at the index position idx.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>A VSIPL++ Library implemented using a VSIPL implementation
            can provide this accessor but not its non-const version.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <orderedlist>
        <listitem>
          <para>[<emphasis>Note: </emphasis> const_Vector and Vector element
          access uses parentheses, not brackets, since parentheses, not
          brackets, are used for multi-dimensional views. ]</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.vector.subviews">
      <title>Subviews</title>

      <titleabbrev>view.vector.subviews</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These functions return subviews of a const_Vector or Vector
          object.</para>

          <synopsis>const_subview_type <emphasis role="bold">get</emphasis>(Domain&lt;1&gt; const &amp;d) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subset of the <emphasis>Vector</emphasis>’s
                domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview object of *this with domain
                Domain&lt;1&gt;(d.size()).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>subview_type <emphasis role="bold">operator()</emphasis>(Domain&lt;1&gt; const &amp;d) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Vector object. d is a subset of the
                Vector’s domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview Vector object of *this with domain
                Domain&lt;1&gt;(d.size()).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_subview_type <emphasis role="bold">operator()</emphasis>(Domain&lt;1&gt; const &amp;d) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subset of the <emphasis>Vector</emphasis>’s
                domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview object of *this with domain
                Domain&lt;1&gt;(d.size()).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>Vector &amp;<emphasis role="bold">operator()</emphasis>(whole_domain_type) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>This value accessor is provided only by Vector, not
                const_Vector. An implementation should provide this accessor
                but is not required to do so.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This operator only exists to prevent the expression
                vector(whole_domain) from matching the value access
                call-operator above.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_Vector &amp;<emphasis role="bold">operator()</emphasis>(whole_domain_type) const VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation should provide this accessor but is
                not required to do so.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This operator only exists to prevent the expression
                vector(whole_domain) from matching the value access
                call-operator above.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_realview_type <emphasis role="bold">real</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview const_Vector object of *this with the same
                domain but accessing only the real parts of the complex values
                of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>realview_type <emphasis role="bold">real</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Vector</emphasis> object of *this
                with the same domain but accessing only the real parts of the
                complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_imagview_type <emphasis role="bold">imag</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview const_Vector object of *this with the same
                domain but accessing only the imaginary parts of the complex
                values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>imagview_type <emphasis role="bold">imag</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Vector</emphasis> object of *this
                with the same domain but accessing only the imaginary parts of
                the complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.vector.accessors">
      <title>Accessors</title>

      <titleabbrev>view.vector.accessors</titleabbrev>

      <synopsis>block_type const &amp;<emphasis role="bold">block</emphasis>() const VSIP_NOTHROW;
block_type &amp;<emphasis role="bold">block</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The vector’s underlying block. const_Vector::block() returns
            a block_type const&amp; while Vector::block() returns a block_type
            &amp;.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">size</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of values in the vector.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">size</emphasis>(dimension_type) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>this-&gt;size()</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">length</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>this-&gt;size().</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.vector.convert">
      <title>Vector type conversion</title>

      <titleabbrev>view.vector.convert</titleabbrev>

      <orderedlist>
        <listitem>
          <para>[<emphasis>Note: </emphasis> The class ViewConversion converts
          between constant and non-constant view classes. ]</para>
        </listitem>

        <listitem>
          <para><type>ViewConversion&lt;Vector, T,
          Block&gt;::const_view_type</type> equals <type>const_Vector&lt;T,
          Block&gt;</type> and <type>ViewConversion&lt;Vector, T,
          Block&gt;::view_type</type> equals <type>Vector&lt;T,
          Block&gt;</type>.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section xml:id="view.matrix">
    <title>Matrix</title>

    <titleabbrev>view.matrix</titleabbrev>

    <orderedlist>
      <listitem>
        <para>The const_Matrix and Matrix classes are views implementing the
        mathematical idea of matrices, i.e., two-dimensional storage and
        access to values. A const_Matrix view is not modifiable, but a Matrix
        view is modifiable.</para>
      </listitem>

      <listitem>
        <para>The interfaces for const_Matrix and Matrix are similar so they
        are simultaneously specified except where noted. For these,
        <emphasis>Matrix</emphasis> indicates both const_Matrix and Matrix.
        The term “matrix” refers to a const_Matrix or Matrix object.</para>

        <para>Header <emphasis>&lt;vsip/matrix.hpp&gt;</emphasis>
        synopsis</para>

        <xi:include href="code/matrix.hpp"/>
      </listitem>
    </orderedlist>

    <section xml:id="view.matrix.template">
      <title>Template parameters</title>

      <titleabbrev>view.matrix.template</titleabbrev>

      <orderedlist>
        <listitem>
          <para>T specifies the type of values stored in the
          <emphasis>Matrix</emphasis> object which has an associated block
          with type Block for storing the values. The only specializations
          which must be supported have T the same as scalar_f, scalar_i,
          cscalar_f, cscalar_i, or bool. An implementation is permitted to
          prevent instantiation for other choices of T.</para>
        </listitem>

        <listitem>
          <synopsis>Block</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be Block::value_type. Block must be a
                two-dimensional block.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Block need not be modifiable.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.matrix.subview_types">
      <title>Subview Types</title>

      <titleabbrev>view.matrix.subview_types</titleabbrev>

      <orderedlist>
        <listitem>
          <para><type>subview_type</type> specifies the type of a
          two-dimensional subview of a <emphasis>Matrix</emphasis>. The type
          is a <emphasis>Matrix</emphasis> with value type T and an
          unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>const_subview_type</type> specifies the type of a
          non-modifiable two-dimensional subview of a Matrix. The type is a
          const_Matrix with value type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>col_type</type> specifies the type of a column subview
          of a <emphasis>Matrix</emphasis>. The type is a
          <emphasis>Vector</emphasis> with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_col_type</type> specifies the type of a
          non-modifiable column subview of a <emphasis>Matrix</emphasis>. The
          type is a const_Vector with value type T and an unspecified block
          type.</para>
        </listitem>

        <listitem>
          <para><type>diag_type</type> specifies the type of a diagonal
          subview of a <emphasis>Matrix</emphasis>. The type is a
          <emphasis>Vector</emphasis> with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_diag_type</type> specifies the type of a
          non-modifiable diagonal subview of a <emphasis>Matrix</emphasis>.
          The type is a const_Vector with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>row_type</type> specifies the type of a row subview of a
          <emphasis>Matrix</emphasis>. The type is a
          <emphasis>Vector</emphasis> with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_row_type</type> specifies the type of a
          non-modifiable row subview of a <emphasis>Matrix</emphasis>. The
          type is a const_Vector with value type T and an unspecified block
          type.</para>
        </listitem>

        <listitem>
          <para><type>transpose_type</type> specifies the type of a
          two-dimensional transpose subview of a <emphasis>Matrix</emphasis>.
          The type is a <emphasis>Matrix</emphasis> with value type T and an
          unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>const_transpose_type</type> specifies the type of a
          non-modifiable two-dimensional transpose subview of a
          <emphasis>Matrix</emphasis>. The type is a const_Matrix with value
          type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>realview_type</type> specifies the type of a subview of
          a <emphasis>Matrix</emphasis> containing only the real parts of the
          <emphasis>Matrix</emphasis>’s values. This type is defined only if T
          is a complex type complex&lt;Tp&gt;. The type is a
          <emphasis>Matrix</emphasis> with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_realview_type</type> specifies the type of a
          non-modifiable subview of a <emphasis>Matrix</emphasis> containing
          only the real parts of the <emphasis>Matrix</emphasis>’s values.
          This type is defined only if T is a complex type complex&lt;Tp&gt;.
          The type is a <type>const_Matrix</type> with value type Tp and an
          unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>imagview_type</type> specifies the type of a subview of
          a <emphasis>Matrix</emphasis> containing only the imaginary parts of
          the <emphasis>Matrix</emphasis>’s values. This type is defined only
          if T is a complex type complex&lt;Tp&gt;. The type is a
          <emphasis>Matrix</emphasis> with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_imagview_type</type> specifies the type of a
          non-modifiable subview of a <emphasis>Matrix</emphasis> containing
          only the imaginary parts of the <emphasis>Matrix</emphasis>’s
          values. This type is defined only if T is a complex type
          complex&lt;Tp&gt;. The type is a const_Matrix with value type Tp and
          an unspecified block type.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.matrix.constructors">
      <title>Constructors, copy, assignment, and destructor</title>

      <titleabbrev>view.matrix.constructors</titleabbrev>

      <synopsis><emphasis role="bold">Matrix</emphasis>(length_type number_of_rows, length_type number_of_columns, T const &amp;value);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>row_length &gt; 0 and column_length &gt; 0. Block must be
            allocatable. Block::map_type must have a default
            constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to
            <emphasis>Matrix</emphasis>(Block(Domain&lt;2&gt;(number_of_rows,
            number_of_columns), value, Block::map_type())).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes:</term>

          <listitem>
            <para>Blocks are created with the effect of increment_count,
            Matrix does not invoke increment_count again for blocks it
            allocates.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Matrix</emphasis>(length_type number_of_rows, length_type number_of_columns);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>row_length &gt; 0 and column_length &gt; 0. Block must be
            allocatable. Block::map_type must have a default
            constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to
            <emphasis>Matrix</emphasis>(Block(Domain&lt;2&gt;(number_of_rows,
            number_of_columns), Block::map_type())).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes:</term>

          <listitem>
            <para>Blocks are created with the effect of increment_count,
            Matrix does not invoke increment_count again for blocks it
            allocates.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Matrix</emphasis>(Block &amp;block) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>2-dimensional modifiable block.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a Matrix m with associated block block.
            <code>m.size(0) == block.size(2,0)</code>. <code>m.size(1) ==
            block.size(2,1)</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">const_Matrix</emphasis>(Block &amp;block) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>2-dimensional block.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a const_Matrix m with associated block block.
            <code>m.size(0) == block.size(2,0)</code>. <code>m.size(1) ==
            block.size(2,1)</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Matrix</emphasis>(<emphasis>Matrix</emphasis> const &amp;m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a subview <emphasis>Matrix</emphasis> object of m
            such that its domain is the same as m’s domain.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">const_Matrix</emphasis>(Matrix const &amp;m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a subview const_Matrix object of m such that its
            domain is the same as m’s domain.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
<emphasis role="bold">Matrix</emphasis>(Matrix&lt;T0, Block0&gt; const &amp;m);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>Block must be allocatable. The only specializations which
            must be supported are for T0 the same as T. An implementation is
            permitted to prevent instantiation for other choices of T0. Type
            T0 must be assignable to T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to <code>Matrix(Block(Domain&lt;2&gt;(m.size(0),
            m.size(1)), Block::map_type())); *this = m;</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0,
          typename Block0&gt;
Matrix&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(const_Matrix&lt;T0,Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this. *this and m must be
            order-independent assignment operands. The only specializations
            which must be supported are for T0 the same as T. An
            implementation is permitted to prevent instantiation for other
            choices of T0. Type T0 must be assignable to T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all Index&lt;2&gt; positions {(idx0,idx1)} in the
            domain, m.get(idx0,idx1) == this-&gt;get(idx0,idx1).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>Matrix&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(const_reference_type val) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation if T
            is not scalar_f, scalar_i, or cscalar_f.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all Index&lt;2&gt; positions {(idx0,idx1)} in the
            domain, this-&gt;get(idx0,idx1) == val.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_mfill_i,
            vsip_mfill_f, and vsip_cmfill_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(T0 const &amp;val) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation for
            T0 different than T. Type T0 must be assignable to T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all Index&lt;2&gt; positions {(idx0,idx1)} in the
            domain, this-&gt;get(idx0,idx1) == val.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">~Matrix</emphasis>() VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>If this object is the only one using its block, the block is
            deallocated. Otherwise, its block’s use count is decremented by
            one. Regardless, *this is deallocated.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.matrix.assign">
      <title>Assignment operators</title>

      <titleabbrev>view.matrix.assign</titleabbrev>

      <synopsis>
template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator+=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>For T the same as scalar_f or scalar_i, the only
            specializations which must be supported are for T0 the same as T .
            For T the same as cscalar_f, the only specializations which must
            be supported are for T0 the same as scalar_f or cscalar_f . An
            implementation is permitted to prevent other instantiations. T0
            must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in <code>*this</code>’s
            domain, <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) +
            v)</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to some of the functionality of
            VSIPL functions vsip_smadd_i, vsip_smadd_f, vsip_rscmadd_f, and
            vsip_csmadd_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator+=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator+=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. The only specializations
            which must be supported are for T0 the same as T . An
            implementation is permitted to prevent instantiation for other
            choices of T0 . An implementation is permitted to prevent
            instantiation for T not the same as scalar_i, scalar_f, or
            cscalar_f . T0 must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) +
            m.get(idx0, idx1))</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator-=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>For T the same as scalar_f or scalar_i, the only
            specializations which must be supported are for T0 the same as T .
            For T the same as cscalar_f, the only specializations which must
            be supported are for T0 the same as scalar_f or cscalar_f . An
            implementation is permitted to prevent other instantiations. T0
            must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s
            domain,<code> this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) -
            v) </code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator-=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator-=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. The only specializations
            which must be supported are for T0 the same as T . An
            implementation is permitted to prevent instantiation for other
            choices of T0 . An implementation is permitted to prevent
            instantiation for T not the same as scalar_i, scalar_f, or
            cscalar_f . T0 must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) -
            m.get(idx0, idx1))</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator*=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>For T equal to scalar_f, the only specialization which must
            be supported is for T0 the same as T . For T the same as
            cscalar_f, the only specializations which must be supported are
            for T0 the same as scalar_f or cscalar_f . An implementation is
            permitted to prevent other instantiations. T0 must be assignable
            to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) *
            v)</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator*=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator*=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. The only specializations
            which must be supported are for T0 the same as T . An
            implementation is permitted to prevent instantiation for other
            choices of T0 . An implementation is permitted to prevent
            instantiation for T not the same as scalar_i, scalar_f, or
            cscalar_f . T0 must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) *
            m.get(idx0, idx1))</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator/=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>For T equal to scalar_f, the only specialization which must
            be supported is for T0 the same as T . For T the same as
            cscalar_f, the only specialization which must be supported is for
            T0 the same as scalar_f . An implementation is permitted to
            prevent other instantiations. T0 must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) /
            v)</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator/=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator/=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. The only specializations
            which must be supported are for T0 the same as T . An
            implementation is permitted to prevent instantiation for other
            choices of T0 . An implementation is permitted to prevent
            instantiation for T not the same as scalar_i, scalar_f, or
            cscalar_f . T0 must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) /
            m.get(idx0, idx1))</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator&amp;=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation. T0
            must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) &amp;
            v)</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator&amp;=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator&amp;=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. An implementation is
            permitted to prevent instantiation for any choice of T0 . T0 must
            be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in <code>*this</code>’s
            domain, <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1)
            &amp; m.get(idx0, idx1))</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator|=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation. T0
            must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in <code>*this</code>’s
            domain, <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) |
            v)</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator|=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator|=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. An implementation is
            permitted to prevent instantiation for any choice of T0 . T0 must
            be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) |
            m.get(idx0, idx1))</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>*this</code> .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Matrix &amp;<emphasis role="bold">operator ^=</emphasis>(T0 const &amp;v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation. T0
            must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in <code>*this</code>’s
            domain, <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) ^
            v)</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator ^=</emphasis>(const_Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;

template &lt;typename T0, typename Block0&gt;
Matrix &amp;<emphasis role="bold">operator ^=</emphasis>(Matrix&lt;T0, Block0&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be element-conformant with *this . *this and m must
            be order-independent assignment operands. An implementation is
            permitted to prevent instantiation for any choice of T0 . T0 must
            be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For all index positions (idx0, idx1) in *this’s domain,
            <code>this-&gt;put(idx0, idx1, this-&gt;get(idx0, idx1) ^
            m.get(idx0, idx1))</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this .</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.matrix.valaccess">
      <title>Value accessors</title>

      <titleabbrev>view.matrix.valaccess</titleabbrev>

      <para>[<emphasis>Note: </emphasis> The restrictions for get and put
      follow from the view requirements in <xref linkend="view.view"/>. Only
      additional restrictions occur here. ]</para>

      <synopsis>
reference_type <emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>This value accessor is provided only by Matrix, not
            const_Matrix. idx0 &lt; this-&gt;size(0) and idx1 &lt;
            this-&gt;size(1). An implementation should provide this accessor
            but is not required to do so.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Value at the Index&lt;2&gt; position (idx0,idx1).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>A VSIPL++ Library implemented using a VSIPL implementation
            cannot provide this accessor because VSIPL does not provide such
            functionality.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>const_reference_type <emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>idx0 &lt; this-&gt;size(0)</code> and <code>idx1 &lt;
            this-&gt;size(1)</code>. An implementation should provide this
            accessor but is not required to do so.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Value at the Index&lt;2&gt; position (idx0, idx1).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>A VSIPL++ Library implemented using a VSIPL implementation
            can provide this accessor but not its non-const version.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.matrix.subviews">
      <title>Subviews</title>

      <titleabbrev>view.matrix.subviews</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These functions return subviews of a const_Matrix or Matrix
          object.</para>

          <synopsis>
const_subview_type <emphasis role="bold">get</emphasis>(Domain&lt;2&gt; const&amp; d) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subset of the <emphasis>Matrix</emphasis>’s
                domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Matrix</emphasis> object of
                <code>*this</code> with domain
                <code>Domain&lt;2&gt;(d[0].size(), d[1].size())</code>
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>subview_type <emphasis role="bold">operator()</emphasis>(Domain&lt;2&gt; const&amp; d) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>*this</code> must be a Matrix object. d is a
                subset of the Matrix’s domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview Matrix object of <code>*this</code> with
                domain <code>Domain&lt;2&gt;(d[0].size(), d[1].size())</code>
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_subview_type <emphasis role="bold">operator()</emphasis>(Domain&lt;2&gt; const &amp;d) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subset of the <emphasis>Matrix</emphasis>’s
                domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Matrix</emphasis> object of
                <code>*this</code> with domain
                <code>Domain&lt;2&gt;(d[0].size(), d[1].size())</code>
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>col_type <emphasis role="bold">col</emphasis>(index_type column_index) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>*this</code> must be a Matrix object.
                <code>column_index &lt; this-&gt;size(1)</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Matrix</type> object containing
                the specified column number column_index with domain
                <code>Domain&lt;1&gt;(this-&gt;size(0))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_col_type <emphasis role="bold">col</emphasis>(index_type column_index) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>column_index &lt; this-&gt;size(1) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <emphasis>Matrix</emphasis> object
                containing the specified column number column_index with
                domain Domain&lt;1&gt;(this-&gt;size(0)).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>col_type <emphasis role="bold">operator()</emphasis>(whole_domain_type, index_type column_index) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>Same as <code>col(column_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Same as <code>col(column_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>Same as <code>col(column_index)</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_col_type <emphasis role="bold">operator()</emphasis>(whole_domain_type, index_type column_index) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>Same as <code>col(column_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Same as <code>col(column_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>Same as <code>col(column_index)</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>diag_type <emphasis role="bold">diag</emphasis>(index_difference_type diagonal_offset = 0) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>*this</code> must be a Matrix object. If
                diagonal_offset is positive, <code>diagonal_offset &lt;
                this-&gt;size(1)</code> . If diagonal_offset is negative,
                <code>-diagonal_offset &lt; this-&gt;size(0)</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>If <code>diagonal_offset == 0</code>, a subview of the
                Matrix object containing its diagonal values. If
                <code>diagonal_offset &gt; 0</code>, return a subview of the
                Matrix object containing values in the diagonal
                diagonal_offset above the main diagonal. Its domain is
                <code>Domain&lt;1&gt;(min(this-&gt;size(0), this-&gt;size(1) -
                diagonal_offset))</code>. If <code>diagonal_offset &lt;
                0</code>, return a subview of the Matrix object containing
                values in the diagonal diagonal_offset below the main
                diagonal. Its domain is
                <code>Domain&lt;1&gt;(min(this-&gt;size(0) + diagonal_offset,
                this-&gt;size(1)))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_diag_type <emphasis role="bold">diag</emphasis>(index_difference_type diagonal_offset = 0) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>If diagonal_offset is positive, <code>diagonal_offset
                &lt; this-&gt;size(1)</code> . If diagonal_offset is negative,
                <code>-diagonal_offset &lt; this-&gt;size(0)</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>If <code>diagonal_offset == 0</code>, a subview of the
                <emphasis>Matrix</emphasis> object containing its diagonal
                values. If <code>diagonal_offset &gt; 0</code>, return a
                subview of the <emphasis>Matrix</emphasis> object containing
                values in the diagonal diagonal_offset above the main
                diagonal. Its domain is
                <code>Domain&lt;1&gt;(min(this-&gt;size(0), this-&gt;size(1) -
                diagonal_offset))</code>. If <code>diagonal_offset &lt;
                0</code>, return a subview of the <emphasis>Matrix</emphasis>
                object containing values in the diagonal diagonal_offset below
                the main diagonal. Its domain is
                <code>Domain&lt;1&gt;(min(this-&gt;size(0) + diagonal_offset,
                this-&gt;size(1)))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>row_type <emphasis role="bold">row</emphasis>(index_type row_index) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>*this</code> must be a Matrix object.
                <code>row_index &lt; this-&gt;size(0)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Matrix</type> object containing
                the specified row number row_index and having domain
                <code>Domain&lt;1&gt;(this-&gt;size(1))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_row_type <emphasis role="bold">row</emphasis>(index_type row_index) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>row_index &lt; this-&gt;size(0)</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Matrix</type> object containing
                the specified row number row_index and having domain
                <code>Domain&lt;1&gt;(this-&gt;size(1))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>row_type <emphasis role="bold">operator()</emphasis>(index_type row_index, whole_domain_type) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>Same as <code>row(row_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Same as <code>row(row_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>Same as <code>row(row_index)</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_row_type <emphasis role="bold">operator()</emphasis>(index_type row_index, whole_domain_type) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>Same as <code>row(row_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Same as<code> row(row_index)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>Same as <code>row(row_index)</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>transpose_type <emphasis role="bold">transpose</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>*this</code> must be a Matrix object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Matrix</type> object containing
                its transpose and having domain
                <code>Domain&lt;2&gt;(this-&gt;size(1),
                this-&gt;size(0))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>The result is a subview of the original view so
                modifying values in the original view also changes values in
                the subview. Many implementations will choose to implement
                this subview by reordering indices. See <xref
                linkend="math.matvec.transpose"/> for an alternate transpose
                implementation.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_transpose_type <emphasis role="bold">transpose</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Matrix</type> object containing
                its transpose and having domain
                <code>Domain&lt;2&gt;(this-&gt;size(1),
                this-&gt;size(0))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>The result is a subview of the original view. Many
                implementations will choose to implement this subview by
                reordering indices. See <xref
                linkend="math.matvec.transpose"/> for an alternate transpose
                implementation.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_realview_type <emphasis role="bold">real</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><type>T</type> must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <type>const_Matrix</type> object of
                <code>*this</code> with the same domain but accessing only the
                real parts of the complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>realview_type <emphasis role="bold">real</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><type>T</type> must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Matrix</emphasis> object of
                <code>*this</code> with the same domain but accessing only the
                real parts of the complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_imagview_type <emphasis role="bold">imag</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><type>T</type> must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <type>const_Matrix</type> object of
                <code>*this</code> with the same domain but accessing only the
                imaginary parts of the complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>imagview_type <emphasis role="bold">imag</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><type>T</type> must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis><type>Matrix</type></emphasis>
                object of <code>*this</code> with the same domain but
                accessing only the imaginary parts of the complex values of
                the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para><type>std::bad_alloc</type> indicating memory allocation
                for the underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.matrix.accessors">
      <title>Accessors</title>

      <titleabbrev>view.matrix.accessors</titleabbrev>

      <synopsis>
block_type const &amp;<emphasis role="bold">block</emphasis>() const VSIP_NOTHROW;
block_type &amp;<emphasis role="bold">block</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix’s underlying block.
            <code>const_Matrix::block()</code> returns a <code>block_type
            const&amp;</code> while <code>Matrix::block()</code> returns a
            <code>block_type &amp;</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">size</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of values in the matrix.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">size</emphasis>(dimension_type d) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>0 &lt;= d &amp;&amp; d &lt;= 1 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of values in the specified dimension.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.matrix.convert">
      <title>Matrix type conversion</title>

      <titleabbrev>view.matrix.convert</titleabbrev>

      <orderedlist>
        <listitem>
          <para>[<emphasis>Note: </emphasis> The class ViewConversion converts
          between constant and non-constant view classes. ]</para>
        </listitem>

        <listitem>
          <para>ViewConversion&lt;<emphasis>Matrix</emphasis>, T,
          Block&gt;::const_view_type equals const_Matrix&lt;T, Block&gt; and
          ViewConversion&lt;<emphasis>Matrix</emphasis>, T,
          Block&gt;::view_type equals Matrix&lt;T, Block&gt;.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section xml:id="view.tensor">
    <title>Tensor</title>

    <titleabbrev>view.tensor</titleabbrev>

    <orderedlist>
      <listitem>
        <para>The <type>const_Tensor</type> and <type>Tensor</type> classes
        are views implementing the mathematical idea of tensors. A
        <type>const_Tensor</type> view is not modifiable, but a
        <type>Tensor</type> view is modifiable.</para>
      </listitem>

      <listitem>
        <para>The interfaces for const_Tensor and Tensor are similar so they
        are simultaneously specified except where noted. For these,
        <emphasis>Tensor</emphasis> indicates both const_Tensor and Tensor.
        The term “tensor” refers to a const_Tensor or Tensor object.</para>

        <para>Header <emphasis>&lt;vsip/tensor.hpp&gt;</emphasis>
        synopsis</para>

        <xi:include href="code/tensor.hpp"/>
      </listitem>
    </orderedlist>

    <section xml:id="view.tensor.template">
      <title>Template parameters</title>

      <titleabbrev>view.tensor.template</titleabbrev>

      <orderedlist>
        <listitem>
          <para>T specifies the type of values stored in the
          <emphasis>Tensor</emphasis> object which has an associated block
          with type Block for storing the values. The only specializations
          which must be supported have T the same as scalar_f, scalar_i,
          cscalar_f, cscalar_i, or bool . An implementation is permitted to
          prevent instantiation for other choices of T .</para>
        </listitem>

        <listitem>
          <synopsis>Block</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be <type>Block::value_type</type> . Block must be
                a three-dimensional block.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Block need not be modifiable.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.tensor.subview_types">
      <title>Subview Types</title>

      <titleabbrev>view.tensor.subview_types</titleabbrev>

      <orderedlist>
        <listitem>
          <para><type>subview_type</type> specifies the type of a
          three-dimensional subview of a <emphasis>Tensor</emphasis> . The
          type is a <emphasis>Tensor</emphasis> with value type T and an
          unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>const_subview_type</type> specifies the type of a
          non-modifiable three-dimensional subview of a
          <emphasis>Tensor</emphasis> . The type is a const_Tensor with value
          type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>subvector&lt;D1, D2&gt;::type</type> (where D1 and D2
          are dimension_types) specifies the type of a one-dimensional
          whole-domain subview of a <emphasis>Tensor</emphasis> with
          fixed-dimensions D1 and D2. The type is a
          <emphasis>Vector</emphasis> with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>subvector&lt;D1, D2&gt;::const_type</type> (where D1 and
          D2 are dimension_types) specifies the type of a non-modifiable
          one-dimensional whole-domain subview of a
          <emphasis>Tensor</emphasis> with fixed-dimensions D1 and D2. The
          type is a const_Vector with value type T and an unspecified block
          type.</para>
        </listitem>

        <listitem>
          <para><type>subvector&lt;D1, D2&gt;::subset_type</type> (where D1
          and D2 are dimension_types) specifies the type of a one-dimensional
          subset-domain subview of a <emphasis>Tensor</emphasis> with
          fixed-dimensions D1 and D2. The type is a
          <emphasis>Vector</emphasis> with value type T and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>subvector&lt;D1, D2&gt;::const_subset_type</type> (where
          D1 and D2 are dimension_types) specifies the type of a
          non-modifiable one-dimensional subset-domain subview of a
          <emphasis>Tensor</emphasis> with fixed-dimensions D1 and D2. The
          type is a const_Vector with value type T and an unspecified block
          type.</para>
        </listitem>

        <listitem>
          <para><type>submatrix&lt;D&gt;::type</type> (where D is a
          dimension_type) specifies the type of a two-dimensional whole-domain
          subview of a <emphasis>Tensor</emphasis> with fixed-dimension D. The
          type is a <emphasis>Matrix</emphasis> with value type T and an
          unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>submatrix&lt;D&gt;::const_type</type> (where D is a
          dimension_type) specifies the type of a non-modifiable
          two-dimensional whole-domain subview of a
          <emphasis>Tensor</emphasis> with fixed-dimension D. The type is a
          const_Matrix with value type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>submatrix&lt;D&gt;::subset_type</type> (where D is a
          dimension_type) specifies the type of a two-dimensional
          subset-domain subview of a <emphasis>Tensor</emphasis> with
          fixed-dimension D. The type is a <emphasis>Matrix</emphasis> with
          value type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>submatrix&lt;D&gt;::const_subset_type</type> (where D is
          a dimension_type) specifies the type of a non-modifiable
          two-dimensional subset-domain subview of a
          <emphasis>Tensor</emphasis> with fixed-dimension D. The type is a
          const_Matrix with value type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>transpose_view&lt;D0, D1, D2&gt;::type</type> specifies
          the type of a three-dimensional transpose subview of a
          <emphasis>Tensor</emphasis> for dimension permutation
          <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>D</m:mi>

                    <m:mn>0</m:mn>

                    <m:mo>,</m:mo>

                    <m:mi>D</m:mi>

                    <m:mn>1</m:mn>

                    <m:mo>,</m:mo>

                    <m:mi>D</m:mi>

                    <m:mn>2</m:mn>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>. The type is a <emphasis>Tensor</emphasis> with
          value type T and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>transpose_view&lt;D0, D1, D2&gt;::const_type</type>
          specifies the type of a non-modifiable, three-dimensional transpose
          subview of a <emphasis>Tensor</emphasis> for dimension permutation
          <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>D</m:mi>

                    <m:mn>0</m:mn>

                    <m:mo>,</m:mo>

                    <m:mi>D</m:mi>

                    <m:mn>1</m:mn>

                    <m:mo>,</m:mo>

                    <m:mi>D</m:mi>

                    <m:mn>2</m:mn>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>. The type is a const_Tensor with value type T
          and an unspecified block type.</para>
        </listitem>

        <listitem>
          <para><type>realview_type</type> specifies the type of a subview of
          a <emphasis>Tensor</emphasis> containing only the real parts of the
          <emphasis>Tensor</emphasis>’s values. This type is defined only if T
          is a complex type complex&lt;Tp&gt;. The type is a
          <emphasis>Tensor</emphasis> with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_realview_type</type> specifies the type of a
          non-modifiable subview of a <emphasis>Tensor</emphasis> containing
          only the real parts of the <emphasis>Tensor</emphasis>’s values.
          This type is defined only if T is a complex type complex&lt;Tp&gt;.
          The type is a const_Tensor with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>imagview_type</type> specifies the type of a subview of
          a <emphasis>Tensor</emphasis> containing only the imaginary parts of
          the <emphasis>Tensor</emphasis>’s values. This type is defined only
          if T is a complex type complex&lt;Tp&gt;. The type is a
          <emphasis>Tensor</emphasis> with value type Tp and an unspecified
          block type.</para>
        </listitem>

        <listitem>
          <para><type>const_imagview_type</type> specifies the type of a
          non-modifiable subview of a <emphasis>Tensor</emphasis> containing
          only the imaginary parts of the <emphasis>Tensor</emphasis>’s
          values. This type is defined only if T is a complex type
          complex&lt;Tp&gt;. The type is a const_Tensor with value type Tp and
          an unspecified block type.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.tensor.constructors">
      <title>Constructors, copy, assignment, and destructor</title>

      <titleabbrev>view.tensor.constructors</titleabbrev>

      <synopsis><emphasis role="bold">Tensor</emphasis>(length_type z_length, length_type y_length, length_type x_length, T const&amp;  value);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>z_length &gt; 0 &amp;&amp; y_length &gt; 0 &amp;&amp;
            x_length &gt; 0</code>. Block must be allocatable. Block::map_type
            must have a default constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to <code>Tensor(Block(Domain&lt;3&gt;(z_length,
            y_length, x_length), value, Block::map_type()))</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes:</term>

          <listitem>
            <para>Blocks are created with the effect of increment_count,
            Tensor does not invoke increment_count again for blocks it
            allocates.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Tensor</emphasis>(length_type z_length, length_type y_length, length_type x_length);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>z_length &gt; 0 &amp;&amp; y_length &gt; 0 &amp;&amp;
            x_length &gt; 0</code>. Block must be allocatable. Block::map_type
            must have a default constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to <code>Tensor(Block(Domain&lt;3&gt;(z_length,
            y_length, x_length), Block::map_type()))</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes:</term>

          <listitem>
            <para>Blocks are created with the effect of increment_count,
            Tensor does not invoke increment_count again for blocks it
            allocates.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Tensor</emphasis>(Block&amp; block) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>3-dimensional modifiable block .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a Tensor t with associated block block .
            <code>t.size(0) == block.size(3,0)</code> . <code>t.size(1) ==
            block.size(3,1)</code> . <code>t.size(2) == block.size(3,2)</code>
            .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">const_Tensor</emphasis>(Block&amp; block) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>3-dimensional block .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a const_Tensor t with associated block block .
            <code>t.size(0) == block.size(3,0)</code> .<code> t.size(1) ==
            block.size(3,1)</code> . <code>t.size(2) == block.size(3,2)</code>
            .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">Tensor</emphasis>(<emphasis>Tensor</emphasis> const&amp; t) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a subview <emphasis>Tensor</emphasis> object of t
            such that its domain is the same as t’s domain.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis><emphasis role="bold">const_Tensor</emphasis>(Tensor const&amp; t) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a subview const_Tensor object of t such that its
            domain is the same as t’s domain.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0,
          typename Block0&gt;
<emphasis role="bold">Tensor</emphasis>(Tensor&lt;T0, Block0&gt; const&amp; t);</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>Block must be allocatable. The only specifications which
            must be supported are for T0 the same as T. An implementation is
            permitted to prevent instantiation. Type T0 must be assignable to
            T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Identical to <code>Tensor(Block(Domain&lt;3&gt;(t.size(0),
            t.size(1), t.size(2)), Block::map_type())); *this =
            t;</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(const_Tensor&lt;T0,Block0&gt; t) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>t must be element-conformant with *this . *this and t must
            be order-independent assignment operands. An implementation is
            permitted to prevent instantiation. Type T0 must be assignable to
            T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all Index&lt;3&gt; positions (idx0, idx1, idx2) in
            *this’s domain, <code>t.get(idx0,idx1,idx2) ==
            this-&gt;get(idx0,idx1,idx2)</code>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>Tensor&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(const_reference_type val) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent
            instantiation.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all Index&lt;3&gt; positions (idx0,idx1,idx2) in *this’s
            domain, this-&gt;get(idx0,idx1,idx2) == val .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0&gt;
Tensor&lt;T,Block&gt; &amp;<emphasis role="bold">operator=</emphasis>(T0 const&amp; val) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>An implementation is permitted to prevent instantiation.
            Type T0 must be assignable to T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>*this .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For all Index&lt;3&gt; positions (idx0,idx1,idx2) in *this’s
            domain, <code>this-&gt;get(idx0,idx1,idx2) == val</code> .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis> <emphasis role="bold">~Tensor</emphasis>() VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>If this object is the only one using its block, the block is
            deallocated. Otherwise, its block’s use count is decremented by
            one. Regardless, the object is deallocated.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.tensor.assign">
      <title>Assignment operators</title>

      <titleabbrev>view.tensor.assign</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Tensor, but not const_Tensor, has assignment operators.</para>

          <synopsis>template &lt;typename T0&gt;
Tensor&amp;<emphasis role="bold">operator+=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, this-&gt;put(idx0, idx1, idx2, this-&gt;get(idx0,
                idx1, idx2) + v) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator+=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator+=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation. T0 must
                be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) + t.get(idx0, idx1,
                idx2))</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Tensor &amp;<emphasis role="bold">operator-=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) - v)</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator-=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator-=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation. T0 must
                be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, this-&gt;put(idx0, idx1, idx2,
                <code>this-&gt;get(idx0, idx1, idx2) - t.get(idx0, idx1,
                idx2))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Tensor &amp;<emphasis role="bold">operator*=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) * v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator*=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator*=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation. T0 must
                be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) * t.get(idx0, idx1,
                idx2))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Tensor &amp;<emphasis role="bold">operator/=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain,<code> this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) / v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator/=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator/=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation. T0 must
                be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) / t.get(idx0, idx1,
                idx2))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Tensor &amp;<emphasis role="bold">operator&amp;=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) &amp; v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator&amp;=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator&amp;=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation for any
                choice of T0 . T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, this-&gt;put(idx0, idx1, idx2, this-&gt;get(idx0,
                idx1, idx2) &amp; t.get(idx0, idx1, idx2)).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Tensor &amp;<emphasis role="bold">operator|=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, this-&gt;put(idx0, idx1, idx2, this-&gt;get(idx0,
                idx1, idx2) | v) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator|=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator|=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation for any
                choice of T0 . T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain,<code> this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) | t.get(idx0, idx1,
                idx2))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0&gt;
Tensor &amp;<emphasis role="bold">operator^=</emphasis>(T0 const&amp; v) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>An implementation is permitted to prevent instantiation.
                T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) ^ v)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><code>*this</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator^=</emphasis>(const_Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;

template &lt;typename T0,
          typename Block0&gt;
Tensor &amp;<emphasis role="bold">operator^=</emphasis>(Tensor&lt;T0, Block0&gt; t) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>t must be element-conformant with *this . *this and t
                must be order-independent assignment operands. An
                implementation is permitted to prevent instantiation for any
                choice of T0 . T0 must be assignable to T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Effects:</term>

              <listitem>
                <para>For all index positions (idx0, idx1, idx2) in *this’s
                domain, <code>this-&gt;put(idx0, idx1, idx2,
                this-&gt;get(idx0, idx1, idx2) ^ t.get(idx0, idx1,
                idx2))</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>*this .</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.tensor.transpose">
      <title>Transpositions</title>

      <titleabbrev>view.tensor.transpose</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These functions return transpositions of a
          <emphasis>Tensor</emphasis> object.</para>

          <synopsis>template &lt;dimension_type D0,
          dimension_type D1,
          dimension_type D2&gt;
typename transpose_view&lt;D0, D1, D2&gt;::const_type <emphasis role="bold">transpose</emphasis>() const VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>D0 &lt; 3 &amp;&amp; D1 &lt; 3 &amp;&amp; D2 &lt;
                3</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Tensor</type> object containing a
                transposition of the specified dimensions. The <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>, <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>, and <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> dimensions are numbered 0, 1, and 2,
                respectively. D0 should indicate dimension_0 of the transposed
                subview. D1 and D2 are similar.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>It is legal for D0 == 0 &amp;&amp; D1 = 1 &amp;&amp;_D2
                = 2, but this yields a subview equal to
                <code>*this</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;dimension_type D0,
          dimension_type D1,
          dimension_type D2&gt;
typename transpose_view&lt;D0, D1, D2&gt;::type <emphasis role="bold">transpose</emphasis>() VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><code>*this</code> must be a <type>Tensor</type> object.
                <code>D0 &lt; 3 &amp;&amp; D1 &lt; 3 &amp;&amp; D2 &lt;
                3</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview of the <type>Tensor</type> object containing a
                transposition of the specified dimensions. The <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>, <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>, and <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> dimensions are numbered 0, 1, and 2,
                respectively. D0 should indicate dimension 0 of the transposed
                subview. D1 and D2 are similar.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>It is legal for <code>D0 == 0 &amp;&amp; D1 = 1
                &amp;&amp; D2 = 2</code>, but this yields a subview equal to
                <code>*this</code>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.tensor.valaccess">
      <title>Value accessors</title>

      <titleabbrev>view.tensor.valaccess</titleabbrev>

      <para>[<emphasis>Note: </emphasis> The restrictions for get and put
      follow from the view requirements in <xref linkend="view.view"/>. Only
      additional restrictions occur here. ]</para>

      <synopsis>reference_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1, index_type idx2) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>This value accessor is provided only by Tensor, not
            const_Tensor. <code>idx0 &lt; this-&gt;size(0)</code>, <code>idx1
            &lt; this-&gt;size(1)</code>, and <code>idx2 &lt;
            this-&gt;size(2)</code>. An implementation should provide this
            accessor but is not required to do so.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Value at the Index&lt;3&gt; position
            (idx0,idx1,idx2).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>A VSIPL++ Library implemented using a VSIPL implementation
            cannot provide this accessor because VSIPL does not provide such
            functionality.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>const_reference_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1, index_type idx2) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>idx0 &lt; size(0), idx1 &lt; size(1), and idx2 &lt; size(2)
            . An implementation should provide this accessor but is not
            required to do so.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Value at the Index&lt;3&gt; position
            (idx0,idx1,idx2).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>A VSIPL++ Library implemented using a VSIPL implementation
            can provide this accessor but not its non-const version.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.tensor.subviews">
      <title>Subviews</title>

      <titleabbrev>view.tensor.subviews</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These functions return subviews of a const_Tensor or Tensor
          object.</para>

          <synopsis>const_subview_type
<emphasis role="bold">get</emphasis>(Domain&lt;3&gt; const&amp; d) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subset of the <type>Tensor</type>’s
                domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview object of <code>*this</code> with domain
                <code>Domain&lt;3&gt;(d[0].size(), d[1].size(),
                d[2].size())</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>subview_type
<emphasis role="bold">operator()</emphasis>(Domain&lt;3&gt; const&amp; d) VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. d is a subset of the
                Tensor’s domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview Tensor object of *this with domain
                <code>Domain&lt;3&gt;(d[0].size(), d[1].size(),
                d[2].size())</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_subview_type
<emphasis role="bold">operator()</emphasis>(Domain&lt;3&gt; const&amp; d) const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subset of the <emphasis>Tensor</emphasis>’s
                domain.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview object of *this with domain
                Domain&lt;3&gt;(d[0].size(), d[1].size(), d[2].size())
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 1&gt;::type
<emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1, whole_domain_type) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. <code>idx0 &lt;
                this-&gt;size(0) . idx1 &lt; this-&gt;size(1)</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Vector object of *this with the
                whole domain of Domain&lt;1&gt;(this-&gt;size(2)) , fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 1&gt;::const_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1, whole_domain_type) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx0 &lt; this-&gt;size(0) . idx1 &lt; this-&gt;size(1)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview const_Vector object of *this with
                the whole domain of Domain&lt;1&gt;(this-&gt;size(2)) , fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 2&gt;::type
<emphasis role="bold">operator()</emphasis>(index_type idx0, whole_domain_type, index_type idx2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx0 &lt;
                this-&gt;size(0) . idx2 &lt; this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Vector object of *this with the
                whole domain of Domain&lt;1&gt;(this-&gt;size(1)) , fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 2&gt;::const_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, whole_domain_type, index_type idx2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx0 &lt; this-&gt;size(0) . idx2 &lt; this-&gt;size(2)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview const_Vector object of *this with
                the whole domain of Domain&lt;1&gt;(this-&gt;size(1)) , fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;1, 2&gt;::type
<emphasis role="bold">operator()</emphasis>(whole_domain_type, index_type idx1, index_type idx2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx1 &lt;
                this-&gt;size(1) . idx2 &lt; this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Vector object of *this with the
                whole domain of Domain&lt;1&gt;(this-&gt;size(0)) , fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1, and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;1, 2&gt;::const_type
<emphasis role="bold">operator()</emphasis>(whole_domain_type, index_type idx1, index_type idx2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx1 &lt; this-&gt;size(1) . idx2 &lt; this-&gt;size(2)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview const_Vector object of *this with
                the whole domain of Domain&lt;1&gt;(this-&gt;size(0)) , fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1, and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 1&gt;::subset_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1, Domain&lt;1&gt; const &amp;d) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx0 &lt;
                this-&gt;size(0) . idx1 &lt; this-&gt;size(1). d is a
                subdomain of Domain&lt;1&gt;(this-&gt;size(2)) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Vector object of *this object such
                that its domain Domain&lt;1&gt;(d.size()) is the subdomain
                specified by d, has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 1&gt;::const_subset_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, index_type idx1, Domain&lt;1&gt; const &amp;d) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx0 &lt; this-&gt;size(0) . idx1 &lt; this-&gt;size(1)
                . d is a subdomain of Domain&lt;1&gt;(this-&gt;size(2))
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview object of *this such that its
                domain Domain&lt;1&gt;(d.size()) is the subdomain specified by
                d, has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 2&gt;::subset_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, Domain&lt;1&gt; const &amp;d, index_type idx2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx0 &lt;
                this-&gt;size(0) . d is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(1)) . idx2 &lt; this-&gt;size(2)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Vector object of *this such that
                its domain Domain&lt;1&gt;(d.size()) is the subdomain
                specified by d, has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;0, 2&gt;::const_subset_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, Domain&lt;1&gt; const &amp;d, index_type idx2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx0 &lt; this-&gt;size(0) . d is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(1)) . idx2 &lt; this-&gt;size(2)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview object of *this such that its
                domain Domain&lt;1&gt;(d.size()) is the subdomain specified by
                d, has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0, and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;1, 2&gt;::subset_type
<emphasis role="bold">operator()</emphasis>(Domain&lt;1&gt; const&amp; d, index_type idx1, index_type idx2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. d is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(0)) . idx1 &lt; this-&gt;size(1)
                . idx2 &lt; this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Vector object of t such that its
                domain Domain&lt;1&gt;(d.size()) is the subdomain specified by
                d, has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1, and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>value idx2.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename subvector&lt;1, 2&gt;::const_subset_type
<emphasis role="bold">operator()</emphasis>(Domain&lt;1&gt; const &amp;d, index_type idx1, index_type idx2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d is a subdomain of Domain&lt;1&gt;(this-&gt;size(0)) .
                idx1 &lt; this-&gt;size(1) . idx2 &lt; this-&gt;size(2)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview object of t such that its domain
                Domain&lt;1&gt;(d.size()) is the subdomain specified by d, has
                fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1, and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;0&gt;::type
<emphasis role="bold">operator()</emphasis>(index_type idx0, whole_domain_type, whole_domain_type) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx0 &lt;
                this-&gt;size(0) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Matrix object of *this with the
                whole domain of Domain&lt;2&gt;(this-&gt;size(1),
                this-&gt;size(2)) and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;0&gt;::const_type
<emphasis role="bold">operator()</emphasis>(index_type idx0, whole_domain_type, whole_domain_type) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx0 &lt; this-&gt;size(0) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview const_Matrix object of *this with
                the whole domain of Domain&lt;2&gt;(this-&gt;size(1),
                this-&gt;size(2)) and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;1&gt;::type
<emphasis role="bold">operator()</emphasis>(whole_domain_type, index_type idx1, whole_domain_type)
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx1 &lt;
                this-&gt;size(1) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Matrix object of *this with the
                whole domain of Domain&lt;2&gt;(this-&gt;size(0),
                this-&gt;size(2)) and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;1&gt;::const_type
<emphasis role="bold">operator()</emphasis>(whole_domain_type, index_type idx1, whole_domain_type) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx1 &lt; this-&gt;size(1) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview const_Matrix object of *this with
                the whole domain of Domain&lt;2&gt;(this-&gt;size(0),
                this-&gt;size(2)) and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;2&gt;::type
<emphasis role="bold">operator()</emphasis>(whole_domain_type, whole_domain_type, index_type idx2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx2 &lt;
                this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Matrix object of *this with the
                whole domain of Domain&lt;2&gt;(this-&gt;size(0),
                this-&gt;size(1)) and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;2&gt;::const_type
<emphasis role="bold">operator()</emphasis>(whole_domain_type, whole_domain_type, index_type idx2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx2 &lt; this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>An <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview const_Matrix object of *this with
                the whole domain of Domain&lt;2&gt;(this-&gt;size(0),
                this-&gt;size(1)) and fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;0&gt;::subset_type
<emphasis role="bold">operator</emphasis>()(index_type idx0, Domain&lt;1&gt; const &amp;d1, Domain&lt;1&gt; const &amp;d2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. idx0 &lt;
                this-&gt;size(0) . d1 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(1)) . d2 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(2)) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Matrix object of *this such that
                its domain Domain&lt;2&gt;(d1.size(), d2.size()) is the
                subdomain specified by Domain&lt;2&gt;(d1, d2) and has fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;0&gt;::const_subset_type
<emphasis role="bold">operator</emphasis>()(index_type idx0, Domain&lt;1&gt; const &amp;d1, Domain&lt;1&gt; const &amp;d2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>idx0 &lt; this-&gt;size(0) . d1 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(1)) . d2 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(2)) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview object of *this such that its
                domain Domain&lt;2&gt;(d1.size(), d2.size()) is the subdomain
                specified by Domain&lt;2&gt;(d1, d2) and has fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx0.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;1&gt;::subset_type
<emphasis role="bold">operator</emphasis>()(Domain&lt;1&gt; const &amp;d0, index_type idx1, Domain&lt;1&gt; const &amp;d2) 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. d0 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(0)) . idx1 &lt; this-&gt;size(1)
                . d2 is a subdomain of this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Matrix object of *this such that
                its domain Domain&lt;2&gt;(d0.size(), d1.size()) is the
                subdomain specified by Domain&lt;2&gt;(d0, d2) and has fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;1&gt;::const_subset_type
<emphasis role="bold">operator</emphasis>()(Domain&lt;1&gt; const &amp;d0, index_type idx1, Domain&lt;1&gt; const &amp;d2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d0 is a subdomain of Domain&lt;1&gt;(this-&gt;size(0)) .
                idx1 &lt; this-&gt;size(1) . d2 is a subdomain
                Domain&lt;2&gt;(d0.size(), d2.size()) of
                Domain&lt;1&gt;(this-&gt;size(2)) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview object of *this such that its
                domain is the subdomain specified by Domain&lt;2&gt;(d0, d2)
                and has fixed <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx1.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;2&gt;::subset_type
<emphasis role="bold">operator</emphasis>()(Domain&lt;1&gt; const&amp; d0, Domain&lt;1&gt; const&amp; d1, index_type idx2)
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. d0 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(0)) . d1 is a subdomain of
                Domain&lt;1&gt;(this-&gt;size(1)) . idx2 &lt; this-&gt;size(2)
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview Matrix object of *this such that
                its domain Domain&lt;2&gt;(d0.size(), d1.size()) is the
                subdomain specified by Domain&lt;2&gt;(d0, d1) and has fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>typename submatrix&lt;2&gt;::const_subset_type
<emphasis role="bold">operator</emphasis>()(Domain&lt;1&gt; const&amp; d0, Domain&lt;1&gt; const&amp; d1, index_type idx2) const 
  VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>d0 is a subdomain of Domain&lt;1&gt;(this-&gt;size(0)) .
                d1 is a subdomain of Domain&lt;1&gt;(this-&gt;size(1)) . idx2
                &lt; this-&gt;size(2) .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>z</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>-<inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>y</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> subview object of *this such that its
                domain Domain&lt;2&gt;(d0.size(), d1.size()) is the subdomain
                specified by Domain&lt;2&gt;(d0, d1) and has fixed
                <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>x</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> value idx2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_realview_type
<emphasis role="bold">real</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview const_Tensor object of *this with the same
                domain but accessing only the real parts of the complex values
                of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>realview_type
<emphasis role="bold">real</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. T must be a complex
                type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Tensor</emphasis> object of *this
                with the same domain but accessing only the real parts of the
                complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>const_imagview_type
<emphasis role="bold">imag</emphasis>() const VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>T must be a complex type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview const_Tensor object of *this with the same
                domain but accessing only the imaginary parts of the complex
                values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>imagview_type
<emphasis role="bold">imag</emphasis>() VSIP_THROW((std::bad_alloc));</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>*this must be a Tensor object. T must be a complex
                type.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A subview <emphasis>Tensor</emphasis> object of *this
                with the same domain but accessing only the imaginary parts of
                the complex values of the object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Throws:</term>

              <listitem>
                <para>std::bad_alloc indicating memory allocation for the
                underlying block failed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="view.tensor.accessors">
      <title>Accessors</title>

      <titleabbrev>view.tensor.accessors</titleabbrev>

      <synopsis>block_type &amp;<emphasis role="bold">block</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The tensor’s underlying block. const_Tensor::block() returns
            a block_type const&amp; while Tensor::block() returns a block_type
            &amp;.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">size</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of values in the tensor.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">size</emphasis>(dimension_type d) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>0 &lt;= d &amp;&amp; d &lt;= 2.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of values in the specified dimension of the
            tensor.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="view.tensor.convert">
      <title>Tensor type conversion</title>

      <titleabbrev>view.tensor.convert</titleabbrev>

      <orderedlist>
        <listitem>
          <para>[<emphasis>Note: </emphasis> The class ViewConversion converts
          between constant and non-constant view classes. ]</para>
        </listitem>

        <listitem>
          <para>For type View equal to Tensor or to const_Tensor,
          ViewConversion&lt;View, T, Block&gt;::const_view_type equals
          const_Tensor&lt;T, Block&gt; and ViewConversion&lt;View, T,
          Block&gt;::view_type equals Tensor&lt;T, Block&gt;.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>
</chapter>
