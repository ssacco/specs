<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="linalg" 
	 xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Linear Algebra Functions</title>

  <section>
    <title>Introduction</title>

    <para>The following functions operate on or produce matrix results. They
    are currently only defined for floating point types.</para>

    <para>In VSIPL, values in a block can be viewed as a vector
    (<function>vsip_<replaceable>d</replaceable>vview_<replaceable>p</replaceable></function>)
    or as a matrix
    (<function>vsip_<replaceable>d</replaceable>mview_<replaceable>p</replaceable></function>).
    For notational convenience, the matrix functions treat the vector view
    objects as column vectors.</para>

    <para>Matrix objects may be stored in memory in either row major or column
    major order (C order or FORTRAN order) by the application programmers
    choice of matrix view strides.</para>

    <para>Note: Many of the matrix functions that make up a family, such as
    matrix multiply, have been implemented in other libraries like BLAS as one
    function with many parameters. BLAS and other libraries historically made
    such choices due to the limitations of a seven letter (or short)
    subroutine names. Here they are handled as separately named functions.
    This eliminates some runtime checking by moving it to compile time, and
    may simplify some optimizations. (The namespace approach is also more
    closely matched to potential future object oriented bindings.) Both
    approaches have similar code development sizes. However, the separately
    named function approach reduces the size of the linked program by not
    including unnecessary functionality.</para>
  </section>

  <section>
    <title>Matrix and Vector Operations</title>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_cmherm_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Hermitian</entry>
          </row>

          <row>
            <entry><function>vsip_cvjdot_<replaceable>p</replaceable></function></entry>

            <entry>Complex Vector Conjugate Dot Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>gemp_<replaceable>p</replaceable></function></entry>

            <entry>General Matrix Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>gems_<replaceable>p</replaceable></function></entry>

            <entry>General Matrix Sum</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>skron_<replaceable>p</replaceable></function></entry>

            <entry>Kronecker Matrix Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mprod3_<replaceable>p</replaceable></function></entry>

            <entry>3 by 3 Matrix Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>p</replaceable></function></entry>

            <entry>4 by 4 Matrix Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mprod_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Product</entry>
          </row>

          <row>
            <entry><function>vsip_cmprodh_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Hermitian Product</entry>
          </row>

          <row>
            <entry><function>vsip_cmprodj_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Conjugate Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Transpose Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mvprod3_<replaceable>p</replaceable></function></entry>

            <entry>3 by 3 Matrix Vector Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mvprod4_<replaceable>p</replaceable></function></entry>

            <entry>4 by 4 Matrix Vector Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mvprod_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Vector Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>mtrans_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Transpose</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vdot_<replaceable>p</replaceable></function></entry>

            <entry>Vector Dot Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vmprod_<replaceable>p</replaceable></function></entry>

            <entry>Vector Matrix Product</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vouter_<replaceable>p</replaceable></function></entry>

            <entry>Vector Outer Product</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="cmherm">
      <title>vsip_cmherm_<replaceable>p</replaceable></title>

      <para>Complex Hermitian (conjugate transpose) of a matrix</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the N by M matrix <emphasis
            role="bold">C</emphasis>, which is the Hermitian (conjugate
            transpose) of an M by N matrix <emphasis
            role="bold">A</emphasis>.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>←</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cmherm_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *A, const vsip_cmview_<replaceable>f</replaceable> *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output N by M matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If the matrix A is square, the transpose is in place if A
            and C resolve to the same object, otherwise A and C must be
            disjoint.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>If the matrix is not square, <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>M</m:mi>

                        <m:mo>≠</m:mo>

                        <m:mi>N</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation>, the input and output matrix views must
                not overlap. If the matrix is square, <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>M</m:mi>

                        <m:mo>=</m:mo>

                        <m:mi>N</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation>, the input and output views must be
                identical views of the same block, or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mtrans_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gems_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cvjdot">
      <title>vsip_cvjdot_<replaceable>p</replaceable></title>

      <para>Compute the conjugate inner (dot) product of two complex
      vectors.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Compute the conjugate dot product</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>r</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">a</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">b</m:mi>

                        <m:mi>*</m:mi>
                      </m:msup>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>N</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msubsup>
                          <m:mi>b</m:mi>

                          <m:mi>j</m:mi>

                          <m:mi>*</m:mi>
                        </m:msubsup>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>Where "*" denotes complex conjugate.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_cscalar_f vsip_cvjdot_f(const vsip_cvview_f *a, const vsip_cvview_f *b);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>This function returns a complex scalar of the same precision
            as the input vectors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow may occur. The result of overflow is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Arguments for input must be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/cvjdot.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vdot_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dgemp">
      <title>vsip_<replaceable>d</replaceable>gemp_<replaceable>p</replaceable></title>

      <para>Calculate the general product of two matrices and
      accumulate.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the following matrix operation</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mrow>
                          <m:mi>α</m:mi>

                          <m:mo>⁢</m:mo>

                          <m:mrow>
                            <m:mi>op</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi fontweight="bold">A</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>

                        <m:mo>⁢</m:mo>

                        <m:mrow>
                          <m:mi>op</m:mi>

                          <m:mo>⁡</m:mo>

                          <m:mfenced>
                            <m:mi fontweight="bold">B</m:mi>
                          </m:mfenced>
                        </m:mrow>
                      </m:mrow>

                      <m:mo>+</m:mo>

                      <m:mrow>
                        <m:mi>β</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">C</m:mi>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">X</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is one of the following</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">X</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>*</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mi>α</m:mi>
                </m:math>
              </inlineequation> and <inlineequation>
                <m:math display="inline">
                  <m:mi>β</m:mi>
                </m:math>
              </inlineequation> are scalars, <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">A</m:mi>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">B</m:mi>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">C</m:mi>
                </m:math>
              </inlineequation> are matrices, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">A</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is an M by P matrix, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">B</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is a P by N matrix and <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">C</m:mi>
                </m:math>
              </inlineequation> is an M by N matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_MAT_NTRANS = 0, // op(A) = A
  VSIP_MAT_TRANS = 1,  // op(A) = A^T
  VSIP_MAT_HERM = 2,   // op(A) = A^H (complex only)
  VSIP_MAT_CONJ = 3    // op(X) = A^* (complex only)
} vsip_mat_op;

void vsip_gemp_f(vsip_scalar_f alpha, const vsip_mview_f *A, vsip_mat_op OpA, 
                 const vsip_mview_f *B, vsip_mat_op OpB, vsip_scalar_f beta,
                 const vsip_mview_f *C);
void vsip_cgemp_f(vsip_cscalar_f alpha, const vsip_cmview_f *A, vsip_mat_op OpA,
                  const vsip_cmview_f *B, vsip_mat_op OpB, vsip_cscalar_f beta,
                  const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>(Real/Complex) scalar.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input matrix A.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>OpA</term>

                <listitem>
                  <para>Specifies the form of op(A).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input matrix B.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>OpB</term>

                <listitem>
                  <para>Specifies the form of op(B).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>(Real/Complex) scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view, may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>

              <listitem>
                <para>OpA and OpB must be valid.</para>

                <itemizedlist>
                  <listitem>
                    <para>Real: OpA, OpB ∈ {VSIP_MAT_NTRANS,
                    VSIP_MAT_TRANS}</para>
                  </listitem>

                  <listitem>
                    <para>Complex: OpA, OpB ∈ {VSIP_MAT_NTRANS,
                    VSIP_MAT_TRANS, VSIP_MAT_HERM, VSIP_MAT_CONJ}</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodh_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodj_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod3_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dgems">
      <title>vsip_<replaceable>d</replaceable>gems_<replaceable>p</replaceable></title>

      <para>Calculate a general matrix sum.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the following matrix operation</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mrow>
                          <m:mi>α</m:mi>

                          <m:mo>⁢</m:mo>

                          <m:mrow>
                            <m:mi>op</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi fontweight="bold">A</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mrow>

                      <m:mo>+</m:mo>

                      <m:mrow>
                        <m:mi>β</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">C</m:mi>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">X</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is one of the following</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">X</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>*</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mi>α</m:mi>
                </m:math>
              </inlineequation> and <inlineequation>
                <m:math display="inline">
                  <m:mi>β</m:mi>
                </m:math>
              </inlineequation> are scalars, <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">A</m:mi>
                </m:math>
              </inlineequation> and <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">C</m:mi>
                </m:math>
              </inlineequation> are matrices, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">A</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is an M by N matrix, and <inlineequation>
                <m:math display="inline">
                  <m:mi fontweight="bold">C</m:mi>
                </m:math>
              </inlineequation> is an M by N matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_MAT_NTRANS = 0, // op(A) = A
  VSIP_MAT_TRANS = 1,  // op(A) = A^T
  VSIP_MAT_HERM = 2,   // op(A) = A^H (complex only)
  VSIP_MAT_CONJ = 3    // op(X) = A^* (complex only)
} vsip_mat_op;

void vsip_gems_<replaceable>f</replaceable>(vsip_scalar_<replaceable>f</replaceable> alpha,
                 const vsip_mview_<replaceable>f</replaceable> *A, vsip_mat_op OpA,
                 vsip_scalar_<replaceable>f</replaceable> beta, const vsip_mview_<replaceable>f</replaceable> *C);
void vsip_cgems_<replaceable>f</replaceable>(vsip_cscalar_<replaceable>f</replaceable> alpha,
                  const vsip_cmview_<replaceable>f</replaceable> *A, vsip_mat_op OpA,
                  vsip_cscalar_<replaceable>f</replaceable> beta, const vsip_cmview_<replaceable>f</replaceable> *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>(Real/Complex) scalar.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input matrix A.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>OpA</term>

                <listitem>
                  <para>Specifies the form of op(A).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>(Real/Complex) scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view C may not overlap the input matrix
            view A.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>

              <listitem>
                <para>OpA must be valid.</para>

                <itemizedlist>
                  <listitem>
                    <para>Real: OpA, OpB ∈ {VSIP_MAT_NTRANS,
                    VSIP_MAT_TRANS}</para>
                  </listitem>

                  <listitem>
                    <para>Complex: OpA, OpB ∈ {VSIP_MAT_NTRANS,
                    VSIP_MAT_TRANS, VSIP_MAT_HERM, VSIP_MAT_CONJ}</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mtrans_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>mherm_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dskron">
      <title>vsip_<replaceable>ds</replaceable>kron_<replaceable>p</replaceable></title>

      <para>Calculate the Kronecker tensor product of two vectors or
      matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>If x and y are vectors of length N and M respectively, then
            this function computes a scalar multiple of a Kronecker product of
            x and y. That is,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>α</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mrow>
                        <m:mo>(</m:mo>

                        <m:mrow>
                          <m:mi>x</m:mi>

                          <m:mo>⊗</m:mo>

                          <m:mi>y</m:mi>
                        </m:mrow>

                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>x</m:mi>

                      <m:mo>⊗</m:mo>

                      <m:mi>y</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mrow>
                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mn>0</m:mn>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:mi>y</m:mi>
                      </m:mrow>

                      <m:mrow>
                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mn>1</m:mn>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:mi>y</m:mi>
                      </m:mrow>

                      <m:mo>⋯</m:mo>

                      <m:mrow>
                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mn>N-1</m:mn>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:mi>y</m:mi>
                      </m:mrow>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">X</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">X</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">X</m:mi>

                      <m:mi>*</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>and <inlineequation>
                <m:math display="inline">
                  <m:mi>α</m:mi>
                </m:math>
              </inlineequation> is a scalar. The resulting matrix, C, is an M
            by N matrix.</para>

            <para>If A is an M by N matrix and B is an K by L matrix , then
            this function computes a scalar multiple of a Kronecker product of
            A and B. That is,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>α</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mrow>
                        <m:mo>(</m:mo>

                        <m:mrow>
                          <m:mi>A</m:mi>

                          <m:mo>⊗</m:mo>

                          <m:mi>B</m:mi>
                        </m:mrow>

                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⊗</m:mo>

                      <m:mi>B</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>0,0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>0,1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>0,N-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>1,0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>1,1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>1,N-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>M-1,0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>M-1,1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:mo>⋯</m:mo>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mn>M-1,N-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mi>B</m:mi>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>and α is a scalar. The resulting matrix, C, is an
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>⁢</m:mo>

                    <m:mi>K</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> by <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>N</m:mi>

                    <m:mo>⁢</m:mo>

                    <m:mi>L</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vkron_f(vsip_scalar_f alpha, const vsip_vview_f *x,
                  const vsip_vview_f *y, const vsip_mview_f *C);
void vsip_cvkron_f(vsip_cscalar_f alpha, const vsip_cvview_f *x,
                   const vsip_cvview_f *y, const vsip_cmview_f *C);
void vsip_mkron_f(vsip_scalar_f alpha, const vsip_mview_f *A,
                  const vsip_mview_f *B, const vsip_mview_f *C);
void vsip_cmkron_f(vsip_cscalar_f alpha, const vsip_cmview_f *A,
                   const vsip_cmview_f *B, const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>(Real/Complex) scalar.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of input vector.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The vectors and matrix x, y, and C or the matrices A, B,
                and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The output matrix view and the input vector/matrix views
                must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vouter_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmprod3">
      <title>vsip_<replaceable>d</replaceable>mprod3_<replaceable>p</replaceable></title>

      <para>Calculate the product of a 3 by 3 matrix and a 3 by N
      matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the product of a 3 by 3 matrix A and a 3 by N
            matrix, B. The result of this operation, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi>B</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>, is a 3 by N matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>k</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mi>2</m:mi>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,k</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>b</m:mi>

                          <m:mi>k,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, 2; for j = 0, 1, …, N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mprod3_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *A, const vsip_mview_<replaceable>f</replaceable> *B,
                   const vsip_mview_<replaceable>f</replaceable> *C);
void vsip_cmprod3_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *A, const vsip_cmview_<replaceable>f</replaceable> *B,
                    const vsip_cmview_<replaceable>f</replaceable> *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input 3 by 3 matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input 3 by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output 3 by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodh_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodj_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gemp_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmprod4">
      <title>vsip_<replaceable>d</replaceable>mprod4_<replaceable>p</replaceable></title>

      <para>Calculate the product of a 4 by 4 matrix and a 4 by N
      matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the product of a 4 by 4 matrix A and a 4 by N
            matrix, B. The result of this operation, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi>B</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>, is a 4 by N matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>k</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mi>3</m:mi>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,k</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>b</m:mi>

                          <m:mi>k,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, 2, 3; for j = 0, 1, …,
                  N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mprod4_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *A, const vsip_mview_<replaceable>f</replaceable> *B,
                   const vsip_mview_<replaceable>f</replaceable> *C);
void vsip_cmprod4_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *A, const vsip_cmview_<replaceable>f</replaceable> *B,
                    const vsip_cmview_<replaceable>f</replaceable> *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input 4 by 4 matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input 4 by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output 4 by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodh_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodj_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod3_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gemp_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmprod">
      <title>vsip_<replaceable>d</replaceable>mprod_<replaceable>p</replaceable></title>

      <para>Calculate the product of two matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the product of an M by P matrix A and a P by N
            matrix, B. The result of this operation, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi>B</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>, is a M by N matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>k</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>P</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,k</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>b</m:mi>

                          <m:mi>k,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, ..., M-1; for j = 0, 1, …,
                  N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mprod_f(const vsip_mview_f *A, const vsip_mview_f *B,
                  const vsip_mview_f *C);
void vsip_cmprod_f(const vsip_cmview_f *A, const vsip_cmview_f *B,
                   const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input P by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodh_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprodj_<replaceable>f</replaceable></function>,
            <function>vsip_cmprod3_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gemp_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmprodh">
      <title>vsip_<replaceable>d</replaceable>mprodh_<replaceable>p</replaceable></title>

      <para>Calculate the product a complex matrix and the Hermitian of a
      complex matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the product of an M by P complex matrix A and the
            Hermitian of an N by P complex matrix, B. The result of this
            operation, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi>B</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>, is an M by N complex matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>k</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>P</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,k</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msubsup>
                          <m:mi>b</m:mi>

                          <m:mi>j,k</m:mi>

                          <m:mi>*</m:mi>
                        </m:msubsup>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, ..., M-1; for j = 0, 1, …,
                  N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cmprodh_f(const vsip_cmview_f *A, const vsip_cmview_f *B,
                    const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input N by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>f</replaceable></function>,
            <function>vsip_cmprod_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprodj_<replaceable>f</replaceable></function>,
            <function>vsip_cmprod3_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gemp_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmprodj">
      <title>vsip_<replaceable>d</replaceable>mprodj_<replaceable>p</replaceable></title>

      <para>Calculate the product a matrix and the conjugate of a
      matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the product of an M by P matrix A and the conjugate
            of a P by N matrix, B. The result of this operation,
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi>B</m:mi>

                        <m:mi>*</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>, is an M by N complex matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>k</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>P</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,k</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msubsup>
                          <m:mi>b</m:mi>

                          <m:mi>k,j</m:mi>

                          <m:mi>*</m:mi>
                        </m:msubsup>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, ..., M-1; for j = 0, 1, …,
                  N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cmprodj_f(const vsip_cmview_f *A, const vsip_cmview_f *B,
                    const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input N by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodt_<replaceable>f</replaceable></function>,
            <function>vsip_cmprodh_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod_<replaceable>f</replaceable></function>,
            <function>vsip_cmprod3_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gemp_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmprodt">
      <title>vsip_<replaceable>d</replaceable>mprodt_<replaceable>p</replaceable></title>

      <para>Calculate the product of a matrix and the transpose of a
      matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the product of an M by P matrix A times the
            transpose of an N by P matrix, B. The result of this operation,
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi>B</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>, is an M by N matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>c</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>k</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>P</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,k</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>b</m:mi>

                          <m:mi>j,k</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, ..., M-1; for j = 0, 1, …,
                  N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mprodt_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *A, const vsip_mview_<replaceable>f</replaceable> *B,
                   const vsip_mview_<replaceable>f</replaceable> *C);
void vsip_cmprodt_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *A, const vsip_cmview_<replaceable>f</replaceable> *B,
                    const vsip_cmview_<replaceable>f</replaceable> *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>B</term>

                <listitem>
                  <para>View of input N by P matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A, B, and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mprodh_<replaceable>f</replaceable></function>,
            <function>vsip_cmprod_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprodj_<replaceable>f</replaceable></function>,
            <function>vsip_cmprod3_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gemp_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmvprod3">
      <title>vsip_<replaceable>d</replaceable>mvprod3_<replaceable>p</replaceable></title>

      <para>Calculate the product of an 3 by 3 matrix and a vector.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes product of an 3 by 3 matrix and a vector.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">y</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">x</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mn>2</m:mn>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,j</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, 2</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mvprod3_f(const vsip_mview_f *A, const vsip_vview_f *x,
                    const vsip_vview_f *y);
void vsip_cmvprod3_f(const vsip_cmview_f *A, const vsip_cvview_f *x,
                     const vsip_cvview_f *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input 3 by 3 matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector of length 3.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output vector of length 3.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result vector view may not overlap either input
            matrix/vector view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix and vectors A, x, and y must be
                conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix/vector views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>These functions may be implemented as macros.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mvprod_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mvprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vmprod_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmvprod4">
      <title>vsip_<replaceable>d</replaceable>mvprod4_<replaceable>p</replaceable></title>

      <para>Calculate the product of an 4 by 4 matrix and a vector.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes product of an 4 by 4 matrix and a vector.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">y</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">x</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mn>3</m:mn>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,j</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, 2, 3</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mvprod4_f(const vsip_mview_f *A, const vsip_vview_f *x,
                    const vsip_vview_f *y);
void vsip_cmvprod4_f(const vsip_cmview_f *A, const vsip_cvview_f *x,
                     const vsip_cvview_f *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input 4 by 4 matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector of length 4.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output vector of length 4.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result vector view may not overlap either input
            matrix/vector view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix and vectors A, x, and y must be
                conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix/vector views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>These functions may be implemented as macros.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mvprod_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mvprod3_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vmprod_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmvprod">
      <title>vsip_<replaceable>d</replaceable>mvprod_<replaceable>p</replaceable></title>

      <para>Calculate a matrix - vector product.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes product of an M by N matrix and a vector.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">y</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">x</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>N</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>i,j</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, ..., M-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mvprod_f(const vsip_mview_f *A, const vsip_vview_f *x,
                   const vsip_vview_f *y);
void vsip_cmvprod_f(const vsip_cmview_f *A, const vsip_cvview_f *x,
                    const vsip_cvview_f *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector of length N.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output vector of length M.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result vector view may not overlap either input
            matrix/vector view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix and vectors A, x, and y must be
                conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix/vector views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>These functions may be implemented as macros.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mvprod3_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mvprod4_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vmprod_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmtrans">
      <title>vsip_<replaceable>d</replaceable>mtrans_<replaceable>p</replaceable></title>

      <para>Transpose a matrix</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the N by M matrix C, which is the transpose of an M
            by N matrix A.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mtrans_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *A, const vsip_mview_<replaceable>f</replaceable> *C);
void vsip_cmtrans_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *A, const vsip_cmview_<replaceable>f</replaceable> *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If the matrix A is square, the transpose is in place if A
            and C resolve to the same object, otherwise A and C must not
            overlap.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices A and C must be conformant.</para>
              </listitem>

              <listitem>
                <para>If the matrix is not square, <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>M</m:mi>

                        <m:mo>≠</m:mo>

                        <m:mi>N</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation>, the input and output matrix views must
                not overlap.</para>
              </listitem>

              <listitem>
                <para>If the matrix is square, <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>M</m:mi>

                        <m:mo>=</m:mo>

                        <m:mi>N</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation>, the input and output views must be
                identical views of the same block, or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_cmherm_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>gems_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvdot">
      <title>vsip_<replaceable>d</replaceable>vdot_<replaceable>p</replaceable></title>

      <para>Compute the inner (dot) product of two vectors.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Compute the dot product</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>r</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">a</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">b</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>N</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>b</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_<replaceable>f</replaceable> vsip_vdot_<replaceable>f</replaceable>(const vsip_vview_<replaceable>f</replaceable> *a, const vsip_vview_<replaceable>f</replaceable> *b);
vsip_cscalar_<replaceable>f</replaceable> vsip_cvdot_<replaceable>f</replaceable>(const vsip_cvview_<replaceable>f</replaceable> *a, const vsip_cvview_<replaceable>f</replaceable> *b);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>For real input vectors this function returns a real scalar
            of the same precision as the input vectors.</para>

            <para>For complex input vectors, this function returns a complex
            scalar of the same precision as the input vectors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow may occur. The result of overflow is implementation
            specific.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>Arguments for input must be the same size.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/dot.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_cvjdot</function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvmprod">
      <title>vsip_<replaceable>d</replaceable>vmprod_<replaceable>p</replaceable></title>

      <para>Calculate a vector - matrix product.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes product of a vector and an M by N matrix.</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">y</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">x</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">A</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mn>0</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>M</m:mi>

                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:munderover>

                      <m:mrow>
                        <m:msub>
                          <m:mi>a</m:mi>

                          <m:mi>j,i</m:mi>
                        </m:msub>

                        <m:mo>⁢</m:mo>

                        <m:msub>
                          <m:mi>x</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>

                  <m:mtext>, for i = 0, 1, ..., N-1</m:mtext>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmprod_f(const vsip_vview_f *x, const vsip_mview_f *A,
                   const vsip_vview_f *y);
void vsip_cvmprod_f(const vsip_cvview_f *x, const vsip_cmview_f *A,
                    const vsip_cvview_f *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector of length M.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>View of input M by N matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output vector of length N.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result vector view may not overlap either input
            matrix/vector view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix and vectors A, x, and y must be
                conformant.</para>
              </listitem>

              <listitem>
                <para>The input and output matrix/vector views must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>mvprod_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>mvprod3_<replaceable>f</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>mvprod4_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvouter">
      <title>vsip_<replaceable>d</replaceable>vouter_<replaceable>p</replaceable></title>

      <para>Calculate the outer product of two vectors.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>If <emphasis role="bold">x</emphasis> and <emphasis
            role="bold">y</emphasis> are vectors of length M and N
            respectively, then this function computes the scalar multiple of
            an outer product of <emphasis role="bold">x</emphasis> and
            <emphasis role="bold">y</emphasis>. That is,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi>α</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">x</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">y</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>α</m:mi>

                    <m:mo>*</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>N-1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>N-1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>M-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>M-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>M-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mn>N-1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>If x and y are complex vectors, then this function
            computes</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>←</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi>α</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">x</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">y</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>α</m:mi>

                    <m:mo>*</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>0</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>1</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>0</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>N-1</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>0</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>1</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>N-1</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>M-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>0</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>M-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>1</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mrow>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mn>M-1</m:mn>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msubsup>
                                <m:mi>y</m:mi>

                                <m:mn>N-1</m:mn>

                                <m:mn>*</m:mn>
                              </m:msubsup>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vouter_f(vsip_scalar_f alpha, const vsip_vview_f *x, 
                   const vsip_vview_f *y, const vsip_mview_f *C);
void vsip_cvouter_f(vsip_cscalar_f alpha, const vsip_cvview_f *x,
                    const vsip_cvview_f *y, const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>(Real/Complex) scalar.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector of length M.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of input vector of length N.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>View of output M by N matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result matrix view may not overlap either input vector
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The vectors and matrix <emphasis
                role="bold">x</emphasis>, <emphasis role="bold">y</emphasis>,
                and <emphasis role="bold">C</emphasis> must be
                conformant</para>
              </listitem>

              <listitem>
                <para>The output matrix view and the input vector views must
                not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>kron_<replaceable>f</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Special Linear System Solvers</title>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>d</replaceable>covsol_<replaceable>p</replaceable></function></entry>

            <entry>Solve Covariance System</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>llsqsol_<replaceable>p</replaceable></function></entry>

            <entry>Solve Linear Least Squares Problem</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>toepsol_<replaceable>p</replaceable></function></entry>

            <entry>Solve Toeplitz System</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dcovsol">
      <title>vsip_<replaceable>d</replaceable>covsol_<replaceable>p</replaceable></title>

      <para>Solve a covariance linear system problem.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Solves a covariance linear system problem,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:msup>
                          <m:mi fontweight="bold">A</m:mi>

                          <m:mi>T</m:mi>
                        </m:msup>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">A</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">B</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:msup>
                          <m:mi fontweight="bold">A</m:mi>

                          <m:mi>H</m:mi>
                        </m:msup>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">A</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">B</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">A</emphasis> is a matrix of
            order M by N with rank N, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>≥</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, and <emphasis role="bold">B</emphasis> is a
            matrix of order N by K.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_covsol_f(const vsip_mview_f *A, const vsip_mview_f *XB);
int vsip_ccovsol_f(const vsip_cmview_f *A, const vsip_cmview_f *XB);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">A</emphasis>, of size M by N, <inlineequation>
                      <m:math display="inline">
                        <m:mrow>
                          <m:mi>M</m:mi>

                          <m:mo>≥</m:mo>

                          <m:mi>N</m:mi>
                        </m:mrow>
                      </m:math>
                    </inlineequation>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>XB</term>

                <listitem>
                  <para>View of output <emphasis
                  role="bold">X</emphasis>/input matrix <emphasis
                  role="bold">B</emphasis>, of size N by K.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <itemizedlist>
              <listitem>
                <para>0 if successful</para>
              </listitem>

              <listitem>
                <para>-1 if memory allocation failure</para>
              </listitem>

              <listitem>
                <para>Positive if <emphasis role="bold">A</emphasis> does not
                have full column rank, rank(<emphasis
                role="bold">A</emphasis>) = N</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> may be
            overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and output/input objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices <emphasis role="bold">A</emphasis> and
                <emphasis role="bold">XB</emphasis> must be conformant and
                must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>This function may allocate and free temporary workspace,
            which may result in nondeterministic execution time. The more
            general QR routines may be used to solve a covariance problem and
            they support explicit creation and destruction.</para>

            <para>The matrix <emphasis role="bold">A</emphasis> is assumed to
            be of full rank. This property is not checked. A positive return
            value indicates that an error occurred and a zero pivot element
            was encountered.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>Section – Overdetermined Linear System</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dllsqsol">
      <title>vsip_<replaceable>d</replaceable>llsqsol_<replaceable>p</replaceable></title>

      <para>Solve a linear least squares problem.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Solves the linear least squares problem,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:munder>
                      <m:mo>min</m:mo>

                      <m:mi>x</m:mi>
                    </m:munder>

                    <m:msub>
                      <m:mrow>
                        <m:mo>||</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mi fontweight="bold">A</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:mi fontweight="bold">X</m:mi>
                          </m:mrow>

                          <m:mo>-</m:mo>

                          <m:mi fontweight="bold">B</m:mi>
                        </m:mrow>

                        <m:mo>||</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">A</emphasis> is a matrix of
            order M by N with rank N, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>≥</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, and <emphasis role="bold">B</emphasis> is a
            matrix of order M by K.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_llsqsol_f(const vsip_mview_f *A, const vsip_mview_f *XB);
int vsip_cllsqsol_f(const vsip_cmview_f *A, const vsip_cmview_f *XB);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">A</emphasis>, of size M by N, <inlineequation>
                      <m:math display="inline">
                        <m:mrow>
                          <m:mi>M</m:mi>

                          <m:mo>≥</m:mo>

                          <m:mi>N</m:mi>
                        </m:mrow>
                      </m:math>
                    </inlineequation>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>XB</term>

                <listitem>
                  <para>On entry view of input matrix <emphasis
                  role="bold">B</emphasis>, of size M by K. The view is const;
                  however on exit the first N rows starting at index zero are
                  the output data. Contents of the view starting at index N
                  are implementation dependent.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <itemizedlist>
              <listitem>
                <para>0 if successful</para>
              </listitem>

              <listitem>
                <para>-1 if memory allocation failure</para>
              </listitem>

              <listitem>
                <para>Positive if <emphasis role="bold">A</emphasis> does not
                have full column rank, rank(<emphasis
                role="bold">A</emphasis>) = N</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> may be
            overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and output/input objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrices <emphasis role="bold">A</emphasis> and
                <emphasis role="bold">XB</emphasis> must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>This function may allocate and free temporary workspace,
            which may result in nondeterministic execution time. The more
            general QR routines may be used to solve a linear least squares
            problem and they support explicit creation and destruction.</para>

            <para>The matrix <emphasis role="bold">A</emphasis> is assumed to
            be of full rank. This property is not checked. A positive return
            value indicates the matrix did not have full column rank and the
            algorithm failed to be completed.</para>

            <para>Since the output data length may be smaller than the input
            data length it is recommended that a subview of the input vector
            be created which defines a vector view of the output data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>Section – Overdetermined Linear System</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtoepsol">
      <title>vsip_<replaceable>d</replaceable>toepsol_<replaceable>p</replaceable></title>

      <para>Solve a real symmetric or complex Hermitian positive definite
      Toeplitz linear system.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Solve a real symmetric positive definite N by N Toeplitz
            linear system, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi fontweight="bold">T</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">x</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>T</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>0</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>0</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mi/>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mi/>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>0</m:mn>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>Solve a complex Hermitian positive definite N by N Toeplitz
            linear system, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi fontweight="bold">T</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">x</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>T</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>0</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msubsup>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>

                              <m:mi>*</m:mi>
                            </m:msubsup>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>0</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mi/>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msubsup>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>

                              <m:mi>*</m:mi>
                            </m:msubsup>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋮</m:mo>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msubsup>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>

                              <m:mi>*</m:mi>
                            </m:msubsup>
                          </m:mtd>

                          <m:mtd>
                            <m:mi/>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋱</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msubsup>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>

                              <m:mi>*</m:mi>
                            </m:msubsup>
                          </m:mtd>

                          <m:mtd>
                            <m:msubsup>
                              <m:mi>t</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>

                              <m:mi>*</m:mi>
                            </m:msubsup>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msubsup>
                              <m:mi>t</m:mi>

                              <m:mn>1</m:mn>

                              <m:mi>*</m:mi>
                            </m:msubsup>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>t</m:mi>

                              <m:mn>0</m:mn>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>We only need a vector t, the first row of T to specify the
            system.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_toepsol_f(const vsip_vview_f *t, const vsip_vview_f *b,
                   const vsip_vview_f *w, const vsip_vview_f *x);
int vsip_ctoepsol_f(const vsip_cvview_f *t, const vsip_cvview_f *b,
                    const vsip_cvview_f *w, const vsip_cvview_f *x);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>t</term>

                <listitem>
                  <para>View of input vector, t, of length N, the first row of
                  the Toeplitz matrix <emphasis
                  role="bold">T</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector, b, of length N.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>w</term>

                <listitem>
                  <para>View of vector, w, of length N used for temporary
                  workspace.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of output vector, x, of length N.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <itemizedlist>
              <listitem>
                <para>0 if successful</para>
              </listitem>

              <listitem>
                <para>-1 if memory allocation failure</para>
              </listitem>

              <listitem>
                <para>Positive if <emphasis role="bold">T</emphasis> is not
                positive definite</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result vector view may not overlap either input vector
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The vectors t, x, w, and b must be conformant.</para>
              </listitem>

              <listitem>
                <para>The input vector views and output vector view must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The matrix T is assumed to be of full rank and positive
            definite. This property is not checked. A positive return value
            indicates that an error occurred and the algorithm failed to be
            completed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>General Square Linear System Solver</title>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>d</replaceable>lud_<replaceable>p</replaceable></function></entry>

            <entry>Matrix LU Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>p</replaceable></function></entry>

            <entry>Create LU Decomposition Object</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>lud_destroy_<replaceable>p</replaceable></function></entry>

            <entry>Destroy LUD Object</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>lud_getattr_<replaceable>p</replaceable></function></entry>

            <entry>LUD Get Attributes</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>lusol_<replaceable>p</replaceable></function></entry>

            <entry>Solve General Linear System</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dlud">
      <title>vsip_<replaceable>d</replaceable>lud_<replaceable>p</replaceable></title>

      <para>Compute an LU decomposition of a square matrix <emphasis
      role="bold">A</emphasis> using partial pivoting.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the LU decomposition of a general N by N matrix
            <emphasis role="bold">A</emphasis> using partial pivoting, with
            either row interchanges or column interchanges. An example of an
            LU decomposition is a factorization using row interchanges that
            has the form,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">P</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">L</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">U</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or using column interchanges has the form,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">L</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">U</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">P</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">P</emphasis> is a permutation
            matrix, <emphasis role="bold">L</emphasis> is lower triangular,
            and <emphasis role="bold">U</emphasis> is upper triangular. The
            choice of the particular factorization and row or column
            interchanges is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_lud_<replaceable>f</replaceable>(vsip_lu_f *lud, const vsip_mview_f *A);
int vsip_clud_<replaceable>f</replaceable>(vsip_clu_f *lud, const vsip_cmview_f *A);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>lud</term>

                <listitem>
                  <para>Pointer to an LU decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">A</emphasis>, N by N.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful. This routine will fail and
            return non-zero if <emphasis role="bold">A</emphasis> does not
            have full rank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> may be
            overwritten by the decomposition, and the matrix <emphasis
            role="bold">A</emphasis> must not be modified as long as the
            factorization is required.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">A</emphasis> and the LU
                decomposition object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> is assumed to
            be of full rank. This property is not checked. A positive return
            value indicates that an error occurred and a zero pivot element
            was encountered.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lusol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lud_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>lud_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dlud_create">
      <title>vsip_<replaceable>d</replaceable>lud_create_<replaceable>p</replaceable></title>

      <para>Create an LU decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates an LU decomposition object. The LU decomposition
            object encapsulates the information concerning the properties of
            the decomposition and required workspace. The LU decomposition
            object is used to compute the LU decomposition of a general N by N
            matrix <emphasis role="bold">A</emphasis> using partial pivoting
            with either row interchanges or column interchanges. As an example
            an LU decomposition, using row interchanges has the form,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">P</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">L</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">U</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or using column interchanges has the form,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">L</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">U</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">P</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">P</emphasis> is a permutation
            matrix, <emphasis role="bold">L</emphasis> is lower triangular,
            and <emphasis role="bold">U</emphasis> is upper triangular. The
            choice of the particular factorization and row or column
            interchanges is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_lu_<replaceable>f</replaceable> *vsip_lud_create_<replaceable>f</replaceable>(vsip_length N);
vsip_clu_<replaceable>f</replaceable> *vsip_clud_create_<replaceable>f</replaceable>(vsip_length N);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>The number of rows in the matrix <emphasis
                  role="bold">A</emphasis>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>The return value is a pointer to an LU decomposition object,
            or null if it fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>N is greater than zero</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>lud_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lusol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lud_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>lud_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dlud_destroy">
      <title>vsip_<replaceable>d</replaceable>lud_destroy_<replaceable>p</replaceable></title>

      <para>Destroy an LU decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroys (frees memory) an LU decomposition object returning
            zero on success, and non-zero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_lud_destroy_f(vsip_lu_f *lud);
int vsip_clud_destroy_f(vsip_clu_f *lud);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>lud</term>

                <listitem>
                  <para>Pointer to an LU decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The LU decomposition object must be valid. An argument
                of null is not an error.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lud_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>ludsol_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>lud_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dlud_getattr">
      <title>vsip_<replaceable>d</replaceable>lud_getattr_<replaceable>p</replaceable></title>

      <para>Returns the attributes of an LU decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the attributes of an LU decomposition object in an
            LU attribute structure passed by reference.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef struct 
{
  vsip_length n; // number of rows and columns in the matrix
} vsip_dlu_attr_<replaceable>f</replaceable>;

void vsip_lud_getattr_<replaceable>f</replaceable>(const vsip_lu_<replaceable>f</replaceable> *lud, vsip_lu_attr_<replaceable>f</replaceable> *attr);
void vsip_clud_getattr_<replaceable>f</replaceable>(const vsip_clu_<replaceable>f</replaceable> *lud, vsip_clu_attr_<replaceable>f</replaceable> *attr);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>lud</term>

                <listitem>
                  <para>Pointer to an LU decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attr</term>

                <listitem>
                  <para>Pointer to output attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The LU decomposition object must be valid.</para>
              </listitem>

              <listitem>
                <para>The attribute pointer must be valid – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lud_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>ludsol_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>lud_destroy_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dludsol">
      <title>vsip_<replaceable>d</replaceable>ludsol_<replaceable>p</replaceable></title>

      <para>Solve a square linear system.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Solve the following linear system</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:mi>op</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi fontweight="bold">A</m:mi>
                        </m:mfenced>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">B</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">A</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is one of the following</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">A</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">A</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">A</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, or <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">A</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>for a general matrix <emphasis role="bold">A</emphasis>
            using the decomposition computed by the routine
            <function>vsip_dlud_<replaceable>f</replaceable></function>.
            <emphasis role="bold">A</emphasis> is a matrix of order N by N
            with rank N, and <emphasis role="bold">B</emphasis> is a matrix of
            order N by K.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_lusol_f(const vsip_lu_f *lud, vsip_mat_op OpA, const vsip_mview_f *XB);
int vsip_clusol_f(const vsip_clu_f *lud, vsip_mat_op OpA, const vsip_cmview_f *XB);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>lud</term>

                <listitem>
                  <para>Pointer to an LU decomposition object for the N by N
                  matrix, <emphasis role="bold">A</emphasis>, computed by the
                  routine
                  <function>vsip_<replaceable>d</replaceable>lud_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>OpA</term>

                <listitem>
                  <para>Specifies the form of op(A).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>XB</term>

                <listitem>
                  <para>View of output <emphasis
                  role="bold">X</emphasis>/input <emphasis
                  role="bold">B</emphasis>, matrix of size N by K.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and input/output objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">XB</emphasis>
                (<emphasis role="bold">X</emphasis> and <emphasis
                role="bold">B</emphasis>) and the LU decomposition object must
                be conformant.</para>
              </listitem>

              <listitem>
                <para>OpA must be valid.</para>

                <itemizedlist>
                  <listitem>
                    <para>Real: OpA ∈ {VSIP_MAT_NTRANS, VSIP_MAT_TRANS}</para>
                  </listitem>

                  <listitem>
                    <para>Complex: OpA ∈ {VSIP_MAT_NTRANS, VSIP_MAT_HERM
                    }</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>lusol_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>lud_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero unsuccessful return
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>lud_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lud_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>lud_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>lud_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Symmetric Positive Definite Linear System Solver</title>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>vsip_dchold_p</entry>

            <entry>Matrix Cholesky Decomposition</entry>
          </row>

          <row>
            <entry>vsip_dchold_create_p</entry>

            <entry>Create Cholesky Decomposition Object</entry>
          </row>

          <row>
            <entry>vsip_dchold_destroy_p</entry>

            <entry>Destroy CHOLD Object</entry>
          </row>

          <row>
            <entry>vsip_dchold_getattr_p</entry>

            <entry>CHOLD Get Attributes</entry>
          </row>

          <row>
            <entry>vsip_dcholsol_p</entry>

            <entry>Solve SPD Linear System</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dchold">
      <title>vsip_<replaceable>d</replaceable>chold_<replaceable>p</replaceable></title>

      <para>Compute a Cholesky decomposition of a symmetric (Hermitian)
      positive definite matrix <emphasis role="bold">A</emphasis>.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>The Cholesky decomposition of a symmetric (Hermitian)
            positive definite N by N matrix <emphasis role="bold">A</emphasis>
            is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">L</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">L</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation> (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">L</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">L</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>), where <emphasis role="bold">L</emphasis> is
            a lower triangular matrix,</para>

            <para>or</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">R</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">R</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation> (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">R</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">R</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>), where <emphasis role="bold">R</emphasis> is
            an upper triangular matrix.</para>

            <para>The particular type of factorization is an implementation
            dependent feature. There is not a utility function for accessing
            the factors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_chold_<replaceable>f</replaceable>(vsip_chol_<replaceable>f</replaceable> *chold, const vsip_mview_<replaceable>f</replaceable> *A);
int vsip_cchold_<replaceable>f</replaceable>(vsip_cchol_<replaceable>f</replaceable> *chold, const vsip_cmview_<replaceable>f</replaceable> *A);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>chold</term>

                <listitem>
                  <para>Pointer to a Cholesky decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">A</emphasis>, N by N.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful. This routine will fail if a
            leading minor of <emphasis role="bold">A</emphasis> is not
            symmetric (Hermitian) positive definite and the algorithm could
            not be completed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> may be
            overwritten by the decomposition, and the matrix <emphasis
            role="bold">A</emphasis> must not be modified as long as the
            decomposition is required.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and input/output objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">A</emphasis> and the
                Cholesky decomposition object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The matrix, <emphasis role="bold">A</emphasis>, is assumed
            to be symmetric (Hermitian). This property is not checked. Since
            VSIPL does not have a symmetric (Hermitian) object type storage
            for the full matrix must be specified. Only half of the matrix is
            referenced and modified; the other half is not modified.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>cholsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>chold_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>chold_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dchold_create">
      <title>vsip_<replaceable>d</replaceable>chold_create_<replaceable>p</replaceable></title>

      <para>Create a Cholesky decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Create a Cholesky decomposition (CHOLD) object. The Cholesky
            decomposition object encapsulates the information concerning the
            properties of the decomposition and required workspace.</para>

            <para>The Cholesky decomposition object is used to compute the
            Cholesky decomposition of a symmetric positive definite N by N
            matrix <emphasis role="bold">A</emphasis>.</para>

            <para>The Cholesky decomposition of a symmetric (Hermitian)
            positive definite N by N matrix <emphasis role="bold">A</emphasis>
            is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">L</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">L</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation> (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">L</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">L</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>), where <emphasis role="bold">L</emphasis> is
            a lower triangular matrix,</para>

            <para>or</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">R</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">R</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation> (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">R</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">R</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>), where <emphasis role="bold">R</emphasis> is
            an upper triangular matrix.</para>

            <para>The particular type of factorization is an implementation
            dependent feature. There is not a utility function for accessing
            the factors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum { VSIP_TR_LOW = 0, VSIP_TR_UPP = 1} vsip_mat_uplo;

vsip_chol_f *vsip_chold_create_f(vsip_mat_uplo uplo, vsip_length N);
vsip_cchol_f *vsip_cchold_create_f(vsip_mat_uplo uplo, vsip_length N);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>The number of row or columns in the input
                  matrix.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>uplo</term>

                <listitem>
                  <para>Specifies if the upper or lower triangular half of the
                  matrix is stored.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>The return value is a pointer to a Cholesky decomposition
            object, or null if it fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input parameters must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>N is greater than zero.</para>
              </listitem>

              <listitem>
                <para>uplo is valid: uplo ∈ {VSIP_TR_LOW, VSIP_TR_UPP}</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>chold_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>cholsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>chold_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>chold_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dchold_destroy">
      <title>vsip_<replaceable>d</replaceable>chold_destroy_<replaceable>p</replaceable></title>

      <para>Destroy a Cholesky decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroy (free memory) a Cholesky decomposition object
            returning zero on success, and nonzero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_chold_destroy_f(vsip_chol_f *chold);
int vsip_cchold_destroy_f(vsip_cchol_f *chold);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>chold</term>

                <listitem>
                  <para>Pointer to a Cholesky decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero on success, and non-zero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input object must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The Cholesky decomposition object must be valid. An
                argument of null is not an error.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>chold_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>cholsol_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>chold_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dchold_getattr">
      <title>vsip_<replaceable>d</replaceable>chold_getattr_<replaceable>p</replaceable></title>

      <para>Returns the attributes of a Cholesky decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the attributes of a Cholesky decomposition object in
            structure passed by reference.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef struct 
{
  vsip_mat_uplo uplo; // Upper or lower triangular matrix
  vsip_length n;      // Number of rows and columns in the matrix
} vsip_dchol_attr_f;

void vsip_chold_getattr_f(const vsip_chol_f *chold, vsip_chol_attr_f *attr);
void vsip_cchold_getattr_f(const vsip_cchol_f *chold, vsip_cchol_attr_f *attr);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>chold</term>

                <listitem>
                  <para>Pointer to a Cholesky decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attr</term>

                <listitem>
                  <para>Pointer to output attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and output arguments must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>The Cholesky decomposition object must be valid.</para>
              </listitem>

              <listitem>
                <para>The attribute pointer must be valid – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>chold_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>cholsol_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>chold_destroy_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dcholsol">
      <title>vsip_<replaceable>d</replaceable>cholsol_<replaceable>p</replaceable></title>

      <para>Solve a symmetric (Hermitian) positive definite linear
      system.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Solve the following linear system</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi fontweight="bold">A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">B</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>for a symmetric (Hermitian) positive definite matrix
            <emphasis role="bold">A</emphasis> using the decomposition
            computed by the routine
            <function>vsip_<replaceable>d</replaceable>chold_</function><replaceable>f</replaceable>.
            <emphasis role="bold">A</emphasis> is a matrix of order N by N,
            and <emphasis role="bold">B</emphasis> is a matrix of order N by
            K.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_cholsol_f(const vsip_chol_f *chold, const vsip_mview_f *XB);
int vsip_ccholsol_f(const vsip_cchol_f *chold, const vsip_cmview_f *XB);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>chold</term>

                <listitem>
                  <para>Pointer to a Cholesky decomposition object for the N
                  by N matrix, <emphasis role="bold">A</emphasis>, computed by
                  the routine
                  <function>vsip_<replaceable>d</replaceable>chold_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>XB</term>

                <listitem>
                  <para>View of input <emphasis
                  role="bold">B</emphasis>/output <emphasis
                  role="bold">X</emphasis>, matrix of size N by K.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and input/output objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">XB</emphasis>
                (<emphasis role="bold">X</emphasis> and <emphasis
                role="bold">B</emphasis>) and the Cholesky decomposition
                object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>cholsol_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>chold_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>chold_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>chold_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>chold_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>chold_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Over-determined Linear System Solver</title>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function></entry>

            <entry>Matrix QR Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function></entry>

            <entry>Create QR Decomposition Object</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function></entry>

            <entry>Destroy QRD Object</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></entry>

            <entry>QRD Get Attributes</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function></entry>

            <entry>Product with Q from QR Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function></entry>

            <entry>Solve Linear System Based on R from QR Dec.</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function></entry>

            <entry>Solve Covariance or LLSQ System</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dqrd">
      <title>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></title>

      <para>Compute a QR decomposition of a matrix .</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Compute a QR decomposition of a matrix. It is a requirement
            that <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>≥</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>. The QR decomposition of an M by N matrix
            <emphasis role="bold">A</emphasis> is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">Q</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">R</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">Q</emphasis> is an M by N
            orthogonal matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">Q</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">Q</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>) or <emphasis role="bold">Q</emphasis> is an M
            by N unitary matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">Q</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">Q</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>) and <emphasis role="bold">R</emphasis> is an
            upper triangular matrix. If <emphasis role="bold">A</emphasis> has
            full rank, then <emphasis role="bold">R</emphasis> is a
            nonsingular matrix. This routine does not perform any column
            interchanges.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_qrd_<replaceable>f</replaceable>(vsip_qr_<replaceable>f</replaceable> *qrd, const vsip_mview_<replaceable>f</replaceable> *A);
int vsip_cqrd_<replaceable>f</replaceable>(vsip_cqr_<replaceable>f</replaceable> *qrd, const vsip_cmview_<replaceable>f</replaceable> *A);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>qrd</term>

                <listitem>
                  <para>Pointer to a QR decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">A</emphasis>, M by N.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero on success. This routine will fail and return
            non-zero if <emphasis role="bold">A</emphasis> does not have full
            column rank, rank(<emphasis role="bold">A</emphasis>) = N.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> may be
            overwritten by the decomposition, and matrix <emphasis
            role="bold">A</emphasis> must not be modified as long as the
            factorization is required.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and input/output objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">A</emphasis> and the QR
                decomposition object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The matrix A is assumed to be of full rank. This property is
            not checked. A positive return value indicates that an error
            occurred and an exactly zero diagonal element of R was
            encountered.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dqrd_create">
      <title>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></title>

      <para>Create a QR decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Create a QR decomposition (QRD) object. The QR decomposition
            object encapsulates the information concerning the properties of
            the decomposition and required workspace. For example, given that
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>≥</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, the QR decomposition of an M by N matrix
            <emphasis role="bold">A</emphasis> is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi fontweight="bold">Q</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">R</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">Q</emphasis> is an M by N
            orthogonal matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">Q</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">Q</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>) or <emphasis role="bold">Q</emphasis> is an M
            by N unitary matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">Q</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">Q</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>) and <emphasis role="bold">R</emphasis> is an
            N by N upper triangular matrix. If <emphasis
            role="bold">A</emphasis> has full rank, then <emphasis
            role="bold">R</emphasis> is a nonsingular matrix. This routine
            does not perform any column interchanges.</para>

            <para>The <emphasis role="bold">R</emphasis> matrix will be
            generated and retained for later usage. However, there is a flag
            to indicate if the <emphasis role="bold">Q</emphasis> matrix is
            retained. It is an option to either retain the “skinny” <emphasis
            role="bold">Q</emphasis> or a full <emphasis
            role="bold">Q</emphasis>, where <emphasis role="bold">Q</emphasis>
            is an M by M orthogonal (unitary) matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_QRD_NOSAVEQ = 0, // Do not save Q
  VSIP_QRD_SAVEQ = 1,   // Save full Q
  VSIP_QRD_SAVEQ1 = 2   // Save skinny Q
} vsip_qrd_qopt;

vsip_qr_f *vsip_qrd_create_f(vsip_length M, vsip_length N, vsip_qrd_qopt qopt);
vsip_cqr_f *vsip_cqrd_create_f(vsip_length M, vsip_length N, vsip_qrd_qopt qopt);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>M</term>

                <listitem>
                  <para>The number of rows for the input matrix <emphasis
                  role="bold">A</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>The number of columns for the input matrix <emphasis
                  role="bold">A</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>qopt</term>

                <listitem>
                  <para>Indicates if the matrix Q is retained.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>The return value is a pointer to a QR decomposition object,
            or null if it fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>M and N positive with <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>N</m:mi>

                        <m:mo>≤</m:mo>

                        <m:mi>M</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>

              <listitem>
                <para>Qopt is valid: qopt ∈ {VSIP_QRD_NOSAVEQ, VSIP_QRD_SAVEQ,
                VSIP_QRD_SAVEQ1}.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dqrd_destroy">
      <title>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></title>

      <para>Destroy a QR decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroy (free memory) a QR decomposition object returning
            zero on success, and non-zero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_qrd_destroy_f(vsip_qr_f *qrd);
int vsip_cqrd_destroy_f(vsip_cqr_f *qrd);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>qrd</term>

                <listitem>
                  <para>Pointer to a QR decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero on success, and non-zero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input object must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The QR decomposition object must be valid. An argument
                of null is not an error.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dqrd_getattr">
      <title>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></title>

      <para>Returns the attributes of a QR decomposition object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the attributes of a QR decomposition object in
            structure passed by reference.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef struct 
{
  vsip_length m;     // The number of rows for the input matrix A
  vsip_length n;     // The number of columns for the input matrix A
  vsip_qrd_opt Qopt; // Indicates if the matrix Q is retained or not
} vsip_dqr_attr_f;
typedef enum 
{
  VSIP_QRD_NOSAVEQ = 0, // Do not save Q
  VSIP_QRD_SAVEQ = 1,   // Save Q
  VSIP_QRD_SAVEQ1 = 2   // Save Skinny Q
} vsip_qrd_qopt;

void vsip_qrd_getattr_f(const vsip_qr_f *qrd, vsip_qr_attr_f *attr);
void vsip_cqrd_getattr_f(const vsip_cqr_f *qrd, vsip_cqr_attr_f *attr);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>qrd</term>

                <listitem>
                  <para>Pointer to a QR decomposition object, created by
                  <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attr</term>

                <listitem>
                  <para>Pointer to output attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The QR decomposition object must be valid.</para>
              </listitem>

              <listitem>
                <para>The attribute pointer must be valid – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dqrdprodq">
      <title>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></title>

      <para>Multiply a matrix by the matrix <emphasis role="bold">Q</emphasis>
      from a QR decomposition.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This function overwrites a R by S matrix <emphasis
            role="bold">C</emphasis> with</para>

            <para><informaltable>
                <tgroup cols="3">
                  <colspec align="center"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi>Q</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mi>C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi>C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:msup>
                                <m:mi>Q</m:mi>

                                <m:mi>T</m:mi>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mi>C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi>C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi>Q</m:mi>

                                <m:mi>T</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:msup>
                                <m:mi>Q</m:mi>

                                <m:mi>H</m:mi>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mi>C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi>C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi>Q</m:mi>

                                <m:mi>H</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>Where the matrix <emphasis
            role="bold">Q</emphasis> was generated by the routine
            <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>.
            If an M by N matrix was the input matrix for the function
            <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>,
            then <emphasis role="bold">Q</emphasis> is either an M by M or M
            by N matrix, depending which option was used to generate <emphasis
            role="bold">Q</emphasis>.</para>

            <para>If <emphasis role="bold">Q</emphasis> was computed using the
            <constant>QRD_SAVEQ1</constant> option, then the following table
            lists the possible dimensions of the matrix C before and after
            this operation:</para>

            <para><informaltable>
                <tgroup cols="5">
                  <colspec align="center"/>

                  <colspec colname="i1"/>

                  <colspec colname="i2"/>

                  <colspec colname="o1"/>

                  <colspec colname="o2"/>

                  <spanspec nameend="i2" namest="i1" spanname="input"/>

                  <spanspec nameend="o2" namest="o1" spanname="output"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center" spanname="input">Input</entry>

                      <entry align="center" spanname="output">Output</entry>
                    </row>

                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry>N by S</entry>

                      <entry>R by M</entry>

                      <entry>M by S</entry>

                      <entry>R by N</entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry>M by S</entry>

                      <entry>R by N</entry>

                      <entry>N by S</entry>

                      <entry>R by M</entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry>M by S</entry>

                      <entry>R by N</entry>

                      <entry>N by S</entry>

                      <entry>R by M</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>Given that <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>≥</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, then for some options the result of this
            operation is a matrix that is larger than the input matrix. The
            matrix view object used for the input/output data is const. The
            first element of the input and the first element of the output are
            stored at element location (0,0) of the input/output matrix. Other
            elements are stored in their natural location in the block
            determined by the row stride and column stride of the input/output
            view.</para>

            <para>If Q was computed using the <constant>QRD_SAVEQ</constant>
            option, then the following table lists the possible dimensions of
            the matrix C before and after this operation:</para>

            <para><informaltable>
                <tgroup cols="3">
                  <colspec align="center"/>

                  <colspec colname="i1"/>

                  <colspec colname="i2"/>

                  <spanspec nameend="i2" namest="i1" spanname="input"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center" spanname="input">Input &amp;
                      Output</entry>
                    </row>

                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry>M by S</entry>

                      <entry>R by M</entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry>M by S</entry>

                      <entry>R by M</entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry>M by S</entry>

                      <entry>R by M</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{ 
  VSIP_MAT_NTRANS = 0, 
  VSIP_MAT_TRANS = 1, 
  VSIP_MAT_HERM = 2
} vsip_mat_op;
typedef enum 
{ 
  VSIP_MAT_LSIDE = 0, 
  VSIP_MAT_RSIDE = 1
} vsip_mat_side;

int vsip_qrdprodq_f(const vsip_qr_f *qrd, vsip_mat_op opQ, vsip_mat_side apQ,
                    const vsip_mview_f *C);
int vsip_cqrdprodq_f(const vsip_cqr_f *qrd, vsip_mat_op opQ, vsip_mat_side apQ,
                     const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>qrd</term>

                <listitem>
                  <para>Pointer to a QR decomposition object, generated by
                  <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>opQ</term>

                <listitem>
                  <para>Specifies the form of op(Q).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>apQ</term>

                <listitem>
                  <para>Indicates if op(Q) is applied on the left or right of
                  C.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>On entry, view of input matrix C, R by S. On output
                  the data is stored in natural order in the block determined
                  by the offset, row stride, and column stride of the input
                  matrix view. See restrictions below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the output data space may be larger than the input
            data space it is required that the input data view allow storage
            in the block for the output data. This means the row stride and
            column stride must be calculated to accommodate the larger data
            space, whether it be input or output.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>opQ is valid:</para>

                <itemizedlist>
                  <listitem>
                    <para>Real: opQ ∈{VSIP_MAT_NTRANS, VSIP_MAT_TRANS}</para>
                  </listitem>

                  <listitem>
                    <para>Complex: opQ ∈{VSIP_MAT_NTRANS,
                    VSIP_MAT_HERM}</para>
                  </listitem>
                </itemizedlist>
              </listitem>

              <listitem>
                <para>apQ is valid: apQ ∈{ VSIP_MAT_LSIDE,
                VSIP_MAT_RSIDE}</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">C</emphasis> and the QR
                decomposition object must be conformant.</para>
              </listitem>

              <listitem>
                <para>The QR decomposition object must have specified
                retaining the <emphasis role="bold">Q</emphasis> matrix when
                it was created.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>

            <para>One way to ensure the input/output data space is proper is
            to calculate the size of the output data space either using the
            tables under functionality above, or directly given knowledge of
            the input matrix sizes. If the output data space is larger than
            the input data space create a matrix view large enough to hold the
            output data. Create a subview of this with index offset at (0,0)
            of proper size to hold the input data. The new (sub) view is then
            the input to the function, and the original view will hold the
            output data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dqrdsolr">
      <title>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></title>

      <para>Solve linear system based on the matrix <emphasis
      role="bold">R</emphasis>, from QR decomposition of the matrix <emphasis
      role="bold">A</emphasis>.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Solve a triangular linear system of the form,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:mi>op</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi fontweight="bold">R</m:mi>
                        </m:mfenced>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi>α</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">B</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>op</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi fontweight="bold">R</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:math>
              </inlineequation> is one of the following</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">R</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">R</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">R</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">R</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>op</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi fontweight="bold">R</m:mi>
                      </m:mfenced>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:msup>
                      <m:mi fontweight="bold">R</m:mi>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><emphasis role="bold">R</emphasis> is an upper triangular N
            by N matrix ,and <emphasis role="bold">X</emphasis> and <emphasis
            role="bold">B</emphasis> are N by K matrices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{ 
  VSIP_MAT_NTRANS = 0, 
  VSIP_MAT_TRANS = 1, 
  VSIP_MAT_HERM = 2
} vsip_mat_op;

int vsip_qrdsolr_<replaceable>f</replaceable>(const vsip_qr_<replaceable>f</replaceable> *qrd, vsip_mat_op OpR, vsip_scalar_<replaceable>f</replaceable> alpha,
                   const vsip_mview_<replaceable>f</replaceable> *XB);
int vsip_cqrdsolr_<replaceable>f</replaceable>(const vsip_cqr_<replaceable>f</replaceable> *qrd, vsip_mat_op OpR, vsip_cscalar_<replaceable>f</replaceable> alpha,
                    const vsip_cmview_<replaceable>f</replaceable> *XB);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>qrd</term>

                <listitem>
                  <para>Pointer to a QR decomposition object, generated by
                  <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>OpR</term>

                <listitem>
                  <para>Specifies the form of op(R).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>(Real/Complex) scalar.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>XB</term>

                <listitem>
                  <para>View of input/output matrix of size N by K.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>opR is valid:</para>

                <itemizedlist>
                  <listitem>
                    <para>Real: opR ∈{VSIP_MAT_NTRANS, VSIP_MAT_TRANS}</para>
                  </listitem>

                  <listitem>
                    <para>Complex: opR ∈{VSIP_MAT_NTRANS,
                    VSIP_MAT_HERM}</para>
                  </listitem>
                </itemizedlist>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">XB</emphasis>
                (<emphasis role="bold">X</emphasis> and <emphasis
                role="bold">B</emphasis>) and the QR decomposition object must
                be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dqrsol">
      <title>vsip_<replaceable>d</replaceable>qrsol_<replaceable>p</replaceable></title>

      <para>Solve either a linear covariance or linear least squares
      problem.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Assume that <emphasis role="bold">A</emphasis> is a matrix
            of order M by N with rank N, <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>≥</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> and <emphasis role="bold">B</emphasis> is a
            matrix of order N by K for the covariance problem or M by K for
            the least squares problem. This routine solves one of the
            following problems using the decomposition computed by the routine
            <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>:
            A covariance linear system problem,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:msup>
                          <m:mi fontweight="bold">A</m:mi>

                          <m:mi>T</m:mi>
                        </m:msup>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">A</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">B</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mrow>
                        <m:msup>
                          <m:mi fontweight="bold">A</m:mi>

                          <m:mi>H</m:mi>
                        </m:msup>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">A</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">B</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or a linear least squares problem,</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:munder>
                      <m:mo>min</m:mo>

                      <m:mi>x</m:mi>
                    </m:munder>

                    <m:msub>
                      <m:mrow>
                        <m:mo>||</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mi fontweight="bold">A</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:mi fontweight="bold">X</m:mi>
                          </m:mrow>

                          <m:mo>-</m:mo>

                          <m:mi fontweight="bold">B</m:mi>
                        </m:mrow>

                        <m:mo>||</m:mo>
                      </m:mrow>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_COV = 0, // Solve a covariance linear system problem
  VSIP_LLS = 1  // Solve a linear least squares problem
} vsip_qrd_prob;

int vsip_qrsol_f(const vsip_qr_f *qrd, vsip_qrd_prob prob, const vsip_mview_f *XB);
int vsip_cqrsol_f(const vsip_qr_f *qrd, vsip_qrd_prob prob, const vsip_cmview_f *XB);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>qrd</term>

                <listitem>
                  <para>Pointer to QR decomposition object for the M by N
                  matrix, <emphasis role="bold">A</emphasis>, computed by the
                  routine
                  <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>prob</term>

                <listitem>
                  <para>Selects between the covariance and linear least
                  squares problem.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>XB</term>

                <listitem>
                  <para>On input view of input matrix B of size N by K for the
                  covariance problem or M by K for the least squares problem.
                  The view is const. The output data overwrites the input data
                  starting at index zero. For the least squares problem
                  elements of the input/output view starting at index N are
                  vendor dependent on output.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>This routine will fail if rank(<emphasis
            role="bold">A</emphasis>) &lt; N.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">XB</emphasis>
                (<emphasis role="bold">X</emphasis> and <emphasis
                role="bold">B</emphasis>) and the QR decomposition object must
                be conformant and must not overlap with the input
                matrix.</para>
              </listitem>

              <listitem>
                <para>prob is valid: prob ∈ {VSIP_COV, VSIP_LLS }</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>qrsol_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>qrd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>qrd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdprodq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrdsolr_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>qrd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>qrd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Singular Value Decomposition</title>

    <para>This section defines the singular value decomposition (SVD)
    routines. Unlike other matrix decomposition routines the SVD routines do
    not include a linear equation solver. However, systems of linear equations
    can be solved by using the matrix multiplication routines
    <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function>
    and
    <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svd_<replaceable>p</replaceable></function></entry>

            <entry>Matrix Singular Value Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function></entry>

            <entry>Create Singular Value Decomposition Object</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function></entry>

            <entry>Destroy SVD Object</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></entry>

            <entry>SVD Get Attributes</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function></entry>

            <entry>Product with U from SV Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function></entry>

            <entry>Product with V from SV Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svdmatu_<replaceable>p</replaceable></function></entry>

            <entry>Return with U from SV Decomposition</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>svdmatv_<replaceable>p</replaceable></function></entry>

            <entry>Return with V from SV Decomposition</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dsvd">
      <title>vsip_<replaceable>d</replaceable>svd_<replaceable>p</replaceable></title>

      <para>Compute the singular value decomposition of a matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes singular value decomposition of a matrix. The
            singular value decomposition of an M by N real matrix <emphasis
            role="bold">A</emphasis> is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">S</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">U</emphasis> is an M by M
            orthogonal matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">U</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>), S is an M by N zero matrix except for its
            min(M, N) diagonal elements, <emphasis role="bold">V</emphasis> is
            an N by N orthogonal matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">V</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>).</para>

            <para>The singular value decomposition of an M by N complex matrix
            <emphasis role="bold">A</emphasis> is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">S</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">U</emphasis> is an M by M
            unitary matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">U</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>), S is an M by N zero matrix except for its
            min(M, N) diagonal elements, <emphasis role="bold">V</emphasis> is
            an N by N unitary matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">V</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>).</para>

            <para>The diagonal elements of <emphasis role="bold">S</emphasis>
            are called the singular values of <emphasis
            role="bold">A</emphasis>, they are real and non-negative, and are
            returned in descending order. The first min(M, N) columns of
            <emphasis role="bold">U</emphasis> and <emphasis
            role="bold">V</emphasis> are called the singular vectors of
            <emphasis role="bold">A</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_svd_f(vsip_sv_f *svd, const vsip_mview_f *A, vsip_vview_f *s);
int vsip_csvd_f(vsip_csv_f *svd, const vsip_cmview_f *A, vsip_vview_f *s);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>A</term>

                <listitem>
                  <para>On entry, view of input matrix A, M by N.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>s</term>

                <listitem>
                  <para>A real vector of length min(M, N), containing the
                  output singular values of <emphasis role="bold">A</emphasis>
                  in descending order.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful. Returns a nonzero if the
            algorithm failed to be completed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The matrix <emphasis role="bold">A</emphasis> is overwritten
            by the decomposition, and matrix <emphasis
            role="bold">A</emphasis> must not be modified as long as the
            factorization is required.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input and input/output objects must conform to the
            following:</para>

            <orderedlist>
              <listitem>
                <para>All objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">A</emphasis>, vector s,
                and the SVD object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvd_create">
      <title>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></title>

      <para>Create the singular value decomposition (SVD) object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a singular value decomposition (SVD) object. The
            singular value decomposition of an M by N real matrix <emphasis
            role="bold">A</emphasis> is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">S</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">U</emphasis> is an M by M
            orthogonal matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">U</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>), S is an M by N zero matrix except for its
            min(M, N) diagonal elements, <emphasis role="bold">V</emphasis> is
            an N by N orthogonal matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">V</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>).</para>

            <para>The singular value decomposition of an M by N complex matrix
            <emphasis role="bold">A</emphasis> is given by</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">A</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi fontweight="bold">S</m:mi>
                      </m:mrow>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>where <emphasis role="bold">U</emphasis> is an M by M
            unitary matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">U</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">U</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>), S is an M by N zero matrix except for its
            min(M, N) diagonal elements, <emphasis role="bold">V</emphasis> is
            an N by N unitary matrix (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi fontweight="bold">V</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi fontweight="bold">V</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi fontweight="bold">I</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>).</para>

            <para>The diagonal elements of <emphasis role="bold">S</emphasis>
            are called the singular values of <emphasis
            role="bold">A</emphasis>, they are real and non-negative, and are
            returned in descending order. The first min(M, N) columns of
            <emphasis role="bold">U</emphasis> and <emphasis
            role="bold">V</emphasis> are called the singular vectors of
            <emphasis role="bold">A</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_SVD_UVNOS = 0,  // no columns of U are computed
  VSIP_SVD_UVFULL = 1, // all columns of U are computed
  VSIP_SVD_UVPART = 2  // first min(M,N) columns of U are computed
} vsip_svd_uv;

vsip_sv_f *vsip_svd_create_f(vsip_length M, vsip_length N,
                             vsip_svd_uv Usave, vsip_svd_uv Vsave);
vsip_csv_f *vsip_csvd_create_f(vsip_length M, vsip_length N
                               vsip_svd_uv Usave, vsip_svd_uv Vsave);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>M</term>

                <listitem>
                  <para>The number of rows for the input matrix <emphasis
                  role="bold">A</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>The number of columns for the input matrix <emphasis
                  role="bold">A</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Usave</term>

                <listitem>
                  <para>Specifies the options for computing <emphasis
                  role="bold">U</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Vsave</term>

                <listitem>
                  <para>Specifies the options for computing <inlineequation>
                      <m:math display="inline">
                        <m:msup>
                          <m:mi fontweight="bold">V</m:mi>

                          <m:mi>T</m:mi>
                        </m:msup>
                      </m:math>
                    </inlineequation>(<inlineequation>
                      <m:math display="inline">
                        <m:msup>
                          <m:mi fontweight="bold">V</m:mi>

                          <m:mi>H</m:mi>
                        </m:msup>
                      </m:math>
                    </inlineequation>).</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>The return value is a pointer to an SVD object, or null if
            it fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>M and N must be positive.</para>
              </listitem>

              <listitem>
                <para>Usave and Vsave valid:</para>

                <para>Usave, Vsave ∈ {VSIP_SVD_UVNOS, VSIP_SVD_UVFULL,
                VSIP_SVD_UVPART }.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvd_destroy">
      <title>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></title>

      <para>Destroy an SVD object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroy (free memory) an SVD object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_svd_destroy_f(vsip_sv_f *svd);
int vsip_csvd_destroy_f(vsip_csv_f *svd);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Return zero on success, and non-zero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input object must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The SVD object must be valid. An argument of null is not
                an error.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvd_getattr">
      <title>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></title>

      <para>Returns the attributes of an SVD object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the attributes of an SVD object in structure passed
            by reference.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_SVD_UVNOS = 0,  // no columns of U/rows of VT (VH) are computed
  VSIP_SVD_UVFULL = 1, // all columns of U/rows of VT (VH) are computed
  VSIP_SVD_UVPART = 2  // first min(M,N) columns of U/rows of VT (VH) are computed
} vsip_svd_uv;

typedef struct 
{
  vsip_length m;     // The number of rows for the input matrix A
  vsip_length n;     // The number of columns for the input matrix A
  vsip_svd_uv Usave; // Specifies the options for computing U
  vsip_svd_uv Vsave; // Specifies the options for computing VT (VH)
} vsip_dsv_attr_f;

void vsip_svd_getattr_f(vsip_sv_f const *svd, vsip_sv_attr_f *attr);
void vsip_csvd_getattr_f(vsip_csv_f const *svd, vsip_csv_attr_f *attr);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attr</term>

                <listitem>
                  <para>Pointer to output attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The SVD object must be valid.</para>
              </listitem>

              <listitem>
                <para>The attribute pointer must be valid - non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvdprodu">
      <title>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></title>

      <para>Multiply a matrix by the matrix <emphasis role="bold">U</emphasis>
      from a singular value decomposition.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This function overwrites an R by S matrix <emphasis
            role="bold">C</emphasis> with</para>

            <para><informaltable>
                <tgroup cols="3">
                  <colspec align="center"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">U</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">U</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:msup>
                                <m:mi fontweight="bold">U</m:mi>

                                <m:mi>T</m:mi>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi fontweight="bold">U</m:mi>

                                <m:mi>T</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:msup>
                                <m:mi fontweight="bold">U</m:mi>

                                <m:mi>H</m:mi>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi fontweight="bold">U</m:mi>

                                <m:mi>H</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>Where the matrix <emphasis
            role="bold">U</emphasis> was generated by the routine
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>.
            If an M by N matrix was the input matrix for the function
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>,
            then <emphasis role="bold">U</emphasis> is either an M by M or M
            by min(M,N) matrix, depending which option was used to generate
            <emphasis role="bold">U</emphasis>.</para>

            <para>If <emphasis role="bold">U</emphasis> was computed using the
            <constant>SVD_UVPART</constant> option, then the following table
            lists the possible dimensions of the matrix <emphasis
            role="bold">C</emphasis> before and after this operation:</para>

            <para><informaltable>
                <tgroup cols="5">
                  <colspec align="center"/>

                  <colspec colname="i1"/>

                  <colspec colname="i2"/>

                  <colspec colname="o1"/>

                  <colspec colname="o2"/>

                  <spanspec nameend="i2" namest="i1" spanname="input"/>

                  <spanspec nameend="o2" namest="o1" spanname="output"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center" spanname="input">Input</entry>

                      <entry align="center" spanname="output">Output</entry>
                    </row>

                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry>min(M,N) by S</entry>

                      <entry>R by M</entry>

                      <entry>M by S</entry>

                      <entry>R by min(M,N)</entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry>M by S</entry>

                      <entry>R by min(M,N)</entry>

                      <entry>min(M,N) by S</entry>

                      <entry>R by M</entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry>M by S</entry>

                      <entry>R by min(M,N)</entry>

                      <entry>min(M,N) by S</entry>

                      <entry>R by M</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>

            <para>For some options, the result of this operation is a matrix
            that is larger than the input matrix. The matrix view object used
            for the input/output data is const. The first element of the input
            and the first element of the output are stored at element location
            (0,0) of the input/output matrix. Other elements are stored in
            their natural location in the block determined by the row stride
            and column stride of the input/output view.</para>

            <para>If <emphasis role="bold">U</emphasis> was computed using the
            <constant>SVD_UVFULL</constant> option, then the following table
            lists the possible dimensions of the matrix <emphasis
            role="bold">C</emphasis> before and after this operation:</para>

            <para><informaltable>
                <tgroup cols="3">
                  <colspec align="center"/>

                  <colspec colname="i1"/>

                  <colspec colname="i2"/>

                  <spanspec nameend="i2" namest="i1" spanname="input"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center" spanname="input">Input &amp;
                      Output</entry>
                    </row>

                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry>M by S</entry>

                      <entry>R by M</entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry>M by S</entry>

                      <entry>R by M</entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry>M by S</entry>

                      <entry>R by M</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_svdprodu_f(const vsip_sv_f *svd, vsip_mat_op OpU, vsip_mat_side ApU,
                    const vsip_mview_f *C);
int vsip_csvdprodu_f(const vsip_csv_f *svd, vsip_mat_op OpU, vsip_mat_side ApU,
                     const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>opU</term>

                <listitem>
                  <para>Specifies the form of op(<emphasis
                  role="bold">U</emphasis>).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>ApU</term>

                <listitem>
                  <para>Indicates if op(<emphasis role="bold">U</emphasis>) is
                  applied on the left or right of <emphasis
                  role="bold">C</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">C</emphasis>, R by S. On output the data is
                  stored in natural order in the block determined by the
                  offset, row stride, and column stride of the input matrix
                  view. See restrictions below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the output data space may be larger than the input
            data space it is required that the input data view allow storage
            in the block for the output data. This means the row stride and
            column stride must be calculated to accommodate the larger data
            space, whether it be input or output.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects are valid.</para>
              </listitem>

              <listitem>
                <para>OpU is valid:<itemizedlist>
                    <listitem>
                      <para>Real: OpU ∈ {VSIP_MAT_NTRANS, VSIP_MAT_TRANS
                      }</para>
                    </listitem>

                    <listitem>
                      <para>Complex: OpU ∈ {VSIP_MAT_NTRANS, VSIP_MAT_HERM
                      }</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>

              <listitem>
                <para>ApU is valid: ApU ∈ {VSIP_MAT_LSIDE, VSIP_MAT_RSIDE
                }.</para>
              </listitem>

              <listitem>
                <para>The SVD object must have been created with the argument
                "Usave" set to <constant>VSIP_SVD_UVFULL</constant> or
                <constant>VSIP_SVD_UVPART</constant>.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">C</emphasis>, and the
                SVD object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>

            <para>One way to ensure the input/output data space is proper is
            to calculate the size of the output data space either using the
            tables under functionality above, or directly given knowledge of
            the input matrix sizes. If the output data space is larger than
            the input data space create a matrix view large enough to hold the
            output data. Create a subview of this with index offset at (0,0)
            of proper size to hold the input data. The new (sub) view is then
            the input to the function, and the original view will hold the
            output data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvdprodv">
      <title>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></title>

      <para>Multiply a matrix by the matrix <emphasis role="bold">V</emphasis>
      from a singular value decomposition.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This function overwrites an R by S matrix <emphasis
            role="bold">C</emphasis> with</para>

            <para><informaltable>
                <tgroup cols="3">
                  <colspec align="center"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">V</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">V</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:msup>
                                <m:mi fontweight="bold">V</m:mi>

                                <m:mi>T</m:mi>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi fontweight="bold">V</m:mi>

                                <m:mi>T</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:msup>
                                <m:mi fontweight="bold">V</m:mi>

                                <m:mi>H</m:mi>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mi fontweight="bold">C</m:mi>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>

                      <entry><inlineequation>
                          <m:math display="inline">
                            <m:mrow>
                              <m:mi fontweight="bold">C</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi fontweight="bold">V</m:mi>

                                <m:mi>H</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:math>
                        </inlineequation></entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>Where the matrix <emphasis
            role="bold">V</emphasis> was generated by the routine
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>.
            If an M by N matrix was the input matrix for the function
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>,
            then <emphasis role="bold">V</emphasis> is either a N by N or N by
            min(M,N) matrix, depending which option was used to generate
            <emphasis role="bold">V</emphasis>.</para>

            <para>If <emphasis role="bold">V</emphasis> was computed using the
            <constant>SVD_UVPART</constant> option, then the following table
            lists the possible dimensions of the matrix <emphasis
            role="bold">C</emphasis> before and after this operation:</para>

            <para><informaltable>
                <tgroup cols="5">
                  <colspec align="center"/>

                  <colspec colname="i1"/>

                  <colspec colname="i2"/>

                  <colspec colname="o1"/>

                  <colspec colname="o2"/>

                  <spanspec nameend="i2" namest="i1" spanname="input"/>

                  <spanspec nameend="o2" namest="o1" spanname="output"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center" spanname="input">Input</entry>

                      <entry align="center" spanname="output">Output</entry>
                    </row>

                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry>min(M,N) by S</entry>

                      <entry>R by N</entry>

                      <entry>N by S</entry>

                      <entry>R by min(M,N)</entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry>N by S</entry>

                      <entry>R by min(M,N)</entry>

                      <entry>min(M,N) by S</entry>

                      <entry>R by N</entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry>N by S</entry>

                      <entry>R by min(M,N)</entry>

                      <entry>min(M,N) by S</entry>

                      <entry>R by N</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>

            <para>For some options, the result of this operation is a matrix
            that is larger than the input matrix. The matrix view object used
            for the input/output data is const. The first element of the input
            and the first element of the output are stored at element location
            (0,0) of the input/output matrix. Other elements are stored in
            their natural location in the block determined by the row stride
            and column stride of the input/output view.</para>

            <para>If <emphasis role="bold">V</emphasis> was computed using the
            <constant>SVD_UVFULL</constant> option, then the following table
            lists the possible dimensions of the matrix <emphasis
            role="bold">C</emphasis> before and after this operation:</para>

            <para><informaltable>
                <tgroup cols="3">
                  <colspec align="center"/>

                  <colspec colname="i1"/>

                  <colspec colname="i2"/>

                  <spanspec nameend="i2" namest="i1" spanname="input"/>

                  <thead>
                    <row>
                      <entry align="center"/>

                      <entry align="center" spanname="input">Input &amp;
                      Output</entry>
                    </row>

                    <row>
                      <entry align="center"/>

                      <entry align="center">MAT_LSIDE</entry>

                      <entry align="center">MAT_RSIDE</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry>MAT_NTRANS</entry>

                      <entry>N by S</entry>

                      <entry>R by N</entry>
                    </row>

                    <row>
                      <entry>MAT_TRANS</entry>

                      <entry>N by S</entry>

                      <entry>R by N</entry>
                    </row>

                    <row>
                      <entry>MAT_HERM</entry>

                      <entry>N by S</entry>

                      <entry>R by N</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_svdprodv_f(const vsip_sv_f *svd, vsip_mat_op OpV, vsip_mat_side ApV,
                    const vsip_mview_f *C);
int vsip_csvdprodv_f(const vsip_csv_f *svd, vsip_mat_op OpV, vsip_mat_side ApV,
                     const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>opV</term>

                <listitem>
                  <para>Specifies the form of op(<emphasis
                  role="bold">V</emphasis>).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>ApV</term>

                <listitem>
                  <para>Indicates if op(<emphasis role="bold">V</emphasis>) is
                  applied on the left or right of <emphasis
                  role="bold">C</emphasis>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>On entry, view of input matrix <emphasis
                  role="bold">C</emphasis>, R by S. On output the data is
                  stored in natural order in the block determined by the
                  offset, row stride, and column stride of the input matrix
                  view. See restrictions below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the output data space may be larger than the input
            data space it is required that the input data view allow storage
            in the block for the output data. This means the row stride and
            column stride must be calculated to accommodate the larger data
            space, whether it be input or output.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects are valid.</para>
              </listitem>

              <listitem>
                <para>OpV is valid:<itemizedlist>
                    <listitem>
                      <para>Real: OpV ∈ {VSIP_MAT_NTRANS, VSIP_MAT_TRANS
                      }</para>
                    </listitem>

                    <listitem>
                      <para>Complex: OpV ∈ {VSIP_MAT_NTRANS, VSIP_MAT_HERM
                      }</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>

              <listitem>
                <para>ApV is valid: ApV ∈ {VSIP_MAT_LSIDE, VSIP_MAT_RSIDE
                }.</para>
              </listitem>

              <listitem>
                <para>The SVD object must have been created with the argument
                "Vsave" set to <constant>VSIP_SVD_UVFULL</constant> or
                <constant>VSIP_SVD_UVPART</constant>.</para>
              </listitem>

              <listitem>
                <para>The matrix <emphasis role="bold">C</emphasis>, and the
                SVD object must be conformant.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>

            <para>One way to ensure the input/output data space is proper is
            to calculate the size of the output data space either using the
            tables under functionality above, or directly given knowledge of
            the input matrix sizes. If the output data space is larger than
            the input data space, create a matrix view large enough to hold
            the output data. Create a subview of this with index offset at
            (0,0) of proper size to hold the input data. The new (sub) view is
            then the input to the function, and the original view will hold
            the output data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodu_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvdmatu">
      <title>vsip_<replaceable>d</replaceable>svdmatu_<replaceable>p</replaceable></title>

      <para>Returns consecutive columns in the matrix <emphasis
      role="bold">U</emphasis> from a singular value decomposition.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns consecutive columns in the matrix <emphasis
            role="bold">U</emphasis> from a singular value decomposition of an
            M by N matrix, starting with the column low and finishing with
            column high. Let <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>u</m:mi>

                    <m:mi>j</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> denote the jth column in the matrix <emphasis
            role="bold">U</emphasis>. This functions returns the following
            matrix:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>U</m:mi>

                              <m:mi>low</m:mi>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>U</m:mi>

                              <m:mrow>
                                <m:mi>low</m:mi>

                                <m:mo>+</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>U</m:mi>

                              <m:mrow>
                                <m:mi>low</m:mi>

                                <m:mo>+</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>U</m:mi>

                              <m:mrow>
                                <m:mi>high</m:mi>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_svdmatu_f(const vsip_sv_f *svd, vsip_scalar_vi low, vsip_scalar_vi high,
                   const vsip_mview_f *C);
int vsip_csvdmatu_f(const vsip_csv_f *svd, vsip_scalar_vi low, vsip_scalar_vi high,
                    const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>low</term>

                <listitem>
                  <para>Specifies the first column in <emphasis
                  role="bold">U</emphasis></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>high</term>

                <listitem>
                  <para>Specifies the last column in <emphasis
                  role="bold">U</emphasis></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>On output the data is stored in natural order in the
                  block determined by the offset, row stride, and column
                  stride of the input matrix view. See restrictions
                  below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Low and high are required to be less than the number of
            columns in U.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects are valid.</para>
              </listitem>

              <listitem>
                <para>low must be less than or equal to high</para>
              </listitem>

              <listitem>
                <para>The SVD object must have been created with the argument
                "Usave" set to <constant>VSIP_SVD_UVFULL</constant> or
                <constant>VSIP_SVD_UVPART</constant>.</para>
              </listitem>

              <listitem>
                <para>If the SVD object was created with the argument “Usave”
                set to <constant>VSIP_SVD_UVPART</constant>, then high must be
                less than or equal to the number of columns for the matrix
                <emphasis role="bold">U</emphasis>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>svdmatu_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsvdmatv">
      <title>vsip_<replaceable>d</replaceable>svdmatv_<replaceable>p</replaceable></title>

      <para>Returns consecutive columns in the matrix <emphasis
      role="bold">V</emphasis> from a singular value decomposition.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns consecutive columns in the matrix <emphasis
            role="bold">V</emphasis> from a singular value decomposition of an
            M by N matrix, starting with the column low and finishing with
            column high. Let <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>v</m:mi>

                    <m:mi>j</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> denote the jth column in the matrix <emphasis
            role="bold">V</emphasis>. This function returns the following
            matrix:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi fontweight="bold">C</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>[</m:mo>

                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>V</m:mi>

                              <m:mi>low</m:mi>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>V</m:mi>

                              <m:mrow>
                                <m:mi>low</m:mi>

                                <m:mo>+</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>V</m:mi>

                              <m:mrow>
                                <m:mi>low</m:mi>

                                <m:mo>+</m:mo>

                                <m:mn>2</m:mn>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>

                          <m:mtd>
                            <m:mo>⋯</m:mo>
                          </m:mtd>

                          <m:mtd>
                            <m:msub>
                              <m:mi>V</m:mi>

                              <m:mrow>
                                <m:mi>high</m:mi>
                              </m:mrow>
                            </m:msub>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>

                      <m:mo>]</m:mo>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_svdmatv_f(const vsip_sv_f *svd, vsip_scalar_vi low, vsip_scalar_vi high,
                   const vsip_mview_f *C);
int vsip_csvdmatv_f(const vsip_csv_f *svd, vsip_scalar_vi low, vsip_scalar_vi high,
                    const vsip_cmview_f *C);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>svd</term>

                <listitem>
                  <para>Pointer to an SVD object, created by
                  <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>low</term>

                <listitem>
                  <para>Specifies the first column in <emphasis
                  role="bold">V</emphasis></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>high</term>

                <listitem>
                  <para>Specifies the last column in <emphasis
                  role="bold">V</emphasis></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>C</term>

                <listitem>
                  <para>On output the data is stored in natural order in the
                  block determined by the offset, row stride, and column
                  stride of the input matrix view. See restrictions
                  below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns zero if successful.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Low and high are required to be less than the number of
            columns in <emphasis role="bold">V</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The input arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All objects are valid.</para>
              </listitem>

              <listitem>
                <para>low must be less than or equal to high</para>
              </listitem>

              <listitem>
                <para>The SVD object must have been created with the argument
                "Usave" set to <constant>VSIP_SVD_UVFULL</constant> or
                <constant>VSIP_SVD_UVPART</constant>.</para>
              </listitem>

              <listitem>
                <para>If the SVD object was created with the argument “Usave”
                set to <constant>VSIP_SVD_UVPART</constant>, then high must be
                less than or equal to the number of columns for the matrix
                <emphasis role="bold">V</emphasis>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is okay to call
            <function>vsip_<replaceable>d</replaceable>svdmatv_<replaceable>f</replaceable></function>
            after
            <function>vsip_<replaceable>d</replaceable>svd_<replaceable>f</replaceable></function>
            fails. This will result in a non-zero, unsuccessful, return
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>svd_create_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svdprodv_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>svd_destroy_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>svd_getattr_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</chapter>
