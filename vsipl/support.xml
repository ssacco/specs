<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="support"
	 xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Support Functions</title>

  <section>
    <title>Introduction</title>

    <para>This section covers the support functions needed by VSIPL. These
    support functions include routines to initialize and to finalize VSIPL
    function usage, as well as to create, destroy, and manipulate VSIPL block
    and view objects. The support functions are divided into five sections,
    describing library initialization and finalization functions, array and
    block object functions, vector view functions, matrix view functions, and
    tensor view functions. In each of the latter four sections, the functions
    may be divided into creation, destruction, and manipulation
    functions.</para>

    <section>
      <title>Library Initialization and Finalization</title>

      <para>Before any other VSIPL functions can be called, the VSIPL library
      must be initialized by a call to <function>vsip_init</function>.
      Conversely, any program that uses VSIPL and that terminates must call
      <function>vsip_finalize</function> before terminating.</para>

      <para>To support third party libraries that use VSIPL without the
      knowledge of the application programmer, calls to
      <function>vsip_init</function> and <function>visp_finalize</function>
      functions may be nested. In addition, sequences of
      <function>vsip_init</function> and <function>vsip_finalize</function>
      pairs may occur in a given program. The following program is
      legal:</para>

      <programlisting>
/* Example of nesting and sequence of init/finalize */
#include “vsip.h”
int main()
{
  /* Nested vsip_init and vsip_finalize */
  vsip_init ((void *)0);
  vsip_init ((void *)0);
  vsip_finalize ((void *)0);
  vsip_finalize ((void *)0);
  /* No VSIPL calls permitted here….*/
  vsip_init ((void *)0);
  /* A second appearance of VSIPL calls */
  vsip_finalize ((void *)0);
  return 0;
}  </programlisting>

      <para>If <function>vsip_init</function> and
      <function>vsip_finalize</function> functions are called multiple times,
      then the calls must be made in pairs. The intermediate
      <function>vsip_init</function> calls (after the first) and the
      intermediate <function>vsip_finalize</function> calls (before the one
      corresponding to the first <function>vsip_init</function> call) may have
      little or no effect. If the VSIPL library has not been initialized, or
      has been terminated, no calls to VSIPL functions other than
      <function>vsip_init</function> are allowed.</para>

      <para>The user must destroy all VSIPL objects before calling
      vsip_finalize. In the case of nested calls to
      <function>vsip_init</function> and <function>vsip_finalize</function>,
      all VSIPL objects must be destroyed before the outermost call to
      <function>vsip_finalize</function>.</para>
    </section>

    <section>
      <title>Object Creation and Destruction</title>

      <para>Functions to create and destroy each particular type of object are
      included. A block is typically created first, followed by one or more
      views of the block. Every VSIPL object that is created must eventually
      be destroyed. All views on a block should be destroyed before the block
      is destroyed. Convenience functions are included to create both a block
      and a view of the block with a single call. These functions return the
      view. The view encompasses all the data in the block, and contains the
      block object pointer as an attribute. Convenience functions are also
      included to destroy a view and a block together when the view in
      question is the only one that references the block. This function is the
      dual of the view creation function. For the vector view, these
      convenience functions are called
      vsip_vcreate_<replaceable>p</replaceable> and
      vsip_valldestroy_<replaceable>p</replaceable>.</para>

      <section>
        <title>Block Object Manipulation</title>

        <para>In order to create a block, a
        <function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function>
        or
        <function>vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></function>
        function is used. The
        <function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function>
        functions create a VSIPL block. The
        <function>vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></function>
        functions create a user block.</para>

        <para>Blocks do not have attributes that can be directly manipulated,
        but they exist in either the released or admitted state, as explained
        in the introduction. A released block may be admitted to VSIPL, at
        which time the block functions like any other VSIPL block. When the
        application programmer wishes to access the data directly, a block in
        an admitted state must first be released from VSIPL. The purpose of
        defining an admitted state is to provide the VSIPL implementation the
        opportunity to operate on the VSIPL object in any manner necessary for
        optimum performance without making such optimizations visible to the
        application programmer. Potential optimizations include, but are not
        limited to, deferred execution, explicit management of a hierarchical
        memory system, and use of system specific resources.</para>

        <para>VSIPL effectively owns the data in an admitted block. The
        purpose of release is to give ownership of the data back to the
        application programmer. When an admitted block is released, all
        operations on the data associated with that block must be completed
        before the release function returns the block to the released
        state.</para>

        <para>A user block may be admitted and released multiple times during
        the application, and it is possible that the data in the associated
        user data array may not be required by the application during any
        individual admit or release operation. To provide the implementor with
        an opportunity for further optimization, the admit and release
        function each provide a boolean update flag. If this flag is false
        then the data need not be maintained during a particular admit or
        release operation.</para>

        <para>A VSIPL block is one created directly by VSIPL using a VSIPL
        create function which allocates memory for the block object and the
        data array. A VSIPL block is created in the admitted state and may not
        be released. To access this data the application programmer must use a
        VSIPL access function (such as get or put), or must copy the data to a
        block which may be released. Only blocks bound to a user data array
        (user blocks) may be released.</para>
      </section>

      <section>
        <title>View Object Manipulation</title>

        <para>Vector, matrix, and tensor view objects allow the user to treat
        data in a block as one, two, or three-dimensional objects
        (respectively). All view objects have four categories of attributes:
        the block that they are bound to, an offset from the start of the
        block, and a stride and length for each dimension of the view object.
        The block attribute can be read by the user but not altered after the
        view is created. Functions are provided for the user to read and set
        the other view attributes.</para>

        <para>VSIPL provides functions that allow a view to be created as a
        subset of another view. For higher-dimensional view objects (matrices
        and tensors), additional functions provide the ability to view part of
        the data set as a lower-dimensional object.</para>
      </section>
    </section>

    <section>
      <title>Complex Blocks and Views</title>

      <para>As described in the introduction, a complex data array is not
      necessarily an array of complex scalars. For VSIPL data, the internal
      behavior of complex objects is hidden from the application programmer by
      the implementation. In the case of user data complex arrays are defined
      as either interleaved, which is sequential memory locations of
      real/imaginary pairs; or as split, which is real in sequential order in
      one section of memory, and imaginary in matching sequential order in
      another section of memory. For split complex, the memory for the real
      part may not necessarily be contiguous with the memory of the imaginary
      part. Upon admission of a user complex block to VSIPL, the layout of the
      data is no longer visible and is implementation dependent. Upon release
      of a user complex block from VSIPL the complex layout is the same as
      when the block was initially created.</para>

      <para>The stride, length and offset of complex data are in terms of a
      complex element. The stride and offset of real or imaginary views of
      complex data are vendor dependent and must be probed using get attribute
      functions if the information is needed. For admitted VSIPL objects the
      data array is controlled by the implementation. To manipulate complex
      data VSIPL functions provided for that purpose must be used.</para>
    </section>

    <section>
      <title>Real Views of Real or Imaginary Parts of Complex Views</title>

      <para>Functions are available which allow one to retrieve a real view of
      the real or imaginary portion of a complex view. The returned view acts
      like any other real view. It is possible to make subviews of it, query
      it to obtain its real block and attributes, and to use the attribute
      information to bind other views to the space encompassed by the real
      block. These views have the following special conditions:</para>

      <orderedlist>
        <listitem>
          <para>The attribute information (block, offset, stride, and length)
          of a real view obtained from a complex view are vendor
          dependent.</para>
        </listitem>

        <listitem>
          <para>The underlying data space of the real view is owned by the
          complex block of the complex view that the real view was derived
          from.</para>
        </listitem>

        <listitem>
          <para>It is an error to destroy the block of any real view derived
          from a complex view. The view is destroyed in the normal manner, but
          the block bound to it is destroyed by the implementation when the
          complex block is destroyed.</para>
        </listitem>

        <listitem>
          <para>Real blocks derived from complex views bound to user data may
          not be directly admitted or released. Such blocks are admitted or
          released when the complex block bound to the user data is admitted
          or released.</para>
        </listitem>

        <listitem>
          <para>Using a block find on a real block derived from a complex
          block bound to user data will produce a null value.</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Examples</title>

      <para>Examples in the Support section are, for the most part, code
      fragments. For complete examples, see the clause on Vector and
      Elementwise operations.</para>
    </section>
  </section>

  <section>
    <title>Initialization/Finalization Operations</title>

    <para>Two functions, vsip_init and vsip_finalize, are provided to control
    the initialization and finalization of VSIPL. The use of these
    initialization and finalization functions is required for all VSIPL
    programs. Programs that never terminate (e.g., periodic loops) need never
    invoke the finalization function, but all programs that terminate must
    first call vsip_finalize. All programs must use the vsip_init function
    before calling other VSIPL functions. These functions may be nested in
    order to support third party and nested libraries. It is correct to
    initialize and finalize VSIPL an arbitrary number of times during the
    lifetime of a program.<synopsis>vsip_init(); /* Initialization Function */
vsip_finalize() /* Finalization (or termination) Function */</synopsis></para>

    <section xml:id="init">
      <title><function>vsip_init</function> - Initialize the library</title>

      <para>Provides initialization, allowing the implementation to allocate
      and set any global state, and prepare to support the use of VSIPL
      functionality by the user.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This required function informs the VSIPL library that
            library initialization is requested, and that other VSIPL
            functions will be called. Each implementation does as much or as
            little internally as is needed in order to support VSIPL services.
            Some implementations may do little or nothing at this stage, while
            others may do quite a bit of resource management. All programs
            must call this function at least once. The example illustrates a
            canonical form of a VSIPL program. It may be called multiple times
            as well, with corresponding calls to vsip_finalize to create
            nested pairs of initialization/termination. Only the final
            vsip_finalize call will actually deinitialize the library.
            Intermediate calls to vsip_init may have little or no effect, but
            support easy program/library development through compositional
            programming, where the user may not even know that a library
            itself invokes VSIPL. The single void* argument is reserved for
            future purposes. The NULL pointer should be passed to it for VSIPL
            1.4 compliance.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_init(void *);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <para>There is no argument value to be passed other than (void *)0
            at this point. This is an argument reserved for future
            purposes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns 0 if the initialization succeeded, and non-zero
            otherwise.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>This function may be called anytime during the execution of
            the program.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>All programs must use the initialization function
            (vsip_init) before calling any other VSIPL functions. Unsuccessful
            initialization of the library is not an error. It is always
            signaled via the function’s return value, and should always be
            checked by the application. Several modes of usage of the
            initialize/terminate are supported: nested
            (init/init/code/finalize/finalize), sequences (init/code/finalize
            … init/code/finalize), and generalizations of these.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting>/* Canonical form of a VSIPL program */
#include "vsip.h"
int main()
{
  /* no VSIPL calls except: vsip_init() at this stage */
  vsip_init((void *)0);
  /* all VSIPL calls here,
  including pairs of vsip_init() and vsip_finalize()... */
  vsip_finalize((void *)0);
  /* no VSIPL calls until another vsip_init */
  return 0;
}</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link linkend="finalize">vsip_finalize</link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="finalize">
      <title><function>vsip_finalize</function> - Terminate the
      library</title>

      <para>Provides cleanup and releases resources used by VSIPL (if the last
      of a nested series of calls), allowing an implementation to guarantee
      that any resources allocated by vsip_init are no longer in use after the
      call is complete.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This required function informs the VSIPL library that it is
            not being used anymore by a program, so that all needed global
            state and hardware state can be returned. Each implementation does
            as much or as little internally as is needed in order to support
            cleanup of VSIPL services. Some implementations may do little or
            nothing at this stage, while others may do quite a bit of resource
            management. All programs must call this function at least once if
            they terminate. If the program does terminate, the last VSIPL
            function called must be an outermost vsip_finalize. Because nested
            vsip_init’s are supported, so are nested vsip_finalize’s. The user
            must explicitly destroy all VSIPL objects before calling this
            function if this is an “outermost” vsip_finalize. When nesting
            initializations, there is no need to destroy all objects prior to
            calling this function, but the user is obliged to keep track of
            the nesting depth if programs are written in such a manner.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_finalize(void *);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <para>There is a reserved argument, which must have the value
            (void *)0 for VSIPL 1.4 compliance.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns 0 if the finalization succeeded, and non-zero
            otherwise. Non-outermost vsip_finalize’s always return
            “success.”</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>This function may only be called if a previous vsip_init
            call has been called, with no previous corresponding
            vsip_finalize.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>An outermost vsip_finalize function produces an error if
            there are any VSIPL objects not destroyed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The user program is always responsible for returning
            resources it is no longer using by destroying VSIPL objects. An
            outermost finalization function (vsip_finalize) will return
            resources that it allocated previously with vsip_init.
            Non-outermost vsip_finalize’s always return zero (success).</para>

            <para>Several modes of usage of the initialize/terminate are
            supported: nested (init/init/code/finalize/finalize), sequences
            (init/code/finalize … init/code/finalize), and generalizations of
            these.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>See example for vsip_init.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link linkend="init">vsip_init</link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Array and Block Object Functions</title>

    <para>This section covers the functions needed to create, destroy, and
    manipulate VSIPL blocks. A VSIPL block includes state information about
    the status of the blocks data (admitted or released), and the type of data
    arrays associated with the block (user and/or VSIPL data arrays). Blocks
    of type vsip_block_<replaceable>p</replaceable> (a real block) also must
    contain state information to indicate if they are a derived block (derived
    from a complex block). A block of type
    vsip_cblock_<replaceable>p</replaceable> must contain information about
    any real block derived from it. In addition, in development mode, the
    block includes information about the size of the data array the block
    references, and the number of vector, matrix or tensor objects that are
    bound to the block.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></entry>

            <entry>Block Admit</entry>
          </row>

          <row>
            <entry>vsip_blockbind_<replaceable>p</replaceable></entry>

            <entry>Memory Block Bind</entry>
          </row>

          <row>
            <entry>vsip_cblockbind_<replaceable>p</replaceable></entry>

            <entry>Complex Memory Block Bind</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></entry>

            <entry>Memory Block Create</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></entry>

            <entry>Memory Block Destroy</entry>
          </row>

          <row>
            <entry>vsip_blockrebind_<replaceable>p</replaceable></entry>

            <entry>Block Rebind</entry>
          </row>

          <row>
            <entry>vsip_blockfind_<replaceable>p</replaceable></entry>

            <entry>Memory Block Find</entry>
          </row>

          <row>
            <entry>vsip_cblockfind_<replaceable>p</replaceable></entry>

            <entry>Memory Complex Block Find</entry>
          </row>

          <row>
            <entry>vsip_cblockrebind_<replaceable>p</replaceable></entry>

            <entry>Complex Block Rebind</entry>
          </row>

          <row>
            <entry>vsip_blockrelease_<replaceable>p</replaceable></entry>

            <entry>Block Release</entry>
          </row>

          <row>
            <entry>vsip_cblockrelease_<replaceable>p</replaceable></entry>

            <entry>Complex Block Release</entry>
          </row>

          <row>
            <entry>vsip_complete</entry>

            <entry>Complete Deferred Execution</entry>
          </row>

          <row>
            <entry>vsip_cstorage_<replaceable>p</replaceable></entry>

            <entry>Complex Storage</entry>
          </row>

          <row>
            <entry>vsip_cstorage</entry>

            <entry>Deprecated; see Notes to Implementors</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dblockadmit">
      <title>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></title>

      <para>Admit a VSIPL block for VSIPL operations.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Admits a VSIPL block,
            vsip_<replaceable>d</replaceable>block_<replaceable>p</replaceable>,
            for VSIPL operations on the associated views. Admission changes
            the ownership of the user data array to VSIPL, and the user should
            not operate on the data array after the block is admitted. It
            returns non-zero if the admission fails. A true update flag
            indicates that the data in the block shall be made consistent with
            the userspecified data array. If the update flag is false the data
            in the block is implementation dependent and the user should
            consider the block to contain undefined data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>int vsip_blockadmit_<replaceable>f</replaceable>(vsip_block_<replaceable>f</replaceable> *block, vsip_scalar_bl update);
int vsip_cblockadmit_<replaceable>f</replaceable>(vsip_cblock_<replaceable>f</replaceable> *block, vsip_scalar_bl update);
int vsip_blockadmit_<replaceable>i</replaceable>(vsip_block_<replaceable>i</replaceable> *block, vsip_scalar_bl update);
int vsip_cblockadmit_<replaceable>i</replaceable>(vsip_cblock_<replaceable>i</replaceable> *block, vsip_scalar_bl update);
int vsip_blockadmit_bl(vsip_block_bl *block, vsip_scalar_bl update);
int vsip_blockadmit_vi(vsip_block_vi *block, vsip_scalar_bl update);
int vsip_blockadmit_mi(vsip_block_mi *block, vsip_scalar_bl update);
int vsip_blockadmit_ti(vsip_block_ti *block, vsip_scalar_bl update);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to a block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>update</term>

                <listitem>
                  <para>Boolean flag where true indicates that the data array
                  values must be maintained during the state change.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns zero on success and non-zero on failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is not an error to admit a block that is already in the
            admitted state.</para>

            <para>The intent of using a false update flag is that if the data
            in the user array is not needed, then there is no need to force
            consistency between the block object’s data and the user-specified
            data array with a potential copy operation.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>See example with
            vsip_<replaceable>d</replaceable>blockrelease_<replaceable>p</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="cblockbind"><function>vsip_cblockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_cblockadmit_<replaceable>p</replaceable></function></link>,
            <function>vsip_<replaceable>d</replaceable>blockrelease_<replaceable>p</replaceable></function>,
            <link
            linkend="blockfind"><function>vsip_blockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockfind"><function>vsip_cblockfind_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="blockbind">
      <title>vsip_blockbind_<replaceable>p</replaceable></title>

      <para>Create and bind a VSIPL block to user allocated (user data array)
      memory.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real VSIPL block object,
            vsip_block_<replaceable>p</replaceable>, and binds the block
            object to a user-defined user data array. The data array should
            contain at least N vsip_scalar_<replaceable>p</replaceable>
            elements. The function returns a pointer to the block object. The
            block is created in the released state and must be admitted to
            VSIPL before calling VSIPL functions that operate on the
            data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_<replaceable>f</replaceable> *vsip_blockbind_<replaceable>f</replaceable>(vsip_scalar_<replaceable>f</replaceable> *data, vsip_length N, 
                               vsip_memory_hint hint);
vsip_block_<replaceable>i</replaceable> *vsip_blockbind_<replaceable>i</replaceable>(vsip_scalar_<replaceable>i</replaceable> *data, vsip_length N, 
                               vsip_memory_hint hint);
vsip_block_bl *vsip_blockbind_bl(vsip_scalar_bl *data, vsip_length N, 
                                 vsip_memory_hint hint);
vsip_block_vi *vsip_blockbind_vi(vsip_scalar_vi *data, vsip_length N, 
                                 vsip_memory_hint hint);
vsip_block_mi *vsip_blockbind_mi(vsip_scalar_vi *data, vsip_length N, 
                                 vsip_memory_hint hint);
vsip_block_ti *vsip_blockbind_ti(vsip_scalar_vi *data, vsip_length N, 
                                 vsip_memory_hint hint);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>data</term>

                <listitem>
                  <para>Pointer to a data array of contiguous memory
                  containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of elements, of user data array, to which a
                  user block, vsip_block_<replaceable>p</replaceable>, is
                  bound.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>hint</term>

                <listitem>
                  <para>Memory hint</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer of type
            vsip_block_<replaceable>p</replaceable>, or returns null if the
            block bind fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The data array size, N, must be greater than
                zero.</para>
              </listitem>

              <listitem>
                <para>The memory hint must be a valid member of the
                vsip_memory_hint enumeration.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is acceptable to bind a block to a null pointer for
            initialization purposes. However, it must be bound to a non-null
            pointer before it can be admitted.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>To create a block and bind a user data array (memory) large
            enough to hold an M by N matrix of type
            <type>double</type>:</para>

            <programlisting>#include &lt;vsip.h&gt;
…
vsip_scalar_d A[M * N];
vsip_block_d *Ablock = vsip_blockbind_d(A, M * N, VSIP_MEM_NONE);
if (NULL == Ablock) error("Bind of A to Ablock failed");</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockfind"><function>vsip_blockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrebind"><function>vsip_blockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrelease"><function>vsip_blockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockdestroy"><function>vsip_blockdestroy_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="cblockbind"><function>vsip_cblockbind_<replaceable>p</replaceable></function></link>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cblockbind">
      <title>vsip_cblockbind_<replaceable>p</replaceable></title>

      <para>Create and bind a VSIPL complex block to user allocated (user data
      array) memory.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a complex VSIPL block object,
            vsip_cblock_<replaceable>p</replaceable>, and binds the complex
            block object to either a single user-defined user data array, or
            to two user-defined data arrays. In the case of a single data
            array, the array must contain 2N
            vsip_scalar_<replaceable>p</replaceable> elements. For two data
            arrays, each array should contain N
            vsip_scalar_<replaceable>p</replaceable> elements. The block is
            created in the released state and must be admitted to VSIPL before
            calling VSIPL functions that operate on the data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_cblock_<replaceable>f</replaceable> *vsip_cblockbind_<replaceable>f</replaceable>(vsip_scalar_<replaceable>f</replaceable> *data1, 
                                 vsip_scalar_<replaceable>f</replaceable> *data2, 
                                 vsip_length N, vsip_memory_hint hint);
vsip_cblock_<replaceable>i</replaceable> *vsip_cblockbind_<replaceable>i</replaceable>(vsip_scalar_<replaceable>i</replaceable> *data1, 
                                 vsip_scalar_<replaceable>i</replaceable> *data2, 
                                 vsip_length N, vsip_memory_hint hint);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>data1</term>

                <listitem>
                  <para>If data2 is null, then data1 is a pointer to a data
                  array of contiguous memory containing at least 2N
                  vsip_scalar_<replaceable>p</replaceable> elements. The even
                  elements of the data array contain the real part values, and
                  the odd elements contain the imaginary part values. The data
                  are stored in interleaved complex form. Note that the first
                  element is considered to be even because index values start
                  at zero.</para>

                  <para>If data2 is not null, then data1 is a pointer to a
                  data array of contiguous memory containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements. The data
                  array contains the real part values. The data are stored in
                  split complex form.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data2</term>

                <listitem>
                  <para>If data2 is null, then the data are stored in
                  interleaved complex form.</para>

                  <para>If data2 is not null, then it is a pointer to a data
                  array of contiguous memory containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements. The data
                  array contains the imaginary part values. The data are
                  stored in split complex form.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of complex elements, of a user data array, to
                  which a user block of type
                  vsip_cblock_<replaceable>p</replaceable> is bound.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>hint</term>

                <listitem>
                  <para>Memory hint</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer of type
            vsip_cblock_<replaceable>p</replaceable>, or returns null if the
            block bind fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The data array size, N, must be greater than
                zero.</para>
              </listitem>

              <listitem>
                <para>The memory hint must be a valid member of the
                vsip_memory_hint enumeration.</para>
              </listitem>

              <listitem>
                <para>The data1 pointer must be valid – non-null if the data2
                pointer is non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is acceptable to bind a block to a null pointer for
            initialization purposes. However, it must be bound to a non-null
            pointer before it can be admitted.</para>

            <para>Complex data in the released state is treated as either
            interleaved or split as described above. A single user data array
            is used for storing complex data in the interleaved form. Two
            (identically sized) user data arrays, one for the real part and
            one for imaginary part, are used for storing complex data in the
            split form. The function vsip_cstorage will return an indicator of
            the desired storage format of the particular implementation.
            However, either storage format will work once admitted to
            VSIPL.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>To create a block and bind user data array (memory) large
            enough to hold an M by N split complex matrix of type
            double:</para>

            <programlisting>#include &lt;vsip.h&gt;
…
vsip_scalar_d Ai[M*N], Aq[M*N];
vsip_cblock_d *Ablock = vsip_cblockbind_d(Ai, Aq, M*N, VSIP_MEM_NONE);
if (NULL == Ablock) error("Bind of A to Ablock failed");</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="cblockfind">vsip_cblockfind_<replaceable>p</replaceable></link>,
            <link
            linkend="cblockrebind">vsip_cblockrebind_<replaceable>p</replaceable></link>,
            <link
            linkend="dblockadmit">vsip_cblockadmit_<replaceable>p</replaceable></link>,
            <link
            linkend="cblockrelease">vsip_cblockrelease_<replaceable>p</replaceable></link>,
            <link
            linkend="dblockdestroy">vsip_cblockdestroy_<replaceable>p</replaceable></link>,
            <link
            linkend="blockbind">vsip_blockbind_<replaceable>p</replaceable></link>,
            and <link
            linkend="cstorage">vsip_cstorage_<replaceable>p</replaceable></link>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dblockcreate">
      <title>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></title>

      <para>Creates a VSIPL block and binds a (VSIPL allocated) data array
      (memory) to it.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates an admitted VSIPL block object
            (vsip_<replaceable>d</replaceable>block_<replaceable>p</replaceable>)
            and allocates data array memory (VSIPL data) for N elements. The
            size of the data array is at least
            N*sizeof(vsip_scalar_<replaceable>p</replaceable>) bytes for real
            data, or 2*N*sizeof(vsip_scalar_<replaceable>p</replaceable>)
            bytes for complex data. The function binds the block object to the
            allocated data memory and returns a pointer to the block object.
            Data arrays created using
            vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable>
            can only be accessed using VSIPL functions. Information that would
            allow direct manipulation, such as a pointer to the data array, is
            not available.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_<replaceable>f</replaceable> *vsip_blockcreate_<replaceable>f</replaceable>(vsip_length N, vsip_memory_hint hint);
vsip_block_<replaceable>i</replaceable> *vsip_blockcreate_<replaceable>i</replaceable>(vsip_length N, vsip_memory_hint hint);
vsip_cblock_<replaceable>f</replaceable> *vsip_cblockcreate_<replaceable>f</replaceable>(vsip_length N, vsip_memory_hint hint);
vsip_cblock_<replaceable>i</replaceable> *vsip_cblockcreate_<replaceable>i</replaceable>(vsip_length N, vsip_memory_hint hint);
vsip_block_bl *vsip_blockcreate_bl(vsip_length N, vsip_memory_hint hint);
vsip_block_vi *vsip_blockcreate_vi(vsip_length N, vsip_memory_hint hint);
vsip_block_mi *vsip_blockcreate_mi(vsip_length N, vsip_memory_hint hint);
vsip_block_ti *vsip_blockcreate_ti(vsip_length N, vsip_memory_hint hint);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of elements to allocate for the data
                  array.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>hint</term>

                <listitem>
                  <para>Memory hint</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer of type
            vsip_<replaceable>d</replaceable>block_<replaceable>p</replaceable>,
            or null if the block create fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The data array size, N, must be greater than
                zero.</para>
              </listitem>

              <listitem>
                <para>The memory hint must be a valid member of the
                vsip_memory_hint enumeration.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>VSIPL data space allocated using the block create function
            is vendor dependent. The data are admitted and the pointer to the
            data space is hidden. The layout of the data in memory is vendor
            dependent. The data are accessed as if they were logically
            contiguous with an offset, stride(s), and length(s) into the data
            space. Offset, strides and lengths are in units of the data
            type.</para>

            <para>Note to Implementors: memory allocation shall not be
            deferred.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>To create a block large enough to hold an M by N matrix of
            type double:</para>

            <programlisting>vsip_block_d *Ablock = vsip_blockcreate_d(M*N, VSIP_MEM_NONE);
if (NULL == Ablock) error("Create of Ablock failed");</programlisting>

            <para>To create a block large enough to hold a complex vector of
            type complex double and length N:</para>

            <programlisting>vsip_cblock_d *Ablock = vsip_cblockcreate_d(N, VSIP_MEM_NONE);
if (NULL == Ablock) error("Create of Ablock failed");</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="blockbind">vsip_blockbind_<replaceable>p</replaceable></link>,
            <link
            linkend="dblockadmit">vsip_blockadmit_<replaceable>p</replaceable></link>,
            <link
            linkend="blockrelease">vsip_blockrelease_<replaceable>p</replaceable></link>,
            <link
            linkend="blockfind">vsip_blockfind_<replaceable>p</replaceable></link>,
            and <link
            linkend="dblockdestroy">vsip_blockdestroy_<replaceable>p</replaceable></link>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dblockdestroy">
      <title>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a VSIPL block object and any data array(s)
      allocated for it by VSIPL.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroys (frees) a VSIPL block object,
            vsip_block_<replaceable>p</replaceable>, and any VSIPL data
            array.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_blockdestroy_<replaceable>f</replaceable>(vsip_block_<replaceable>f</replaceable> *block);
void vsip_blockdestroy_<replaceable>i</replaceable>(vsip_block_<replaceable>i</replaceable> *block);
void vsip_cblockdestroy_<replaceable>f</replaceable>(vsip_cblock_<replaceable>f</replaceable> *block);
void vsip_cblockdestroy_<replaceable>i</replaceable>(vsip_cblock_<replaceable>i</replaceable> *block);
void vsip_blockdestroy_bl(vsip_block_bl *block);
void vsip_blockdestroy_vi(vsip_block_vi *block);
void vsip_blockdestroy_mi(vsip_block_mi *block);
void vsip_blockdestroy_ti(vsip_block_ti *block);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to a block object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid. It is not a mistake to
                destroy a null pointer.</para>
              </listitem>

              <listitem>
                <para>The block object must not be derived from a complex
                block object.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If necessary, the programmer can determine the pointer(s) to
            the user bound array(s) with a call to
            vsip_<replaceable>d</replaceable>blockfind_f before the (released)
            block is destroyed.</para>

            <para>Destroying an admitted block bound to a user data array(s)
            may not update the data in the user array(s).</para>

            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Destroy a VSIPL block object.</para>

            <programlisting>{
  vsip_block_bl* xblock = vsip_blockcreate_bl(1000, VSIP_MEM_NONE);
  …
  vsip_blockdestroy_bl(xblock);
}</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="blockbind">vsip_blockbind_<replaceable>p</replaceable></link>,
            <link
            linkend="cblockbind">vsip_cblockbind_<replaceable>p</replaceable></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="blockfind">
      <title>vsip_blockfind_<replaceable>p</replaceable></title>

      <para>Find the pointer to the data bound to a VSIPL released block
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the address of the user data array bound to a VSIPL
            released block. If the block is not released a null pointer is
            returned. Note that if the block was bound to NULL and is in the
            released state then a null pointer will be returned.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_<replaceable>f</replaceable> *vsip_blockfind_<replaceable>f</replaceable>(const vsip_block_<replaceable>f</replaceable> *block);
vsip_scalar_<replaceable>i</replaceable> *vsip_blockfind_<replaceable>i</replaceable>(const vsip_block_<replaceable>i</replaceable> *block);
vsip_scalar_bl *vsip_blockfind_bl(const vsip_block_bl *block);
vsip_scalar_vi *vsip_blockfind_vi(const vsip_block_vi *block);
vsip_scalar_vi *vsip_blockfind_mi(const vsip_block_mi *block);
vsip_scalar_vi *vsip_blockfind_ti(const vsip_block_ti *block);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to a block object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer of type
            vsip_scalar_<replaceable>p</replaceable> to the released block’s
            data array, or null if the block object is not in the released
            state. Note that if the block is released and bound to a NULL,
            then a null pointer is also returned.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Although the data in a derived block is released when the
            parent block is released the derived block is never in a released
            state so blockfind will fail and return null. To find the data for
            a derived block the parent block must be queried.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="blockbind">vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></link>,
            and <link
            linkend="dblockdestroy">vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></link>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cblockfind">
      <title>vsip_cblockfind_<replaceable>p</replaceable></title>

      <para>Returns the pointers to the user data array(s) bound to a VSIPL
      released complex block object, vsip_cblock_<replaceable>p</replaceable>,
      or nulls if the complex block object data are in the admitted
      state.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns pointers to the user data arrays bound to a VSIPL
            released complex block object,
            vsip_cblock_<replaceable>p</replaceable>, or null if the block
            object data are in the admitted state.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cblockfind_<replaceable>f</replaceable>(const vsip_cblock_<replaceable>f</replaceable> *block, 
                       vsip_scalar_<replaceable>f</replaceable> **data1, vsip_scalar_<replaceable>f</replaceable> **data2);
void vsip_cblockfind_<replaceable>i</replaceable>(const vsip_cblock_<replaceable>i</replaceable> *block, 
                       vsip_scalar_<replaceable>i</replaceable> **data1, vsip_scalar_<replaceable>i</replaceable> **data2);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to a block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data1</term>

                <listitem>
                  <para>Output - Pointer to a pointer to the data array, or
                  data array for the real values. Returns null if the complex
                  block is in the admitted state.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data2</term>

                <listitem>
                  <para>Output - Pointer to a null pointer, or to the previous
                  data array for the imaginary values. Returns null if the
                  complex block is in the admitted state or if the previous
                  binding was to data in complex interleaved form.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointers to the user data arrays must be valid –
                non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="blockbind">vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></link>,
            and <link
            linkend="dblockdestroy">vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="blockrebind">
      <title>vsip_blockrebind_<replaceable>p</replaceable></title>

      <para>Rebind a VSIPL block to user-specified data.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Rebinds an existing VSIPL released real block object,
            vsip_block_<replaceable>p</replaceable>, to a new (previously
            allocated) user data array. It must contain at least N,
            vsip_scalar_<replaceable>p</replaceable>, elements where N is the
            number of elements in the existing block object. An attempt to
            rebind either a derived block object, or a block object that is in
            an admitted state, will fail. In either case a null will be
            returned. Otherwise, it returns a pointer to the old user data
            array.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_<replaceable>f</replaceable> *vsip_blockrebind_<replaceable>f</replaceable>(vsip_block_<replaceable>f</replaceable> *block, vsip_scalar_<replaceable>f</replaceable> *data);
vsip_scalar_<replaceable>i</replaceable> *vsip_blockrebind_<replaceable>i</replaceable>(vsip_block_<replaceable>i</replaceable> *block, vsip_scalar_<replaceable>i</replaceable> *data);
vsip_scalar_bl *vsip_blockrebind_bl(vsip_block_bl *block, vsip_scalar_bl *data);
vsip_scalar_vi *vsip_blockrebind_vi(vsip_block_vi *block, vsip_scalar_vi *data);
vsip_scalar_vi *vsip_blockrebind_mi(vsip_block_mi *block, vsip_scalar_vi *data);
vsip_scalar_vi *vsip_blockrebind_ti(vsip_block_ti *block, vsip_scalar_vi *data);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to a block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data</term>

                <listitem>
                  <para>Pointer to a user data array of contiguous memory
                  containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements to be
                  bound to the block.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the previous data array bound to the
            block, or null if the block is in an admitted state.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Rebind does not allow you to change the number of elements
            in a block.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The user data array pointer must be valid –
                non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Rebind does not allow you to change the number of elements
            in a block. However, there is no method to determine that the data
            pointer being bound is a valid pointer to an array of the proper
            size.</para>

            <para>A derived block is not releasable and so may not be rebound.
            When the parent block is released and rebound to user data the
            corresponding data in the derived block is changed.</para>

            <para>The block must be admitted to VSIPL before calling VSIPL
            functions that operate on the data. The intent of rebind is to
            support efficient dynamic binding of buffers for I/O.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Ping-Pong I/O buffering.</para>

            <programlisting>#include &lt;vsip.h&gt;

#define BUFSIZE 1000

extern const volatile vsip_scalar_f *buf_ping, *buf_pong;
int pingpong = 0;
vsip_block_f* buf_blk = vsip_blockbind_f(buf_ping, BUFSIZE, VSIP_MEM_NONE);
vsip_vview_f* buf = vsip_vbind_f(buf_blk,0,1,N);

while{1)
{
  /* Wait until data ready in buf_ping (buf_pong) */
  wait_until_data_ready();
  pingpong = !pingpong;

  /* Release buf_pong (buf_ping) */
  vsip_blockrelease_f(buf_blk,VSIP_FALSE);
  /* Start DMA of next data frame into buf_pong (buf_ping) */
  /* Rebind and admit buf_ping (buf_pong) */
  dma_write((vsip_blockrebind_f(buf_blk, (pingpong ? buf_ping : buf_pong)));
  vsip_blockadmit_f(buf_blk, VSIP_TRUE);
  /* Do some processing using buf_ping */
  do_some_processing_with_buf();
}</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="blockbind">vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></link>,
            <link
            linkend="blockfind">vsip_<replaceable>d</replaceable>blockfind_<replaceable>p</replaceable></link>,
            and <link
            linkend="dblockdestroy">vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cblockrebind">
      <title>vsip_cblockrebind_<replaceable>p</replaceable></title>

      <para>Rebind a VSIPL complex block to user-specified data.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Rebinds an existing VSIPL released complex block object,
            vsip_cblock_<replaceable>p</replaceable>, to either a single new
            (previously allocated) user-defined user data array, or to two new
            (previously allocated) user-defined data arrays. In the case of a
            single data array, the array must contain 2N
            vsip_scalar_<replaceable>p</replaceable> elements. For two data
            arrays, each array should contain N
            vsip_scalar_<replaceable>p</replaceable> elements. An attempt to
            rebind a block object that is in an admitted state will fail, and
            null will be returned. Otherwise, it returns a pointer to the old
            user data array.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cblockrebind_<replaceable>f</replaceable>(vsip_cblock_<replaceable>f</replaceable> *block,
                         vsip_scalar_<replaceable>f</replaceable> *data1, vsip_scalar_<replaceable>f</replaceable> *data2, 
                         vsip_scalar_<replaceable>f</replaceable> **prevdata1, vsip_scalar_<replaceable>f</replaceable> **prevdata2);
void vsip_cblockrebind_<replaceable>i</replaceable>(vsip_cblock_<replaceable>i</replaceable> *block,
                         vsip_scalar_<replaceable>i</replaceable> *data1, vsip_scalar_<replaceable><replaceable>i</replaceable></replaceable> *data2,
                         vsip_scalar_<replaceable><replaceable>i</replaceable></replaceable> **prevdata1, vsip_scalar_<replaceable>i</replaceable> **prevdata2);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to complex block object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data1</term>

                <listitem>
                  <para>If data2 is null, then data1 is a pointer to a user
                  data array of contiguous memory containing at least 2N
                  vsip_scalar_<replaceable>p</replaceable> elements. The even
                  elements of the data array contain the real values, and the
                  odd elements contain the imaginary values. The data are
                  stored in interleaved complex form. Note that the first
                  element is considered to be even because index values start
                  at zero.</para>

                  <para>If data2 is not null, then data1 is a pointer to a
                  user data array of contiguous memory containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements, whose
                  elements contain the real values. The data are stored in
                  split complex form.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data2</term>

                <listitem>
                  <para>If data2 is null, then the data are stored in
                  interleaved complex form.</para>

                  <para>If data2 is not null, then it is a pointer to a user
                  data array of contiguous memory containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements, whose
                  elements contain the imaginary values. The data are stored
                  in split complex form.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>prevdata1</term>

                <listitem>
                  <para>Output - Pointer to a pointer to the previous user
                  data array, or user data array for the real values. Returns
                  null if the complex block is in the admitted state.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>prevdata2</term>

                <listitem>
                  <para>Output - Pointer to a null pointer, or to the previous
                  user data array for the imaginary values. Returns null if
                  the complex block is in the admitted state or if the
                  previous binding was to data in complex interleaved
                  form.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Complex rebind does not allow you to change the number of
            elements in a block.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointers to the user data arrays must be valid –
                non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Complex rebind does not allow you to change the number of
            elements in a block. However, there is no method to determine that
            the data pointer being bound is a valid pointer to an array of the
            proper size.</para>

            <para>The block must be admitted to VSIPL before calling VSIPL
            functions that operate on the data. The intent of rebind is to
            support efficient dynamic binding of buffers for I/O.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="blockbind">vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></link>,
            <link
            linkend="blockfind">vsip_<replaceable>d</replaceable>blockfind_<replaceable>p</replaceable></link>,
            and <link
            linkend="dblockdestroy">vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="blockrelease">
      <title>vsip_blockrelease_<replaceable>p</replaceable></title>

      <para>Release a VSIPL block for direct user access.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Releases a VSIPL block object,
            vsip_block_<replaceable>p</replaceable>, to allow direct user
            access of the data array. Block objects created by
            vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable>
            and derived blocks cannot be released. An attempt to do so will
            return a null. A true update flag indicates that the data in the
            user-specified data array shall be updated to match the data
            associated with the block. If the update flag is false, the state
            of the user data is implementation dependent, and the user data
            array should be assumed to contain undefined data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_<replaceable>f</replaceable> *vsip_blockrelease_<replaceable>f</replaceable>(vsip_block_<replaceable>f</replaceable> *block, vsip_scalar_bl update);
vsip_scalar_<replaceable>i</replaceable> *vsip_blockrelease_<replaceable>i</replaceable>(vsip_block_<replaceable>i</replaceable> *block, vsip_scalar_bl update);
vsip_scalar_bl *vsip_blockrelease_bl(vsip_block_bl *block, vsip_block_bl update);
vsip_scalar_vi *vsip_blockrelease_vi(vsip_block_vi *block, vsip_scalar_bl update);
vsip_scalar_vi *vsip_blockrelease_mi(vsip_block_mi *block, vsip_scalar_bl update);
vsip_scalar_vi *vsip_blockrelease_ti(vsip_block_ti *block, vsip_scalar_bl update);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to block object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>update</term>

                <listitem>
                  <para>Boolean flag where true indicates that the block
                  object’s data must be maintained during the state
                  change.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns null if the block release fails, otherwise it
            returns the pointer to the data array.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is not an error to release a block that is already in the
            released state.</para>

            <para>Release causes any deferred execution associated with the
            block object, and any changes to the data array, to be completed
            before the function returns.</para>

            <para>The intent of using a false update flag is that if the data
            in the block object is no longer needed, then there is no need to
            force consistency between the block object’s data and the
            user-specified data array with a potential copy operation.</para>

            <para>If the block is a derived block, derived from a complex
            block, only the complex block object can be released and
            admitted.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Add two vectors together.</para>

            <programlisting>#include &lt;vsip.h&gt;
…
int i;
vsip_scalar_d a[N], c[N];
vsip_block_d
*ablk = vsip_blockbind_d (a, N, VSIP_MEM_NONE),
*cblk = vsip_blockbind_d (c, N, VSIP_MEM_NONE);
vsip_vview_d
*va = vsip_vbind_d(ablk, 0, 1, N),
*vb = vsip_vcreate_d(N, VSIP_MEM_NONE),
*vc = vsip_vbind_d(cblk, 0, 1, N);
for (i=0; i&lt;N; i++) a[i] = cosh(2*M_PI*i/N);
vsip_vramp_d(0.0, 1.0/N, vb);
vsip_blockadmit_d(ablk,VSIP_TRUE);
vsip_vadd_d(va,vb,vc);
vsip_blockrelease_d(cblk,VSIP_TRUE);
for (i=0; i&lt;N; i++) printf("c[%i] = %d\n",i,c[i]);</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate">vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></link>,
            <link
            linkend="dblockadmit">vsip_blockadmit_<replaceable>p</replaceable></link>,
            <link
            linkend="blockrelease">vsip_blockrelease_<replaceable>p</replaceable></link>,<link
            linkend="blockfind">
            vsip_blockfind_<replaceable>p</replaceable></link>, and <link
            linkend="dblockdestroy">vsip_blockdestroy_<replaceable>p</replaceable></link>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cblockrelease">
      <title>vsip_cblockrelease_<replaceable>p</replaceable></title>

      <para>Release a complex block from VSIPL for direct user access.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Releases a VSIPL complex block object,
            vsip_cblock_<replaceable>p</replaceable>, for direct user access
            to the data array(s). Block objects created by
            vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable>
            cannot be released. An attempt to do so will return nulls in both
            pointer values. A true update flag indicates that the data in the
            userspecified data array shall be updated to match the data
            associated with the block. If the update flag is false, the state
            of the user data is implementation dependent, and the user data
            array should be assumed to contain undefined data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cblockrelease_<replaceable>f</replaceable>(vsip_cblock_<replaceable>f</replaceable> *block, vsip_scalar_bl update,
                          vsip_scalar_<replaceable>f</replaceable> **data1, vsip_scalar_<replaceable>f</replaceable> **data2);
void vsip_cblockrelease_<replaceable>i</replaceable>(vsip_cblock_<replaceable>i</replaceable> *block, vsip_scalar_bl update,
                          vsip_scalar_<replaceable>i</replaceable> **data1, vsip_scalar_<replaceable>i</replaceable> **data2);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to block object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>update</term>

                <listitem>
                  <para>Boolean flag where true indicates that the block
                  object’s data must be maintained during the state
                  change.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data1</term>

                <listitem>
                  <para>Pointer to output data array - If the pointer returned
                  in data2 is null, then the pointer returned in data1 is a
                  pointer to a user data array of contiguous memory containing
                  at least 2N vsip_scalar_<replaceable>p</replaceable>
                  elements. The even elements of the data array contain the
                  real part values and the odd elements contain the imaginary
                  part values. The data are stored in interleaved complex
                  form. Note that the first element is considered to be even
                  because index values start at zero. If the pointer returned
                  in data2 is not null, then the pointer returned in data1 is
                  a pointer to a user data array of contiguous memory
                  containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements, whose
                  elements contain the real part values. The data are stored
                  in split complex form.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>data2</term>

                <listitem>
                  <para>Pointer to output data array - If the pointer returned
                  in data2 is null, then the data are stored in interleaved
                  complex form. If the pointer returned in data2 is not null,
                  then it is a pointer to a user data array of contiguous
                  memory containing at least N
                  vsip_scalar_<replaceable>p</replaceable> elements, whose
                  elements contain the imaginary part values. The data are
                  stored in split complex form.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointers to the user data arrays must be valid –
                non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is not an error to release a block that is already in the
            released state.</para>

            <para>Release causes any deferred execution associated with the
            complex block object, and any changes to the data, to be completed
            before the function returns.</para>

            <para>The intent of using a false update flag is that if the data
            in the block object is no longer needed, then there is no need to
            force consistency between the block object’s data and the
            user-specified data array with a potential copy operation.</para>

            <para>This function returns either a single pointer to the user
            data array, as the third argument (for interleaved complex data),
            or two pointers to the user data arrays as the third and fourth
            arguments (for split complex data). In the case of interleaved
            complex data, the fourth argument will be returned as null. If the
            block is not releasable, both pointers will be returned as
            null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>The first example below illustrates a split
            cblockrelease:</para>

            <programlisting>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vsip.h&gt;

#define N 829

int main ( )
{
  int i;
  vsip_cscalar_f X, Y;
  vsip_scalar_f dat1[N], dat2[N]; /* input data arrays */
  vsip_scalar_f *addr1, *addr2; /* returned data pointers */
  /* Input complex scalar */
  X.r = 2.0;
  X.i = 0.0;
  /* Input data sets */
  for (i = 0; i &lt; N; i++)
  {
    dat1[i] = (vsip_scalar_f)( i);
    dat2[i] = (vsip_scalar_f)(-i);
  }
  /* Initialize VSIPL */
  vsip_init((void *)0);
  {
    /* Bind data to a complex block */
    vsip_cblock_f *cblock = vsip_cblockbind_f(dat1, dat2, N, VSIP_MEM_NONE);
    vsip_cvview_f *cdat = vsip_cvbind_f(cblock, 0, 1, N);
    /* Admit the block into VSIPL */
    vsip_cblockadmit_f(cblock, VSIP_TRUE);
    /* Multiply in-place the complex data type (dat1,dat2) by X */
    vsip_csvmul_f(X, cdat, cdat);
    /* Release the block back to the user */
    vsip_cblockrelease_f(cblock, VSIP_TRUE, &amp;addr1, &amp;addr2);
    /* Destroy the block and its views and data */
    vsip_cvdestroy_f(cdat);
    vsip_cblockdestroy_f(cblock);
  }
  /* Finalize VSIPL */
  vsip_finalize((void *)0);
  /* Print results using original pointers */
  for (i = 0; i &lt; N; i++)
    printf("result %d : %.1f %.1f\n", i, dat1[i], dat2[i]);
  printf("\n\n");
  /* Print results using returned pointers */
  for (i = 0; i &lt; N; i++)
    printf( "result(again) %d : %.1f %.1f\n", i, *(addr1 + i), *(addr2 + i) );
  printf("\n\n");
  return 0;
}</programlisting>

            <para>The second example below illustrates an interleaved
            cblockrelease:</para>

            <programlisting>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vsip.h&gt;
#define N 829
int main ( )
{
  int i;
  vsip_cscalar_f X, Y;
  vsip_scalar_f dat1[2*N];
  vsip_scalar_f *addr1, *addr2;
  /* Initialize VSIPL */
  vsip_init( (void *)0 );
  /* Input complex scalar */
  X.r = 2.0;
  X.i = 0.0;
  /* Input data sets */
  for (i = 0; i &lt; 2*N; i += 2)
  {
    dat1[i] = (vsip_scalar_f)( i);
    dat1[i+1] = (vsip_scalar_f)(-i);
  }
  {
    /* Bind data to a complex block */
    vsip_cblock_f *cblock = vsip_cblockbind_f(
    dat1, NULL, N, VSIP_MEM_NONE);
    vsip_cvview_f *cdat = vsip_cvbind_f(cblock, 0, 1, N);
    /* Admit the block into VSIPL */
    vsip_cblockadmit_f(cblock, VSIP_TRUE);
    /* Multiply in-place the complex data by X */
    vsip_csvmul_f(X, cdat, cdat);
    /* Release the block back to the user */
    vsip_cblockrelease_f(cblock, VSIP_TRUE, &amp;addr1, &amp;addr2);
    /* Destroy the block and its views and data */
    vsip_cvdestroy_f(cdat);
    vsip_cblockdestroy_f(cblock);
  }
  /* Finalize VSIPL */
  vsip_finalize( (void *)0 );
  /* Print results using the original pointer */
  for (i = 0; i &lt; 2*N; i += 2)
    printf("result %d : %.1f %.1f\n", i, dat1[i], dat1[i+1]);
  printf("\n\n");
  /* Note that a pointer to NULL is returned in addr2.
   * Only addr1 is useful. Then print results using
   * the returned pointer.*/
  for (i = 0; i &lt; 2*N; i += 2)
    printf("result(again) %d : %.1f %.1f\n",
           i, *(addr1 + i), *(addr1 + i + 1) );
  printf("\n\n");
  return 0;
}</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrelease"><function>vsip_blockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockfind"><function>vsip_cblockfind_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="complete">
      <title>vsip_complete</title>

      <para>Force all deferred VSIPL execution to complete.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Forces all deferred VSIPL execution (limited to this thread
            on this processor) to complete and then returns.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_complete();</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The primary purpose of vsip_complete is for debugging.
            Applications may be coordinating with other libraries that share
            implementation knowledge with VSIPL. User application code cannot
            directly observe the effects of deferred execution without using
            VSIPL private information.</para>

            <para>Deferred execution is an implementation issue, and is an
            optional method to potentially improve performance.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cstorage">
      <title>vsip_cstorage_<replaceable>p</replaceable></title>

      <para>Returns the preferred complex storage format, interleaved, split,
      or none for a precision type for this implementation.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the preferred complex storage format. The preferred
            storage type can be dependent on the precision if required for
            best performance. For instance float precision may have a
            preferred user data type of split, and double precision may have a
            preferred user data type of interleaved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_cmplx_mem vsip_cstorage_<replaceable>p</replaceable>();</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Enumerated type corresponding to preferred storage
            format.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is also possible to determine the preferred storage
            format at compile time. The include file
            <filename>vsip.h</filename> defines the value of VSIP_CMPLX_MEM_P
            to be one of: <code>{VSIP_CMPLX_INTERLEAVED_P | VSIP_CMPLX_SPLIT_P
            | VSIP_CMPLX_NONE_P}</code>. For example,</para>

            <programlisting>#define VSIP_CMPLX_MEM_F (VSIP_CMPLX_SPLIT_F) 
#define VSIP_CMPLX_MEM_D (VSIP_CMPLX_INTERLEAVED_D) </programlisting>

            <para>We note that the _P character in the macro is replaced with
            the appropriate capital for the supported types. We note this
            function replaces the vsip_cstorage function which has been
            deprecated and moved to the end of the document. The original is
            retained in the specification to support code portability. This
            function allows for precision dependent preferred storage. For
            instance internal storage for float might be split and for integer
            might be interleaved or different precisions of float or integer
            may have different internal storage requirements.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>The function <function>vsip_cstorage</function> is
            deprecated. See section Notes to Implementors for this
            function.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Vector View Object Functions</title>

    <para>A VSIPL block holds the data in a data array. A block can be viewed
    as a vector or matrix. Two or more vector and/or matrix objects may
    reference the same block. There is no apparent difference to the
    application programmer for operation by VSIPL library functions on blocks
    bound only to VSIPL data arrays or (admitted) blocks associated with user
    data arrays.</para>

    <para>A vector view object has the attributes of offset, stride, and
    length (number) of elements.</para>

    <para>Vector views can be treated as row vectors or column vectors. When
    used in conjunction with matrix view objects they are normally treated as
    row vectors.</para>

    <para>Vector view object functions are provided to:</para>

    <itemizedlist>
      <listitem>
        <para>Create (constructors) vector view objects,</para>
      </listitem>

      <listitem>
        <para>Destroy (destructors) vector view objects,</para>
      </listitem>

      <listitem>
        <para>Modify/manipulate vector view objects, and</para>
      </listitem>

      <listitem>
        <para>Access functions for vector view objects.</para>
      </listitem>
    </itemizedlist>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>vsip_<replaceable>d</replaceable>valldestroy_<replaceable>p</replaceable></entry>

            <entry>Destroy Vector and Block</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></entry>

            <entry>Create and Bind a Vector View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable></entry>

            <entry>Create Vector View Clone</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></entry>

            <entry>Create Vector</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vdestroy_<replaceable>p</replaceable></entry>

            <entry>Destroy Vector View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vget_<replaceable>p</replaceable></entry>

            <entry>Vector Get Element</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vgetattrib_<replaceable>p</replaceable></entry>

            <entry>Vector Get View Attributes</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vgetblock_<replaceable>p</replaceable></entry>

            <entry>Vector Get Block</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vgetlength_<replaceable>p</replaceable></entry>

            <entry>Vector Get Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vgetoffset_<replaceable>p</replaceable></entry>

            <entry>Vector Get Offset</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vgetstride_<replaceable>p</replaceable></entry>

            <entry>Vector Get Stride</entry>
          </row>

          <row>
            <entry>vsip_vimagview_<replaceable>p</replaceable></entry>

            <entry>Create Imaginary Vector View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vput_<replaceable>p</replaceable></entry>

            <entry>Vector Put Element</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vputattrib_<replaceable>p</replaceable></entry>

            <entry>Put Vector View Attributes</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vputlength_<replaceable>p</replaceable></entry>

            <entry>Vector Put Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vputoffset_<replaceable>p</replaceable></entry>

            <entry>Vector Put Offset</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vputstride_<replaceable>p</replaceable></entry>

            <entry>Vector Put Stride</entry>
          </row>

          <row>
            <entry>vsip_vrealview_<replaceable>p</replaceable></entry>

            <entry>Create Real Vector View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>vsubview_<replaceable>p</replaceable></entry>

            <entry>Create Subview Vector View</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dvalldestroy">
      <title>vsip_<replaceable>d</replaceable>valldestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a vector, its associated block, and any VSIPL data
      array bound to the block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroys (frees) a vector view object, the block object to
            which it is bound, and any VSIPL data array. If v is a vector of
            type
            vsip_<replaceable>d</replaceable>vview_<replaceable>p</replaceable>
            then
            <code>vsip_<replaceable>d</replaceable>valldestroy_<replaceable>p</replaceable>(v);</code>
            is equivalent to
            <code>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable>(vsip_<replaceable>d</replaceable>vdestroy_<replaceable>p</replaceable>(v);</code></para>

            <para>This is the complementary function to
            vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable>
            and should only be used to destroy vectors that have only one view
            bound to the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_valldestroy_f(vsip_vview_f *v);
void vsip_valldestroy_i(vsip_vview_i *v);
void vsip_cvalldestroy_f(vsip_cvview_f *v);
void vsip_cvalldestroy_i(vsip_cvview_i *v);
void vsip_valldestroy_bl(vsip_vview_bl *v);
void vsip_valldestroy_vi(vsip_vview_vi *v);
void vsip_valldestroy_mi(vsip_vview_mi *v);
void vsip_valldestroy_ti(vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid. An argument of
                null is not an error.</para>
              </listitem>

              <listitem>
                <para>The specified vector view must be the only view bound to
                the block.</para>
              </listitem>

              <listitem>
                <para>The vector view must not be bound to a derived block
                (derived from a complex block).</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector view is bound to a derived block (derived from
            a complex block), the complex block must be destroyed to free the
            block and associated data.</para>

            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting>/* Create and destroy a simple vector of 100 elements. */
vsip_vview_f *v = vsip_vcreate_f((vsip_length)100, VSIP_MEM_NONE);
…
vsip_valldestroy_f(v);</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockbind"><function>vsip_cblockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrelease"><function>vsip_blockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrelease"><function>vsip_cblockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrebind"><function>vsip_blockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrebind"><function>vsip_cblockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockfind"><function>vsip_blockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockfind"><function>vsip_cblockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvbind"><function>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dvdestroy"><function>vsip_<replaceable>d</replaceable>vdestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvbind">
      <title>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></title>

      <para>Create a vector view object and bind it to a block object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a vector view object or returns null if it fails. If
            the view create is successful, it: (1) binds the vector view
            object to the block object, (2) sets the offset from the beginning
            of the data array to the beginning of the vector, the stride
            between scalar elements, and the length in elements (number of
            scalar elements), and (3) then returns a (pointer to the) vector
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vbind_f(const vsip_block_f *block, vsip_offset offset,
                           vsip_stride stride, vsip_length length);
vsip_vview_i *vsip_vbind_i(const vsip_block_i *block, vsip_offset offset,
                           vsip_stride stride, vsip_length length);
vsip_cvview_f *vsip_cvbind_f(const vsip_cblock_f *block, vsip_offset offset,
                             vsip_stride stride, vsip_length length);
vsip_cvview_i *vsip_cvbind_i(const vsip_cblock_i *block, vsip_offset offset,
                             vsip_stride stride, vsip_length length);
vsip_vview_bl *vsip_vbind_bl(const vsip_block_bl *block, vsip_offset offset,
                             vsip_stride stride, vsip_length length);
vsip_vview_vi *vsip_vbind_vi(const vsip_block_vi *block, vsip_offset offset,
                             vsip_stride stride, vsip_length length);
vsip_vview_mi *vsip_vbind_mi(const vsip_block_mi *block, vsip_offset offset,
                             vsip_stride stride, vsip_length length);
vsip_vview_ti *vsip_vbind_ti(const vsip_block_ti *block, vsip_offset offset,
                             vsip_stride stride, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>offset</term>

                <listitem>
                  <para>Vector view offset in elements relative to the base of
                  block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>stride</term>

                <listitem>
                  <para>Vector view stride between scalar elements.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Vector view length in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>The function returns a pointer to the created vector view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The offset must be less than the length of the block’s
                data array.</para>
              </listitem>

              <listitem>
                <para>The stride, length, and offset arguments must not
                specify a vector view that exceeds the bounds of the data
                array of the associated block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the function’s
            return value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, this function
            updates the number of bindings (reference count) recorded in the
            block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockbind"><function>vsip_cblockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrelease"><function>vsip_blockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrelease"><function>vsip_cblockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrebind"><function>vsip_blockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrebind"><function>vsip_cblockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockfind"><function>vsip_blockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockfind"><function>vsip_cblockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvdestroy"><function>vsip_<replaceable>d</replaceable>vdestroy_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dvalldestroy"><function>vsip_<replaceable>d</replaceable>valldestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvcloneview">
      <title>vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable></title>

      <para>Create a clone of a vector view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a new vector view object, copies all of the
            attributes of the source vector view object to the new vector view
            object, and then binds the new vector view object to the block
            object of the source vector view object. This function returns
            null on a memory allocation (creation) failure; otherwise, it
            returns a pointer to the new vector view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vcloneview_f(const vsip_vview_f *v);
vsip_vview_i *vsip_vcloneview_i(const vsip_vview_i *v);
vsip_cvview_f *vsip_cvcloneview_f(const vsip_cvview_f *v);
vsip_cvview_i *vsip_cvcloneview_i(const vsip_cvview_i *v);
vsip_vview_bl *vsip_vcloneview_bl(const vsip_vview_bl *v);
vsip_vview_vi *vsip_vcloneview_vi(const vsip_vview_vi *v);
vsip_vview_mi *vsip_vcloneview_mi(const vsip_vview_mi *v);
vsip_vview_ti *vsip_vcloneview_ti(const vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Source vector view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created vector view object clone,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for null in case of a memory allocation failure.</para>

            <para>Note to Implementors: In development mode,
            vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable>
            increments the number of bindings (reference count) recorded in
            the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dvbind"><function>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcloneview"><function>vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvsubview"><function>vsip_<replaceable>d</replaceable>vsubview_<replaceable>p</replaceable></function></link>
            <link
            linkend="vimagview"><function>vsip_vimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="vrealview"><function>vsip_vrealview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvcreate">
      <title>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></title>

      <para>Creates a block object and a vector view (object) of the
      block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a block object with an N element VSIPL data array,
            it creates a unit stride vector view object and then binds the
            block object to it.</para>

            <para>The function <code>vsip_vview_<replaceable>p</replaceable>
            *vsip_vcreate_<replaceable>p</replaceable>(N, hint);</code>
            returns the same result as
            <code>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable>(vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable>(N,
            hint), (vsip_offset)0, (vsip_stride)1, N);</code> except that
            <function>vsip_vcreate_<replaceable>p</replaceable></function>
            returns null if
            <code>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable>(N,
            hint)</code> returns null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vcreate_f(vsip_length N, vsip_memory_hint hint);
vsip_vview_i *vsip_vcreate_i(vsip_length N, vsip_memory_hint hint);
vsip_cvview_f *vsip_cvcreate_f(vsip_length N, vsip_memory_hint hint);
vsip_cvview_i *vsip_cvcreate_i(vsip_length N, vsip_memory_hint hint);
vsip_vview_bl *vsip_vcreate_bl(vsip_length length, vsip_memory_hint hint);
vsip_vview_vi *vsip_vcreate_vi(vsip_length N, vsip_memory_hint hint);
vsip_vview_mi *vsip_vcreate_mi(vsip_length N, vsip_memory_hint hint);
vsip_vview_ti *vsip_vcreate_ti(vsip_length N, vsip_memory_hint hint);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of elements of vector.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>hint</term>

                <listitem>
                  <para>Memory hint.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created vector view object, or null
            if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector length, N, must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The memory hint must be a valid member of the
                vsip_memory_hint enumeration.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Note to Implementors: In development mode,
            vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable>
            sets the initial number of bindings in the block object on which
            the returned vector is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting>/* Make a block of type double, and length 32, and attach to it 
   a vector view of type double, unit stride, and of length 32. */
vsip_vview_d *vector = vsip_vcreate_d((vsip_length) 32, VSIP_MEM_NONE);</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockbind"><function>vsip_cblockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrelease"><function>vsip_blockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrelease"><function>vsip_cblockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrebind"><function>vsip_blockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrebind"><function>vsip_cblockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockfind"><function>vsip_blockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockfind"><function>vsip_cblockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvbind"><function>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvdestroy"><function>vsip_<replaceable>d</replaceable>vdestroy_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dvalldestroy"><function>vsip_<replaceable>d</replaceable>valldestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvdestroy">
      <title>vsip_<replaceable>d</replaceable>vdestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a vector view object and return a pointer to the
      associated block object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Frees a vector view object from the block object that it was
            bound to, destroys the vector view object, and then returns a
            pointer to the block object. If the vector view argument is null,
            it returns null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_f *vsip_vdestroy_f(vsip_vview_f *v);
vsip_block_i *vsip_vdestroy_i(vsip_vview_i *v);
vsip_cblock_f *vsip_cvdestroy_f(vsip_cvview_f *v);
vsip_cblock_i *vsip_cvdestroy_i(vsip_cvview_i *v);
vsip_block_bl *vsip_vdestroy_bl(vsip_vview_bl *v);
vsip_block_vi *vsip_vdestroy_vi(vsip_vview_vi *v);
vsip_block_mi *vsip_vdestroy_mi(vsip_vview_mi *v);
vsip_block_ti *vsip_vdestroy_ti(vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the block object to which the vector
            view was bound, or null if the calling argument was null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid. It is not an error
                to destroy a null pointer.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>

            <para>Note to Implementors: In development mode, the function
            updates the bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockbind"><function>vsip_cblockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrelease"><function>vsip_blockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrelease"><function>vsip_cblockrelease_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockrebind"><function>vsip_blockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockrebind"><function>vsip_cblockrebind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockfind"><function>vsip_blockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="cblockfind"><function>vsip_cblockfind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvbind"><function>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dvalldestroy"><function>vsip_<replaceable>d</replaceable>valldestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvget">
      <title>vsip_<replaceable>d</replaceable>vget_<replaceable>p</replaceable></title>

      <para>Get the value of a specified element of a vector view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the value of the specified element of a vector view
            object, <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mi>j</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vget_f(const vsip_vview_f *x, vsip_index j);
vsip_scalar_i vsip_vget_i(const vsip_vview_i *x, vsip_index j);
vsip_cscalar_f vsip_cvget_f(const vsip_cvview_f *x, vsip_index j);
vsip_cscalar_i vsip_cvget_i(const vsip_cvview_i *x, vsip_index j);
vsip_scalar_bl vsip_vget_bl(const vsip_vview_bl *x, vsip_index j);
vsip_scalar_vi vsip_vget_vi(const vsip_vview_vi *x, vsip_index j);
vsip_scalar_mi vsip_vget_mi(const vsip_vview_mi *x, vsip_index j);
vsip_scalar_ti vsip_vget_ti(const vsip_vview_ti *x, vsip_index j);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Vector view object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Index of vector element.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the specified element of a vector view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must be a valid index of the vector
                view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>vsip_<replaceable>d</replaceable>sput_<replaceable>p</replaceable></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvgetattrib">
      <title>vsip_<replaceable>d</replaceable>vgetattrib_<replaceable>p</replaceable></title>

      <para>Get the attributes of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the attributes of a vector view object: (pointer to)
            bound block object, offset, stride, and length.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef struct 
{
  vsip_offset offset;
  vsip_stride stride;
  vsip_length length;
  vsip_block_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_vattr_<replaceable>p</replaceable>;

typedef struct 
{
  vsip_offset offset;
  vsip_stride stride;
  vsip_length length;
  vsip_cblock_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_cvattr_<replaceable>p</replaceable>;

void vsip_vgetattrib_f(const vsip_vview_f *v, vsip_vattr_f *attrib);
void vsip_vgetattrib_i(const vsip_vview_i *v, vsip_vattr_i *attrib);
void vsip_cvgetattrib_f(const vsip_cvview_f *v, vsip_cvattr_f *attrib);
void vsip_cvgetattrib_i(const vsip_cvview_i *v, vsip_cvattr_i *attrib);
void vsip_vgetattrib_bl(const vsip_vview_bl *v, vsip_vattr_bl *attrib);
void vsip_vgetattrib_vi(const vsip_vview_vi *v, vsip_vattr_vi *attrib);
void vsip_vgetattrib_mi(const vsip_vview_mi *v, vsip_vattr_mi *attrib);
void vsip_vgetattrib_ti(const vsip_vview_ti *v, vsip_vattr_ti *attrib);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attrib</term>

                <listitem>
                  <para>Pointer to output vector attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the vector attribute structure must be
                valid – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The block attribute can be read (get), but cannot be
            set.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvgetblock">
      <title>vsip_<replaceable>d</replaceable>vgetblock_<replaceable>p</replaceable></title>

      <para>Get the block attribute of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns a pointer to the VSIPL block object to which the
            vector view object is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_f *vsip_vgetblock_f(const vsip_vview_f *v);
vsip_block_i *vsip_vgetblock_i(const vsip_vview_i *v);
vsip_cblock_f *vsip_cvgetblock_f(const vsip_cvview_f *v);
vsip_cblock_i *vsip_cvgetblock_i(const vsip_cvview_i *v);
vsip_block_bl *vsip_vgetblock_bl(const vsip_vview_bl *v);
vsip_block_vi *vsip_vgetblock_vi(const vsip_vview_vi *v);
vsip_block_mi *vsip_vgetblock_mi(const vsip_vview_mi *v);
vsip_block_ti *vsip_vgetblock_ti(const vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the block object to which the vector
            view object is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The functions
            vsip_<replaceable>d</replaceable>vgetattrib_<replaceable>p</replaceable>
            and
            vsip_<replaceable>d</replaceable>vputattrib_<replaceable>p</replaceable>
            are not symmetric since you can get the block object but you
            cannot put the block object</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvgetlength">
      <title>vsip_<replaceable>d</replaceable>vgetlength_<replaceable>p</replaceable></title>

      <para>Get the length attribute of a vector view object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the value of the length (number of elements)
            attribute of a vector view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_vgetlength_f(const vsip_vview_f *v);
vsip_length vsip_vgetlength_i(const vsip_vview_i *v);
vsip_length vsip_cvgetlength_f(const vsip_cvview_f *v);
vsip_length vsip_cvgetlength_i(const vsip_cvview_i *v);
vsip_length vsip_vgetlength_bl(const vsip_vview_bl *v);
vsip_length vsip_vgetlength_vi(const vsip_vview_vi *v);
vsip_length vsip_vgetlength_mi(const vsip_vview_mi *v);
vsip_length vsip_vgetlength_ti(const vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the length attribute of a vector view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvgetoffset">
      <title>vsip_<replaceable>d</replaceable>vgetoffset_<replaceable>p</replaceable></title>

      <para>Get the offset attribute of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the offset (in elements) to the first scalar element
            of a vector view from the start of the block object to which it is
            bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_offset vsip_vgetoffset_f(const vsip_vview_f *v);
vsip_offset vsip_vgetoffset_i(const vsip_vview_i *v);
vsip_offset vsip_cvgetoffset_f(const vsip_cvview_f *v);
vsip_offset vsip_cvgetoffset_i(const vsip_cvview_i *v);
vsip_offset vsip_vgetoffset_bl(const vsip_vview_bl *v);
vsip_offset vsip_vgetoffset_vi(const vsip_vview_vi *v);
vsip_offset vsip_vgetoffset_mi(const vsip_vview_mi *v);
vsip_offset vsip_vgetoffset_ti(const vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the offset attribute of the vector view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvgetstride">
      <title>vsip_<replaceable>d</replaceable>vgetstride_<replaceable>p</replaceable></title>

      <para>Get the stride attribute of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the stride (in elements of the bound block) between
            successive scalar elements in a vector view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_stride vsip_vgetstride_f(const vsip_vview_f *v);
vsip_stride vsip_vgetstride_i(const vsip_vview_i *v);
vsip_stride vsip_cvgetstride_f(const vsip_cvview_f *v);
vsip_stride vsip_cvgetstride_i(const vsip_cvview_i *v);
vsip_stride vsip_vgetstride_bl(const vsip_vview_bl *v);
vsip_stride vsip_vgetstride_vi(const vsip_vview_vi *v);
vsip_stride vsip_vgetstride_mi(const vsip_vview_mi *v);
vsip_stride vsip_vgetstride_ti(const vsip_vview_ti *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the stride attribute of the vector view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="vimagview">
      <title>vsip_vimagview_<replaceable>p</replaceable></title>

      <para>Create a vector view object of the imaginary part of a complex
      vector from a complex vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real vector view object from the “imaginary part
            of a complex” vector view object, or returns null if it
            fails.</para>

            <para>On success, the function creates a derived block object
            (derived from the complex block object). The derived block object
            is bound to the imaginary data part of the original complex block
            and then binds a real vector view object to the block. The new
            vector encompasses the imaginary part of the input complex
            vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vimagview_f(const vsip_cvview_f *v);
vsip_vview_i *vsip_vimagview_i(const vsip_cvview_i *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Source vector view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created “imaginary” vector view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The derived block object cannot be destroyed or released.
            The parent complex block object may be released (if it is bound to
            user data). Destroying the complex block is the only way to free
            the memory associated with the derived block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The complex vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>This function should not be confused with the function
            vsip_simag_<replaceable>p</replaceable>() which is a copy operator
            (copies the imaginary data).</para>

            <para>There are no requirements on offset or stride of a real view
            on its derived block. Using
            vsip_vgetattrib_<replaceable>p</replaceable> information about the
            layout of the view on the block may be obtained.</para>

            <caution>
              <para>Using attribute information, and the block bound to the
              vector, to bind new vectors outside the data space of the
              original vector produced by
              vsip_simagview_<replaceable>p</replaceable> will produce
              nonportable code. Portable code may be produced by: (1)
              remaining inside the data space of the vector, (2) by not
              assuming a set relationship of strides and offsets, and (3) by
              using the get attributes functions to obtain necessary
              information within the application code to understand the layout
              for each implementation.</para>
            </caution>

            <para>Note to Implementors:</para>

            <itemizedlist>
              <listitem>
                <para>The resulting derived block must have a property which
                prevents it from being released or destroyed.</para>
              </listitem>

              <listitem>
                <para>In development mode,
                vsip_<replaceable>d</replaceable>vimagview_<replaceable>p</replaceable>
                updates the binding count in the parent complex block
                object.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting>/* Calculate a complex vector of length N, whose imaginary part is 
   the cosine from zero to 2+ and whose real part is the sine from
   zero to 2+, using real view and imaginary view functions to find
   the cosine and sine vectors. */
#include &lt;vsip.h&gt;
vsip_cvview_d *CV = vsip_cvcreate_d((vsip_length)N, VSIP_MEM_NONE);
vsip_vview_d *V = vsip_vcreate_d(vsip_length) N, VSIP_MEM_NONE), *RV, *IV;
/* make a ramp from zero to two pi where pi is M_PI*/
vsip_vramp_d(0, (2.0 * M_PI)/(double)(N - 1),V);
/* Fill the complex vector */
vsip_veuler_d(V,CV);
/* get the view of the real (cos) and imaginary (sin) parts */
vsip_vrealview_d(CV,RV);
vsip_vimagview_d(CV,IV);</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dvcloneview"><function>vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="vrealview"><function>vsip_vrealview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvsubview"><function>vsip_<replaceable>d</replaceable>vsubview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvput">
      <title>vsip_<replaceable>d</replaceable>vput_<replaceable>p</replaceable></title>

      <para>Put (Set) the value of a specified element of a vector view
      object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the value of the specified element of a vector
            view object.<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mi>x</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vput_f(const vsip_vview_f *y, vsip_index j, vsip_scalar_f x);
void vsip_vput_i(const vsip_vview_i *y, vsip_index j, vsip_scalar_i x);
void vsip_cvput_f(const vsip_cvview_f *y, vsip_index j, vsip_cscalar_f x);
void vsip_cvput_i(const vsip_cvview_i *y, vsip_index j, vsip_cscalar_i x);
void vsip_vput_bl(const vsip_vview_bl *y, vsip_index j, vsip_scalar_bl x);
void vsip_vput_vi(const vsip_vview_vi *y, vsip_index j, vsip_scalar_vi x);
void vsip_vput_mi(const vsip_vview_mi *y, vsip_index j, vsip_scalar_mi x);
void vsip_vput_ti(const vsip_vview_ti *y, vsip_index j, vsip_scalar_ti x);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Vector view object of destination</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Vector index j of vector element.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Scalar value to put</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must be a valid index of the vector
                view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>vsip_<replaceable>d</replaceable>sget_<replaceable>p</replaceable></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvputattrib">
      <title>vsip_<replaceable>d</replaceable>vputattrib_<replaceable>p</replaceable></title>

      <para>Put (Set) the attributes of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the value of the specified element of a vector
            view object.<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mi>x</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef struct 
{
  vsip_offset offset;
  vsip_stride stride;
  vsip_length length;
  vsip_block_<replaceable>p</replaceable> *block; Get only, ignored on Put
} vsip_vattr_<replaceable>p</replaceable>;

typedef struct 
{
  vsip_offset offset;
  vsip_stride stride;
  vsip_length length;
  vsip_cblock_<replaceable>p</replaceable> *block; Get only, ignored on Put
} vsip_cvattr_<replaceable>p</replaceable>;

vsip_vview_f *vsip_vputattrib_f(vsip_vview_f *v, const vsip_vattr_f *attrib);
vsip_vview_i *vsip_vputattrib_i(vsip_vview_i *v, const vsip_vattr_i *attrib);
vsip_cvview_f *vsip_cvputattrib_f(vsip_cvview_f *v, const vsip_cvattr_f *attrib);
vsip_cvview_i *vsip_cvputattrib_i(vsip_cvview_i *v, const vsip_cvattr_i *attrib);
vsip_vview_bl *vsip_vputattrib_bl(vsip_vview_bl *v, const vsip_vattr_bl *attrib);
vsip_vview_vi *vsip_vputattrib_vi(vsip_vview_vi *v, const vsip_vattr_vi *attrib);
vsip_vview_mi *vsip_vputattrib_mi(vsip_vview_mi *v, const vsip_vattr_mi *attrib);
vsip_vview_ti *vsip_vputattrib_ti(vsip_vview_ti *v, const vsip_vattr_ti *attrib);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attrib</term>

                <listitem>
                  <para>Pointer to a vector attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source vector view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the vector attribute structure must be
                valid – non-null.</para>
              </listitem>

              <listitem>
                <para>The stride, length, and offset arguments must not
                specify a vector view that exceeds the bounds of the data
                array of the associated block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The functions
            vsip_<replaceable>d</replaceable>vgetattrib_<replaceable>p</replaceable>
            and
            vsip_<replaceable>d</replaceable>vputattrib_<replaceable>p</replaceable>
            are not symmetric since you can get the block object but you
            cannot put the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting>#include &lt;vsip.h&gt;
…
vsip_vview_f *vect;
vsip_scalar_f sum;
…
{ 
  /* Modify vector view to view "odd" elements and sum the odd values */
  vsip_vattr_f attrib;
  vsip_vgetattrib_f(vect, &amp;attrib);
  attrib.stride *= 2;
  attrib.offset += 1;
  attrib.length /=2;
  sum = vsip_vsumval_f(vsip_vputattrib_f(vect, &amp;attrib));
}</programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvputlength">
      <title>vsip_<replaceable>d</replaceable>vputlength_<replaceable>p</replaceable></title>

      <para>Put (Set) the length attribute of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the length (number of elements) of a vector
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vputlength_f(vsip_vview_f *v, vsip_length length);
vsip_vview_i *vsip_vputlength_i(vsip_vview_i *v, vsip_length length);
vsip_vview_f *vsip_cvputlength_f(vsip_cvview_f *v, vsip_length length);
vsip_vview_i *vsip_cvputlength_i(vsip_cvview_i *v, vsip_length length);
vsip_vview_bl *vsip_vputlength_bl(vsip_vview_bl *v, vsip_length length);
vsip_vview_vi *vsip_vputlength_vi(vsip_vview_vi *v, vsip_length length);
vsip_vview_mi *vsip_vputlength_mi(vsip_vview_mi *v, vsip_length length);
vsip_vview_ti *vsip_vputlength_ti(vsip_vview_ti *v, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Length in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source vector view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The length argument must not specify a vector view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvputoffset">
      <title>vsip_<replaceable>d</replaceable>vputoffset_<replaceable>p</replaceable></title>

      <para>Put (Set) the offset attribute of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the offset (in elements) to the first scalar
            element of a vector view, from the start of the block object’s
            data array, to which it is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vputoffset_f(vsip_vview_f *v, vsip_offset offset);
vsip_vview_i *vsip_vputoffset_i(vsip_vview_i *v, vsip_offset offset);
vsip_vview_f *vsip_cvputoffset_f(vsip_cvview_f *v, vsip_offset offset);
vsip_vview_i *vsip_cvputoffset_i(vsip_cvview_i *v, vsip_offset offset);
vsip_vview_bl *vsip_vputoffset_bl(vsip_vview_bl *v, vsip_offset offset);
vsip_vview_vi *vsip_vputoffset_vi(vsip_vview_vi *v, vsip_offset offset);
vsip_vview_mi *vsip_vputoffset_mi(vsip_vview_mi *v, vsip_offset offset);
vsip_vview_ti *vsip_vputoffset_ti(vsip_vview_ti *v, vsip_offset offset);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>offset</term>

                <listitem>
                  <para>Offset in elements relative to the start of the block
                  object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source vector view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The offset argument must not specify a vector view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvputstride">
      <title>vsip_<replaceable>d</replaceable>vputstride_<replaceable>p</replaceable></title>

      <para>Put (Set) the stride attribute of a vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the stride attribute of a vector view object.
            Stride is the distance in elements of the block between successive
            elements of the vector view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vputstride_f(vsip_vview_f *v, vsip_stride stride);
vsip_vview_i *vsip_vputstride_i(vsip_vview_i *v, vsip_stride stride);
vsip_cvview_f *vsip_cvputstride_f(vsip_cvview_f *v, vsip_stride stride);
vsip_cvview_i *vsip_cvputstride_i(vsip_cvview_i *v, vsip_stride stride);
vsip_vview_bl *vsip_vputstride_bl(vsip_vview_bl *v, vsip_stride stride);
vsip_vview_vi *vsip_vputstride_vi(vsip_vview_vi *v, vsip_stride stride);
vsip_vview_mi *vsip_vputstride_mi(vsip_vview_mi *v, vsip_stride stride);
vsip_vview_ti *vsip_vputstride_ti(vsip_vview_ti *v, vsip_stride stride);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Vector view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>stride</term>

                <listitem>
                  <para>Stride in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source vector view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The stride argument must not specify a vector view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="vrealview">
      <title>vsip_vrealview_<replaceable>p</replaceable></title>

      <para>Create a vector view object of the real part of a complex vector
      from a complex vector view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real vector view object from the “real part of a
            complex” vector view object, or returns null if it fails.</para>

            <para>On success, the function creates a derived block object
            (derived from the complex block object). The derived block object
            is bound to the real data part of the original complex block and
            then binds a real vector view object to the block. The new vector
            encompasses the real part of the input complex vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vrealview_f(const vsip_cvview_f *v);
vsip_vview_i *vsip_vrealview_i(const vsip_cvview_i *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Source vector view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created “real” vector view object,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The derived block object cannot be destroyed or released.
            The parent complex block object may be released (if it is bound to
            user data). Destroying the complex block is the only way to free
            the memory associated with the derived block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The complex vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>This function should not be confused with the function
            vsip_sreal_<replaceable>p</replaceable>() which is a copy operator
            (copies the imaginary data).</para>

            <para>There are no requirements on offset or stride of a real view
            on its derived block. Using
            vsip_vgetattrib_<replaceable>p</replaceable> information about the
            layout of the view on the block may be obtained.</para>

            <caution>
              <para>Using attribute information, and the block bound to the
              vector, to bind new vectors outside the data space of the
              original vector produced by
              vsip_srealview_<replaceable>p</replaceable> will produce
              nonportable code. Portable code may be produced by: (1)
              remaining inside the data space of the vector, (2) by not
              assuming a set relationship of strides and offsets, and (3) by
              using the get attributes functions to obtain necessary
              information within the application code to understand the layout
              for each implementation.</para>
            </caution>

            <para>Note to Implementors:</para>

            <itemizedlist>
              <listitem>
                <para>The resulting derived block must have a property which
                prevents it from being released or destroyed.</para>
              </listitem>

              <listitem>
                <para>In development mode,
                vsip_<replaceable>d</replaceable>vrealview_<replaceable>p</replaceable>
                updates the binding count in the parent complex block
                object.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>See example with
            vsip_<replaceable>d</replaceable>vimagview_<replaceable>p</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dvcloneview"><function>vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="vimagview"><function>vsip_vimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvsubview"><function>vsip_<replaceable>d</replaceable>vsubview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvsubview">
      <title>vsip_<replaceable>d</replaceable>vsubview_<replaceable>p</replaceable></title>

      <para>Create a vector view object that is a subview of a vector view
      object (offset, and length are relative to the source view object, not
      the bound block object).</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a subview vector view object from a source vector
            view object, and binds it to the same block object, or returns
            null if it fails. The zero index element of the new subview
            corresponds to the index element of the source vector view.</para>

            <para>(The subview is relative to the source view, and stride is
            inherited from the source view).</para>

            <informalfigure>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/offset.svg" format="svg"
                             scale="80"/>
                </imageobject>

                <imageobject>
                  <imagedata fileref="images/offset.png" format="png"
                             scale="80"/>
                </imageobject>
              </mediaobject>
            </informalfigure>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_vsubview_f(const vsip_vview_f *v, 
                              vsip_index index, vsip_length length);
vsip_vview_i *vsip_vsubview_i(const vsip_vview_i *v, 
                              vsip_index index, vsip_length length);
vsip_cvview_f *vsip_cvsubview_f(const vsip_cvview_f *v, 
                                vsip_index index, vsip_length length);
vsip_cvview_i *vsip_cvsubview_i(const vsip_cvview_i *v, 
                                vsip_index index, vsip_length length);
vsip_vview_bl *vsip_vsubview_bl(const vsip_vview_bl *v, 
                                vsip_index index, vsip_length length);
vsip_vview_vi *vsip_vsubview_vi(const vsip_vview_vi *v, 
                                vsip_index index, vsip_length length);
vsip_vview_mi *vsip_vsubview_mi(const vsip_vview_mi *v, 
                                vsip_index index, vsip_length length);
vsip_vview_ti *vsip_vsubview_ti(const vsip_vview_ti *v, 
                                vsip_index index, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Source vector view.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>The subview vectors first element (index 0) is at
                  vector index “index” of the source vector.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Length in elements of new vector view.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created subview vector view object,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The subview must not extend beyond the bounds of the
                source view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the function
            updates the binding count (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>See example with
            vsip_<replaceable>d</replaceable>vimagview_<replaceable>p</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dvbind"><function>vsip_<replaceable>d</replaceable>vbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcloneview"><function>vsip_<replaceable>d</replaceable>vcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dvcreate"><function>vsip_<replaceable>d</replaceable>vcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="vimagview"><function>vsip_vimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="vrealview"><function>vsip_vrealview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Matrix View Object Functions</title>

    <para>VSIPL blocks hold the data in a data array. A block can be viewed as
    a vector or matrix. Two or more vector and/or matrix objects may reference
    the same block. VSIPL library functions make no distinction that is
    apparent to the application programmer between block objects which
    reference only VSIPL data arrays and block objects which reference user
    data arrays associated with an admitted block.</para>

    <para>Matrix view objects have the attributes of offset, col_stride,
    row_stride, col_length and row_length.</para>

    <para>VSIPL makes no distinction between row major or column major. The
    major direction is decided on matrix view creation by the selection of the
    strides, row_stride and col_stride. See
    vsip_<replaceable>d</replaceable>mcreate_<replaceable>p</replaceable> for
    more details.</para>

    <note>
      <para>A matrix view object can be transposed by using a function to
      exchange the values of row_stride, row_length, col_stride, and
      col_length. This is not the same thing as transposing the underlying
      data in the block. The applications programmer needs to be aware that
      memory access in an inner loop (or implied in a library function) that
      access successive matrix elements with strides that are longer than
      cache lines are likely to experience a very significant performance
      degradation. There does not appear to be a satisfactory abstraction to
      hide this aspect of portability from the applications programmer for any
      computing system that has nonhomogeneous average latency and bandwidth
      for accessing memory.</para>
    </note>

    <para>Matrix view object functions are provided to:</para>

    <itemizedlist>
      <listitem>
        <para>Create (constructors) matrix view objects,</para>
      </listitem>

      <listitem>
        <para>create (constructors) vector view objects from matrix view
        objects,</para>
      </listitem>

      <listitem>
        <para>destroy (destructors) matrix view objects,</para>
      </listitem>

      <listitem>
        <para>modify/manipulate matrix view objects, and</para>
      </listitem>

      <listitem>
        <para>access functions for matrix view objects.</para>
      </listitem>
    </itemizedlist>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>vsip_<replaceable>d</replaceable>malldestroy_<replaceable>p</replaceable></entry>

            <entry>Destroy Matrix and Block</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></entry>

            <entry>Create and Bind a Matrix View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></entry>

            <entry>Create Matrix View Clone</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></entry>

            <entry>Create Column-View Matrix View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mcreate_<replaceable>p</replaceable></entry>

            <entry>Create Matrix</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mdestroy_<replaceable>p</replaceable></entry>

            <entry>Destroy Matrix View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></entry>

            <entry>Create Matrix Diagonal View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mget_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Element</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetattrib_<replaceable>p</replaceable></entry>

            <entry>Matrix Get View Attributes</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetblock_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Block</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetcollength_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Column Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetcolstride_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Column Stride</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetoffset_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Offset</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetrowlength_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Row Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mgetrowstride_<replaceable>p</replaceable></entry>

            <entry>Matrix Get Row Stride</entry>
          </row>

          <row>
            <entry>vsip_mimagview_<replaceable>p</replaceable></entry>

            <entry>Create Imaginary Matrix View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mput_<replaceable>p</replaceable></entry>

            <entry>Matrix Put Element</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mputattrib_<replaceable>p</replaceable></entry>

            <entry>Matrix Put View Attributes</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mputcollength_<replaceable>p</replaceable></entry>

            <entry>Matrix Put Column Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mputcolstride_<replaceable>p</replaceable></entry>

            <entry>Matrix Put Column Stride</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mputoffset_<replaceable>p</replaceable></entry>

            <entry>Matrix Put Offset</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mputrowlength_<replaceable>p</replaceable></entry>

            <entry>Matrix Put Row Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mputrowstride_<replaceable>p</replaceable></entry>

            <entry>Matrix Put Row Stride</entry>
          </row>

          <row>
            <entry>vsip_mrealview_<replaceable>p</replaceable></entry>

            <entry>Create Real Matrix View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></entry>

            <entry>Create Matrix Row View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></entry>

            <entry>Create Sub-View Matrix View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></entry>

            <entry>Create Matrix Transposed View</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dmalldestroy">
      <title>vsip_<replaceable>d</replaceable>malldestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a matrix, its associated block, and any VSIPL data
      array bound to the block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroys (frees) a matrix view object, the block object to
            which it is bound, and any VSIPL data array. If <code>X</code> is
            a matrix of type
            <code>vsip_<replaceable>d</replaceable>mview_<replaceable>p</replaceable></code>,
            then
            <code>vsip_<replaceable>d</replaceable>malldestroy_<replaceable>p</replaceable>(X);</code>
            is equivalent to<code>
            vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable>(vsip_<replaceable>d</replaceable>mdestroy_<replaceable>p</replaceable>(X);</code></para>

            <para>This is the complementary function to
            vsip_<replaceable>d</replaceable>mcreate_<replaceable>p</replaceable>
            and should only be used to destroy matrices that have only one
            view bound to the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_malldestroy_f(vsip_mview_f *X);
void vsip_malldestroy_i(vsip_mview_i *X);
void vsip_cmalldestroy_f(vsip_cmview_f *X);
void vsip_cmalldestroy_i(vsip_cmview_i *X);
void vsip_malldestroy_bl(vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid. An argument of
                null is not an error.</para>
              </listitem>

              <listitem>
                <para>The specified matrix view must be the only view bound to
                the block.</para>
              </listitem>

              <listitem>
                <para>The matrix view must not be bound to a derived block
                (derived from a complex block).</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the matrix view is bound to a derived block (derived from
            a complex block) the complex block must be destroyed to free the
            block and associated data.</para>

            <para>An argument of null is not an error.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting>/* Create and destroy a simple matrix of 10 by 15 elements. */
vsip_mview_f *X =
vsip_mcreate_f((vsip_length)10,(vsip_length)15,VSIP_MEM_NONE);
…
vsip_malldestroy_f(X);</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockdestroy"><function>vsip_blockdestroy_<replaceable>p</replaceable></function></link>,
            <function><link
            linkend="dmcreate">vsip_<replaceable>d</replaceable>mcreate_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmdestroy">vsip_<replaceable>d</replaceable>mdestroy_<replaceable>p</replaceable></link></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmbind">
      <title>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></title>

      <para>Create a matrix view object and bind it to a block object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a matrix object or returns null if it fails. If the
            view create is successful, it: (1) binds the matrix view object to
            the block object; (2) sets the offset from the beginning of the
            data array to the beginning of the matrix, the stride, col_stride,
            between scalar elements in a column, the number col_length of
            scalar elements in a column, the stride, row_stride, between
            scalar elements in a row, the number row_length of scalar elements
            in a row; and (3) then returns a pointer to the created matrix
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mbind_f(const vsip_block_f *block, vsip_offset offset, 
                           vsip_stride col_stride, vsip_length col_length,
                           vsip_stride row_stride, vsip_length row_length);
vsip_mview_i *vsip_mbind_i(const vsip_block_i *block, vsip_offset offset,
                           vsip_stride col_stride, vsip_length col_length, 
                           vsip_stride row_stride, vsip_length row_length);
vsip_cmview_f *vsip_cmbind_f(const vsip_cblock_f *block, vsip_offset offset,
                             vsip_stride col_stride, vsip_length col_length,
                             vsip_stride row_stride, vsip_length row_length);
vsip_cmview_i *vsip_cmbind_i(const vsip_cblock_i *block, vsip_offset offset,
                             vsip_stride col_stride, vsip_length col_length,
                             vsip_stride row_stride, vsip_length row_length);
vsip_mview_bl *vsip_mbind_bl(const vsip_block_bl *block, vsip_offset offset,
                             vsip_stride col_stride, vsip_length col_length,
                             vsip_stride row_stride, vsip_length row_length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>offset</term>

                <listitem>
                  <para>Matrix view offset in elements relative to the base of
                  block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>col_stride</term>

                <listitem>
                  <para>Matrix view stride between elements in a
                  column.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>col_length</term>

                <listitem>
                  <para>Matrix view length in elements of a column.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>row_stride</term>

                <listitem>
                  <para>Matrix view stride between scalar elements in a
                  row.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>row_length</term>

                <listitem>
                  <para>Matrix view length in elements of a row.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created matrix view object, or null
            if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The offset must be less than the length of the block’s
                data array.</para>
              </listitem>

              <listitem>
                <para>The row stride, row length, column stride, column
                length, and offset arguments must not specify a matrix view
                that exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the function
            updates the bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function><link
            linkend="dmcloneview">vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmcolview">vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmdiagview">vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></link></function>,
            <link
            linkend="mimagview"><function>vsip_mimagview_<replaceable>p</replaceable></function></link>,<function>
            <link
            linkend="mrealview">vsip_mrealview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmrowview">vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmsubview">vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmtransview">vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></link></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmcloneview">
      <title>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></title>

      <para>Create a clone of a matrix view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a new matrix view object, copies all of the
            attributes of the source matrix view object to the new matrix view
            object, and then binds the new matrix view object to the block
            object of the source matrix view object. This function returns
            null on a memory allocation (creation) failure; otherwise, it
            returns a pointer to the new matrix view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mcloneview_f(const vsip_mview_f *X);
vsip_mview_i *vsip_mcloneview_i(const vsip_mview_i *X);
vsip_cmview_f *vsip_cmcloneview_f(const vsip_cmview_f *X);
vsip_cmview_i *vsip_cmcloneview_i(const vsip_cmview_i *X);
vsip_mview_bl *vsip_mcloneview_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created matrix view object clone,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the function
            updates the number of bindings (reference count) recorded in the
            block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <function><link
            linkend="dmcolview">vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmdiagview">vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="mimagview">vsip_mimagview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="mrealview">vsip_mrealview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmrowview">vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmsubview">vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></link></function>,
            <link
            linkend="dmtransview"><function>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmcolview">
      <title>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></title>

      <para>Create a vector view object of a specified column of the source
      matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a vector view object from a specified column of a
            matrix view object, or returns null if it fails. Otherwise, it
            binds the new vector view object to the same block object as the
            source matrix view object and sets its attributes to view just the
            specified column of the source matrix object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_mcolview_f(const vsip_mview_f *X, vsip_index col_index);
vsip_vview_i *vsip_mcolview_i(const vsip_mview_i *X, vsip_index col_index);
vsip_cvview_f *vsip_cmcolview_f(const vsip_cmview_f *X, vsip_index col_index);
vsip_cvview_i *vsip_cmcolview_i(const vsip_cmview_i *X, vsip_index col_index);
vsip_vview_bl *vsip_mcolview_bl(const vsip_mview_bl *X, vsip_index col_index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>col_index</term>

                <listitem>
                  <para>Column index of source matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created column vector view object,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The requested column index must be a valid column index
                of the source matrix view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function><link
            linkend="dmbind">vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></link></function>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,<function>
            <link
            linkend="dmdiagview">vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="mimagview">vsip_mimagview_<replaceable>p</replaceable></link></function>,
            <link
            linkend="mrealview"><function>vsip_mrealview_<replaceable>p</replaceable></function></link>,
            <function><link
            linkend="dmrowview">vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></link></function>,
            <function><link
            linkend="dmsubview">vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></link></function>,
            and <function><link
            linkend="dmtransview">vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></link></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmcreate">
      <title>vsip_<replaceable>d</replaceable>mcreate_<replaceable>p</replaceable></title>

      <para>Creates a block object and matrix view (object) of the
      block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a block object with an M ,N element VSIPL data
            array, it creates an M by N dense matrix view object and then
            binds the block object to it.</para>

            <para>The function</para>

            <para><programlisting>vsip_mview_<replaceable>p</replaceable> *vsip_mcreate_<replaceable>p</replaceable>(M, N, VSIP_ROW, hint);</programlisting>returns
            the same result as<programlisting>vsip_mbind_<replaceable>p</replaceable>(vsip_blockcreate_<replaceable>p</replaceable>(M*N, hint),(vsip_offset)0,
             (vsip_stride)N, (vsip_length)M,  /* column stride, column length */
             (vsip_stride)1, (vsip_length)N); /* row stride, row length */</programlisting>or<programlisting>vsip_mview_<replaceable>p</replaceable> *vsip_mcreate_<replaceable>p</replaceable>(M, N, VSIP_COL, hint);</programlisting>returns
            the same result as<programlisting>vsip_mbind_<replaceable>p</replaceable>(vsip_blockcreate_<replaceable>p</replaceable>(M*N, hint),(vsip_offset)0,
             (vsip_stride)1, (vsip_length)M,  /* column stride, column length */
             (vsip_stride)M, (vsip_length)N); /* row stride, row length */</programlisting>except
            that <function>vsip_mcreate_p</function> returns a null if
            <code>vsip_block_create_p(M*N, hint)</code> returns a null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mcreate_f(vsip_length M, vsip_length N,
                             vsip_major major, vsip_memory_hint hint);
vsip_mview_i *vsip_mcreate_i(vsip_length M, vsip_length N,
                             vsip_major major, vsip_memory_hint hint);
vsip_cmview_f *vsip_cmcreate_f(vsip_length M, vsip_length N,
                               vsip_major major, vsip_memory_hint hint);
vsip_cmview_i *vsip_cmcreate_i(vsip_length M, vsip_length N,
                               vsip_major major, vsip_memory_hint hint);
vsip_mview_bl *vsip_mcreate_bl(vsip_length M, vsip_length N,
                               vsip_major major, vsip_memory_hint hint);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>M</term>

                <listitem>
                  <para>Number of rows of the matrix view (column
                  length).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of columns of the matrix view (row
                  length).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>major</term>

                <listitem>
                  <para>Row or Column major</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>hint</term>

                <listitem>
                  <para>Memory hint</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created matrix view object, or null
            if it fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The lengths, N and M, must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The major memory direction must be a valid member of the
                vsip_major enumeration.</para>
              </listitem>

              <listitem>
                <para>The memory hint must be a valid member of the
                vsip_memory_hint enumeration.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Note to Implementors: In development mode, it should also
            update the bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmdestroy">
      <title>vsip_<replaceable>d</replaceable>mdestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a matrix view object and return a pointer to the
      associated block object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Frees a matrix view object from the block object that it was
            bound to, destroys the matrix view object, and then returns a
            pointer to the block object. If the vector view argument is null,
            it returns null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_f *vsip_mdestroy_f(vsip_mview_f *X);
vsip_block_i *vsip_mdestroy_i(vsip_mview_i *X);
vsip_cblock_f *vsip_cmdestroy_f(vsip_cmview_f *X);
vsip_cblock_i *vsip_cmdestroy_i(vsip_cmview_i *X);
vsip_block_bl *vsip_mdestroy_bl(vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the block object to which the matrix
            view was bound, or null if the calling argument was null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid. An argument of
                null is not an error.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>

            <para>Note to Implementors: In development mode, the function
            updates the bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmdiagview">
      <title>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></title>

      <para>Create a vector view object of a matrix diagonal of a matrix view
      object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a vector view object of a specified diagonal of a
            matrix view object, or returns null if it fails. On success, it
            binds the new vector view object to the same block object as the
            source matrix view object and sets its attributes to view just the
            specified diagonal of the source matrix object. An index of ‘0’
            specifies the main diagonal, positive indices are above the main
            diagonal, and negative indices are below the main diagonal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_mdiagview_f(const vsip_mview_f *X, vsip_stride index);
vsip_vview_i *vsip_mdiagview_i(const vsip_mview_i *X, vsip_stride index);
vsip_cvview_f *vsip_cmdiagview_f(const vsip_cmview_f *X, vsip_stride index);
vsip_cvview_i *vsip_cmdiagview_i(const vsip_cmview_i *X, vsip_stride index);
vsip_vview_bl *vsip_mdiagview_bl(const vsip_mview_bl *X, vsip_stride index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Index of diagonal: 0 main, + above, - below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created diagonal vector view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must specify a valid diagonal. For positive
                indices, index must be less than the number of column, for
                negative indices, the |index| must be less than the number of
                rows.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>The index is of type vsip_stride since this is a portable
            signed integer of sufficient size to index any supported matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcolview"><function>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mimagview"><function>vsip_mimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mrealview"><function>vsip_mrealview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmrowview"><function>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmsubview"><function>vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dmtransview"><function>vsip_<replaceable>d</replaceable>mtransview_</function><replaceable>p</replaceable></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmget">
      <title>vsip_<replaceable>d</replaceable>mget_<replaceable>p</replaceable></title>

      <para>Get the value of a specified element of a matrix view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the value of the specified element of a matrix view
            object, <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mi>i,j</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_mget_f(const vsip_mview_f *X,
                          vsip_index i, vsip_index j);
vsip_scalar_i vsip_mget_i(const vsip_mview_i *X,
                          vsip_index i, vsip_index j);
vsip_cscalar_f vsip_cmget_f(const vsip_cmview_f *X,
                            vsip_index i, vsip_index j);
vsip_cscalar_i vsip_cmget_i(const vsip_cmview_i *X,
                            vsip_index i, vsip_index j);
vsip_scalar_bl vsip_mget_bl(const vsip_mview_bl *X,
                            vsip_index i, vsip_index j);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>i</term>

                <listitem>
                  <para>Matrix index i of (i,j), the row index.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Matrix index j of (i,j), the column index.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the specified element of a matrix view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must be a valid index of the matrix
                view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable><replaceable>s</replaceable>put_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetattrib">
      <title>vsip_<replaceable>d</replaceable>mgetattrib_<replaceable>p</replaceable></title>

      <para>Get the attributes of a matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Retrieves the attributes of matrix view object: (pointer to)
            bound block object, offset, col_stride, col_length, row_stride,
            and row_length.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>
typedef struct 
{
  vsip_offset offset;
  vsip_stride row_stride;
  vsip_length row_length;
  vsip_stride col_stride;
  vsip_length col_length;
  vsip_block_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_mattr_<replaceable>p</replaceable>;
typedef struct 
{
  vsip_offset offset;
  vsip_stride row_stride;
  vsip_length row_length;
  vsip_stride col_stride;
  vsip_length col_length;
  vsip_cblock_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_cmattr_<replaceable>p</replaceable>;

void vsip_mgetattrib_f(vsip_mview_f *X, vsip_mattr_f *attrib);
void vsip_mgetattrib_i(vsip_mview_i *X, vsip_mattr_i *attrib);
void vsip_cmgetattrib_f(vsip_cmview_f *X, vsip_cmattr_f *attrib);
void vsip_cmgetattrib_i(vsip_cmview_i *X, vsip_cmattr_i *attrib);
void vsip_mgetattrib_bl(vsip_mview_bl *X, vsip_mattr_bl *attrib);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attrib</term>

                <listitem>
                  <para>Pointer to output matrix attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the matrix attribute structure must be
                valid – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The block attribute can be read (get), but cannot be
            set.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetblock">
      <title>vsip_<replaceable>d</replaceable>mgetblock_<replaceable>p</replaceable></title>

      <para>Get the block attribute of a matrix view object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns a pointer to the VSIPL block object to which the
            matrix view object is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_f *vsip_mgetblock_f(const vsip_mview_f *X);
vsip_block_i *vsip_mgetblock_i(const vsip_mview_i *X);
vsip_cblock_f *vsip_cmgetblock_f(const vsip_cmview_f *X);
vsip_cblock_i *vsip_cmgetblock_i(const vsip_cmview_i *X);
vsip_block_bl *vsip_mgetblock_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the block object to which the matrix
            view object is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The functions
            vsip_<replaceable>d</replaceable>mgetattrib_<replaceable>p</replaceable>
            and
            vsip_<replaceable>d</replaceable>mputattrib_<replaceable>p</replaceable>
            are not symmetric since you can get the block object but you
            cannot put the block object</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetcollength">
      <title>vsip_<replaceable>d</replaceable>mgetcollength_<replaceable>p</replaceable></title>

      <para>Get the column length attribute of a matrix view object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the length of (number of elements along) a column of
            a matrix view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_mgetcollength_f(const vsip_mview_f *X);
vsip_length vsip_mgetcollength_i(const vsip_mview_i *X);
vsip_length vsip_cmgetcollength_f(const vsip_cmview_f *X);
vsip_length vsip_cmgetcollength_i(const vsip_cmview_i *X);
vsip_length vsip_mgetcollength_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the col_length attribute of a matrix
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The following cause a VSIPL runtime error in development
            mode; in production mode the results will be implementation
            dependent.</para>

            <orderedlist>
              <listitem>
                <para>The matrix view is invalid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetcolstride">
      <title>vsip_<replaceable>d</replaceable>mgetcolstride_<replaceable>p</replaceable></title>

      <para>Get the column stride attribute of a matrix view object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the stride (in elements of the bound block) between
            successive scalar elements along a column of a matrix view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_stride vsip_mgetcolstride_f(const vsip_mview_f *X);
vsip_stride vsip_mgetcolstride_i(const vsip_mview_i *X);
vsip_stride vsip_cmgetcolstride_f(const vsip_cmview_f *X);
vsip_stride vsip_cmgetcolstride_i(const vsip_cmview_i *X);
vsip_stride vsip_mgetcolstride_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the column stride attribute of a matrix
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetoffset">
      <title>vsip_<replaceable>d</replaceable>mgetoffset_<replaceable>p</replaceable></title>

      <para>Get the offset attribute of a matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the offset (in elements) to the first scalar element
            of a matrix view from the start of the block object to which it is
            bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_offset vsip_mgetoffset_f(const vsip_mview_f *X);
vsip_offset vsip_mgetoffset_i(const vsip_mview_i *X);
vsip_offset vsip_cmgetoffset_f(const vsip_cmview_f *X);
vsip_offset vsip_cmgetoffset_i(const vsip_cmview_i *X);
vsip_offset vsip_mgetoffset_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the offset attribute of the matrix view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetrowlength">
      <title>vsip_<replaceable>d</replaceable>mgetrowlength_<replaceable>p</replaceable></title>

      <para>Get the row length attribute of a matrix view object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the length of (number of elements along) a row of a
            matrix view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_mgetrowlength_f(const vsip_mview_f *X);
vsip_length vsip_mgetrowlength_i(const vsip_mview_i *X);
vsip_length vsip_cmgetrowlength_f(const vsip_cmview_f *X);
vsip_length vsip_cmgetrowlength_i(const vsip_cmview_i *X);
vsip_length vsip_mgetrowlength_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the row_length attribute of a matrix
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The following cause a VSIPL runtime error in development
            mode; in production mode the results will be implementation
            dependent.</para>

            <orderedlist>
              <listitem>
                <para>The matrix view is invalid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmgetrowstride">
      <title>vsip_<replaceable>d</replaceable>mgetrowstride_<replaceable>p</replaceable></title>

      <para>Get the row stride attribute of a matrix view object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the stride (in elements of the bound block) between
            successive scalar elements along a row of a matrix view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_stride vsip_mgetrowstride_f(const vsip_mview_f *X);
vsip_stride vsip_mgetrowstride_i(const vsip_mview_i *X);
vsip_stride vsip_cmgetrowstride_f(const vsip_cmview_f *X);
vsip_stride vsip_cmgetrowstride_i(const vsip_cmview_i *X);
vsip_stride vsip_mgetrowstride_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the row stride attribute of a matrix
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="mimagview">
      <title>vsip_mimagview_<replaceable>p</replaceable></title>

      <para>Create a matrix view object of the imaginary part of a complex
      matrix from a complex matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real matrix view object from the “imaginary part
            of a complex” matrix view object, or returns null if it
            fails.</para>

            <para>On success the function creates a derived block object,
            derived from the complex block object, that is bound to the
            imaginary data part of the original complex block and then binds a
            real matrix view object to the block. The new matrix encompasses
            the imaginary part of the source complex matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mimagview_f(const vsip_cmview_f *X);
vsip_mview_i *vsip_mimagview_i(const vsip_cmview_i *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created “imaginary” matrix view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The derived block object, derived from the complex block
            object cannot be destroyed or released. The parent complex block
            object may be released (if it is bound to user data), and
            destroying the complex block is the only way to free the memory
            associated with the derived block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The complex matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>This function should not be confused with the function
            vsip_simag_<replaceable>p</replaceable>() which is a copy operator
            (copies the imaginary data).</para>

            <para>There are no requirements on offset or stride of a real view
            on its derived block. Using
            vsip_vgetattrib_<replaceable>p</replaceable> information about the
            layout of the view on the block may be obtained.</para>

            <caution>
              <para>Using attribute information, and the block bound to the
              matrix, to bind new matrices outside the data space of the
              original matrix produced by
              vsip_simagview_<replaceable>p</replaceable> will produce
              non-portable code. Portable code may be produced by: (1)
              remaining inside the data space of the matrix, (2) by not
              assuming a set relationship of strides and offsets, and (3) by
              using the get attributes functions to obtain necessary
              information within the application code to understand the layout
              for each implementation.</para>
            </caution>

            <para>Note to Implementors:</para>

            <itemizedlist>
              <listitem>
                <para>The resulting derived block must have a property which
                prevents it from being released or destroyed.</para>
              </listitem>

              <listitem>
                <para>In development mode, block binding count (reference
                count) recorded in the block object is incremented.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcolview"><function>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmdiagview"><function>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mrealview"><function>vsip_mrealview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmrowview"><function>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmsubview"><function>vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmtransview"><function>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></function></link>,
            and
            <function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmput">
      <title>vsip_<replaceable>d</replaceable>mput_<replaceable>p</replaceable></title>

      <para>Put (Set) the value of a specified element of a matrix view
      object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the value of the specified element of a matrix
            view object.<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>y</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>←</m:mo>

                    <m:mi>x</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_mput_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *y, vsip_index i, vsip_index j, 
                 vsip_scalar_<replaceable>f</replaceable> x);
void vsip_mput_<replaceable>i</replaceable>(const vsip_mview_<replaceable>i</replaceable> *y, vsip_index i, vsip_index j, 
                 vsip_scalar_<replaceable>i</replaceable> x);
void vsip_cmput_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *y, vsip_index i, vsip_index j, 
                  vsip_cscalar_<replaceable>f</replaceable> x);
void vsip_cmput_<replaceable>i</replaceable>(const vsip_cmview_<replaceable>i</replaceable> *y, vsip_index i, vsip_index j, 
                  vsip_cscalar_<replaceable>i</replaceable> x);
void vsip_mput_bl(const vsip_mview_bl *y, vsip_index i, vsip_index j, 
                  vsip_scalar_bl x);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Matrix view object of destination</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>i</term>

                <listitem>
                  <para>Matrix index i of ( i, j), the row index.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Matrix index j of ( i, j), the row index.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Scalar value to put in matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must be a valid index of the matrix
                view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable><replaceable>s</replaceable>get_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmputattrib">
      <title>vsip_<replaceable>d</replaceable>mputattrib_<replaceable>p</replaceable></title>

      <para>Put (Set) the attributes of a matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Stores the matrix view attributes of: offset, column stride,
            column length, row stride, and row length, of a matrix view
            object, and as a programmer convenience, returns a pointer to the
            matrix view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>
typedef struct 
{
  vsip_offset offset;
  vsip_stride row_stride;
  vsip_length row_length;
  vsip_stride col_stride;
  vsip_length col_length;
  vsip_block_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_mattr_<replaceable>p</replaceable>;
typedef struct 
{
  vsip_offset offset;
  vsip_stride row_stride;
  vsip_length row_length;
  vsip_stride col_stride;
  vsip_length col_length;
  vsip_cblock_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_cmattr_<replaceable>p</replaceable>;

vsip_mview_f *vsip_mputattrib_f(vsip_mview_f *X, const vsip_mattr_f *attrib);
vsip_mview_i *vsip_mputattrib_i(vsip_mview_i *X, const vsip_mattr_i *attrib);
vsip_cmview_f *vsip_cmputattrib_f(vsip_cmview_f *X, const vsip_cmattr_f *attrib);
vsip_cmview_i *vsip_cmputattrib_i(vsip_cmview_i *X, const vsip_cmattr_i *attrib);
vsip_mview_bl *vsip_mputattrib_bl(vsip_mview_bl *X, const vsip_mattr_bl *attrib);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attrib</term>

                <listitem>
                  <para>Pointer to a matrix attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source matrix view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the matrix attribute structure must be
                valid – non-null.</para>
              </listitem>

              <listitem>
                <para>The offset, column stride, column length, row stride,
                and row length arguments must not specify a matrix view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The functions vsip_mgetattrib_<replaceable>p</replaceable>
            and vsip_mputattrib_<replaceable>p</replaceable> are not symmetric
            since you can “get” the block object but you cannot “put” the
            block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmputcollength">
      <title>vsip_<replaceable>d</replaceable>mputcollength_<replaceable>p</replaceable></title>

      <para>Put (Set) the column length attribute of a matrix view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the length of (number of elements along) a
            column of a matrix view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mputcollength_f(const vsip_mview_f *X, vsip_length length);
vsip_mview_i *vsip_mputcollength_i(const vsip_mview_i *X, vsip_length length);
vsip_mview_f *vsip_cmputcollength_f(const vsip_cmview_f *X, vsip_length length);
vsip_mview_i *vsip_cmputcollength_i(const vsip_cmview_i *X, vsip_length length);
vsip_mview_bl *vsip_mputcollength_bl(const vsip_mview_bl *X, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Column length in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source matrix view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The length argument must not specify a matrix view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmputcolstride">
      <title>vsip_<replaceable>d</replaceable>mputcolstride_<replaceable>p</replaceable></title>

      <para>Put (Set) the column stride attribute of a matrix view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the stride (in elements of the bound block)
            between successive scalar elements along a column of a matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mputcolstride_f(const vsip_mview_f *X, vsip_stride stride);
vsip_mview_i *vsip_mputcolstride_i(const vsip_mview_i *X, vsip_stride stride);
vsip_mview_f *vsip_cmputcolstride_f(const vsip_cmview_f *X, vsip_stride stride);
vsip_mview_i *vsip_cmputcolstride_i(const vsip_cmview_i *X, vsip_stride stride);
vsip_mview_bl *vsip_mputcolstride_bl(const vsip_mview_bl *X, vsip_stride stride);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Column stride in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source matrix view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The stride argument must not specify a matrix view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>A column stride of zero may be used to define a matrix view
            where each column is filled with a constant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmputoffset">
      <title>vsip_<replaceable>d</replaceable>mputoffset_<replaceable>p</replaceable></title>

      <para>Put (Set) the offset attribute of a matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the offset (in elements) to the first scalar
            element of a matrix view, from the start of the block, to which it
            is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mputoffset_f(const vsip_mview_f *X, vsip_offset offset);
vsip_mview_i *vsip_mputoffset_i(const vsip_mview_i *X, vsip_offset offset);
vsip_mview_f *vsip_cmputoffset_f(const vsip_cmview_f *X, vsip_offset offset);
vsip_mview_i *vsip_cmputoffset_i(const vsip_cmview_i *X, vsip_offset offset);
vsip_mview_bl *vsip_mputoffset_bl(const vsip_mview_bl *X, vsip_offset offset);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>offset</term>

                <listitem>
                  <para>Offset in elements relative to the start of the block
                  object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source matrix view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The offset argument must not specify a matrix view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmputrowlength">
      <title>vsip_<replaceable>d</replaceable>mputrowlength_<replaceable>p</replaceable></title>

      <para>Put (Set) the row length attribute of a matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the length of (number of elements along) a row
            of a matrix view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mputrowlength_f(const vsip_mview_f *X, vsip_length length);
vsip_mview_i *vsip_mputrowlength_i(const vsip_mview_i *X, vsip_length length);
vsip_mview_f *vsip_cmputrowlength_f(const vsip_cmview_f *X, vsip_length length);
vsip_mview_i *vsip_cmputrowlength_i(const vsip_cmview_i *X, vsip_length length);
vsip_mview_bl *vsip_mputrowlength_bl(const vsip_mview_bl *X, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Row length in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source matrix view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The length argument must not specify a matrix view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmputrowstride">
      <title>vsip_<replaceable>d</replaceable>mputrowstride_<replaceable>p</replaceable></title>

      <para>Put (Set) the row stride attribute of a matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the stride (in elements of the bound block)
            between successive scalar elements along a row of a matrix
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mputrowstride_f(const vsip_mview_f *X, vsip_stride stride);
vsip_mview_i *vsip_mputrowstride_i(const vsip_mview_i *X, vsip_stride stride);
vsip_mview_f *vsip_cmputrowstride_f(const vsip_cmview_f *X, vsip_stride stride);
vsip_mview_i *vsip_cmputrowstride_i(const vsip_cmview_i *X, vsip_stride stride);
vsip_mview_bl *vsip_mputrowstride_bl(const vsip_mview_bl *X, vsip_stride stride);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Row stride in elements.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source matrix view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The stride argument must not specify a matrix view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>A row stride of zero may be used to define a matrix view
            where each column is filled with a constant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="mrealview">
      <title>vsip_mrealview_<replaceable>p</replaceable></title>

      <para>Create a matrix view object of the real part of a complex matrix
      from a complex matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real matrix view object from the “real part of a
            complex” matrix view object, or returns null if it fails.</para>

            <para>On success, the function creates a derived block object
            (derived from the complex block object). The derived block object
            is bound to the real data part of the original complex block and
            then binds a real matrix view object to the block. The new matrix
            encompasses the real part of the input complex matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mrealview_f(const vsip_cmview_f *X);
vsip_mview_i *vsip_mrealview_i(const vsip_cmview_i *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created “real” part matrix view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The derived block object, derived from the complex block
            object cannot be destroyed or released. The parent complex block
            object may be released (if it is bound to user data), and
            destroying the complex block is the only way to free the memory
            associated with the derived block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The complex matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure. This function should not be
            confused with the function
            vsip_sreal_<replaceable>p</replaceable>() which is a copy operator
            (copies the real data).</para>

            <para>There are no requirements on offset or stride of a real view
            on its derived block. By using
            vsip_mgetattrib_<replaceable>p</replaceable> information about the
            layout of the view on the block may be obtained.</para>

            <caution>
              <para>Using attribute information, and the block bound to the
              matrix, to bind new matrixes outside the data space of the
              original matrix produced by
              vsip_srealview_<replaceable>p</replaceable> will produce
              non-portable code. Portable code may be produced by: (1)
              remaining inside the data space of the matrix, (2) by not
              assuming a set relationship of strides and offsets, and (3) by
              using the get attributes functions to obtain necessary
              information within the application code to understand the layout
              for each implementation.</para>
            </caution>

            <para>Note to Implementors:</para>

            <itemizedlist>
              <listitem>
                <para>The resulting derived block must have a property which
                prevents it from being released or destroyed.</para>
              </listitem>

              <listitem>
                <para>In development mode, block binding count (reference
                count) recorded in the block object is incremented.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcolview"><function>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmdiagview"><function>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mimagview"><function>vsip_mimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmrowview"><function>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmsubview"><function>vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmtransview"><function>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></function></link>,
            and
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmrowview">
      <title>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></title>

      <para>Create a vector view object of a specified row of the source
      matrix view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a vector view object from a specified row of a
            matrix view object, or returns null if it fails. On success, it
            binds the new vector view object to the same block object as the
            source matrix view object and sets its attributes to view just the
            specified row of the source matrix object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_vview_f *vsip_mrowview_f(const vsip_mview_f *X, vsip_index row_index);
vsip_vview_i *vsip_mrowview_i(const vsip_mview_i *X, vsip_index row_index);
vsip_cvview_f *vsip_cmrowview_f(const vsip_cmview_f *X, vsip_index row_index);
vsip_cvview_i *vsip_cmrowview_i(const vsip_cmview_i *X, vsip_index row_index);
vsip_vview_bl *vsip_mrowview_bl(const vsip_mview_bl *X, vsip_index row_index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>row_index</term>

                <listitem>
                  <para>Row index of source matrix view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created row vector view object, or
            null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The requested row index must be a valid row index of the
                source matrix view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcolview"><function>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmdiagview"><function>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mimagview"><function>vsip_mimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mrealview"><function>vsip_mrealview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmsubview"><function>vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dmtransview"><function>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmsubview">
      <title>vsip_<replaceable>d</replaceable>msubview_<replaceable>p</replaceable></title>

      <para>Create a matrix view object that is a subview of matrix view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a matrix view object from a subview of a matrix
            view, or returns null if it fails. The subview is an M by N matrix
            view whose (0,0) element corresponds with the (row index, column
            index) element of the source matrix view.</para>

            <para>(The subview is relative to the source view, row stride and
            column stride are inherited from the source view).</para>

            <informalfigure>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/offset2.svg" format="svg"
                             scale="50"/>
                </imageobject>

                <imageobject>
                  <imagedata fileref="images/offset2.png" format="png"/>
                </imageobject>
              </mediaobject>
            </informalfigure>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_msubview_f(const vsip_mview_f *X,
                              vsip_index row_index, vsip_index col_index,
                              vsip_length M, vsip_length N);
vsip_mview_i *vsip_msubview_i(const vsip_mview_i *X,
                              vsip_index row_index, vsip_index col_index,
                              vsip_length M, vsip_length N);
vsip_cmview_f *vsip_cmsubview_f(const vsip_cmview_f *X,
                                vsip_index row_index, vsip_index col_index,
                                vsip_length M, vsip_length N);
vsip_cmview_i *vsip_cmsubview_i(const vsip_cmview_i *X,
                                vsip_index row_index, vsip_index col_index,
                                vsip_length M, vsip_length N);
vsip_mview_bl *vsip_msubview_bl(const vsip_mview_bl *X,
                                vsip_index row_index, vsip_index col_index,
                                vsip_length M, vsip_length N);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>row_index</term>

                <listitem>
                  <para>The index (row index, column index) of the source
                  matrix view object is mapped to the index (0,0) of the
                  submatrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>col_index</term>

                <listitem>
                  <para>The index (row index, column index) of the source
                  matrix view object is mapped to the index (0,0) of the
                  submatrix view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>M</term>

                <listitem>
                  <para>Number of rows of the matrix view (column
                  length).</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of columns of the matrix view (row
                  length).</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created subview matrix view object,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix index (row index, column index) must be a
                valid index of the matrix view.</para>
              </listitem>

              <listitem>
                <para>The subview must not extend beyond the bounds of the
                source matrix view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the function
            updates the binding count (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcolview"><function>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmdiagview"><function>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mimagview"><function>vsip_mimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mrealview"><function>vsip_mrealview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmrowview"><function>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmtransview"><function>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dmtransview">
      <title>vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></title>

      <para>Create a matrix view object that is the transpose of a matrix view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a matrix view object that provides a transposed view
            of a specified matrix view, or returns null if it fails. On
            success, it binds the new matrix view object to the same block
            object as the source matrix view object and sets its attributes to
            view the transpose of the source matrix object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_mview_f *vsip_mtransview_f(const vsip_mview_f *X);
vsip_mview_i *vsip_mtransview_i(const vsip_mview_i *X);
vsip_cmview_f *vsip_cmtransview_f(const vsip_cmview_f *X);
vsip_cmview_i *vsip_cmtransview_i(const vsip_cmview_i *X);
vsip_mview_bl *vsip_mtransview_bl(const vsip_mview_bl *X);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>X</term>

                <listitem>
                  <para>Source matrix view objects.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created transposed matrix view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>This should not be confused with the function
            vsip_<replaceable>d</replaceable>transpose_<replaceable>p</replaceable>()
            which transposes the underlying data of the matrix block object.
            Inner loop memory accesses are more efficient on most processors
            if they are accessing memory with small (unit) strides between
            memory elements. Use this information to guide the selection of
            transpose method.</para>

            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dmbind"><function>vsip_<replaceable>d</replaceable>mbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcloneview"><function>vsip_<replaceable>d</replaceable>mcloneview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmcolview"><function>vsip_<replaceable>d</replaceable>mcolview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmdiagview"><function>vsip_<replaceable>d</replaceable>mdiagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mimagview"><function>vsip_mimagview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="mrealview"><function>vsip_mrealview_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dmrowview"><function>vsip_<replaceable>d</replaceable>mrowview_<replaceable>p</replaceable></function></link>,
            and<link linkend="dmtransview"><function>
            vsip_<replaceable>d</replaceable>mtransview_<replaceable>p</replaceable></function></link>
            <link
            linkend="dmtrans"><function>vsip_<replaceable>d</replaceable>mtrans_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Tensor View Object Functions</title>

    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/tensor.svg" format="svg"/>
        </imageobject>

        <imageobject>
          <imagedata fileref="images/tensor.png" format="png"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>vsip_<replaceable>d</replaceable>talldestroy_<replaceable>p</replaceable></entry>

            <entry>Destroy Tensor And Block</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tbind_<replaceable>p</replaceable></entry>

            <entry>Create and Bind a Tensor View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tcloneview_<replaceable>p</replaceable></entry>

            <entry>Create Tensor View Clone</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tcreate_<replaceable>p</replaceable></entry>

            <entry>Create Tensor</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tdestroy_<replaceable>p</replaceable></entry>

            <entry>Destroy Tensor View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tget_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Element</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetattrib_<replaceable>p</replaceable></entry>

            <entry>Tensor Get View Attributes</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetblock_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Block</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetoffset_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Offset</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetxlength_<replaceable>p</replaceable></entry>

            <entry>Tensor Get X Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetxstride_<replaceable>p</replaceable></entry>

            <entry>Tensor Get X Stride</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetylength_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Y Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetystride_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Y Stride</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetzlength_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Z Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tgetzstride_<replaceable>p</replaceable></entry>

            <entry>Tensor Get Z Stride</entry>
          </row>

          <row>
            <entry>vsip_timagview_<replaceable>p</replaceable></entry>

            <entry>Create Imaginary Tensor View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tmatrixview_<replaceable>p</replaceable></entry>

            <entry>Create Tensor Plane View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tput_<replaceable>p</replaceable></entry>

            <entry>Tensor Put Element</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputattrib_<replaceable>p</replaceable></entry>

            <entry>Tensor Put View Attributes</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputoffset_<replaceable>p</replaceable></entry>

            <entry>Tensor Put Offset</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputxlength_<replaceable>p</replaceable></entry>

            <entry>Tensor Put X Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputxstride_<replaceable>p</replaceable></entry>

            <entry>Tensor Put X Stride</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputylength_<replaceable>p</replaceable></entry>

            <entry>Tensor Put Y Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputystride_<replaceable>p</replaceable></entry>

            <entry>Tensor Put Y Stride</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputzlength_<replaceable>p</replaceable></entry>

            <entry>Tensor Put Z Length</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tputzstride_<replaceable>p</replaceable></entry>

            <entry>Tensor Put Z Stride</entry>
          </row>

          <row>
            <entry>vsip_trealview_<replaceable>p</replaceable></entry>

            <entry>Create Real Tensor View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tsubview_<replaceable>p</replaceable></entry>

            <entry>Create Sub-View Tensor View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>ttransview_<replaceable>p</replaceable></entry>

            <entry>Create Tensor Transposed View</entry>
          </row>

          <row>
            <entry>vsip_<replaceable>d</replaceable>tvectview_<replaceable>p</replaceable></entry>

            <entry>Create Tensor Vector View</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dtalldestroy">
      <title>vsip_<replaceable>d</replaceable>talldestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a tensor, its associated block, and any VSIPL data
      array bound to the block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Destroys (frees) a tensor view object, the block object to
            which it is bound, and any VSIPL data array. If T is a tensor of
            type
            <type>vsip_<replaceable>d</replaceable>tview_<replaceable>p</replaceable></type>,
            then
            <code>vsip_<replaceable>d</replaceable>talldestroy_<replaceable>p</replaceable>(T);</code>
            is equivalent to
            <code>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable>(vsip_<replaceable>d</replaceable>tdestroy_<replaceable>p</replaceable>(T);</code></para>

            <para>This is the complementary function to
            vsip_<replaceable>d</replaceable>tcreate_<replaceable>p</replaceable>
            and should only be used to destroy tensors that have only one view
            bound to the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_talldestroy_f(vsip_tview_f *T);
void vsip_ctalldestroy_f(vsip_ctview_f *T);
void vsip_talldestroy_i(vsip_tview_i *T);
void vsip_ctalldestroy_i(vsip_ctview_i *T);
void vsip_talldestroy_bl(vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid. An argument of
                null is not an error.</para>
              </listitem>

              <listitem>
                <para>The specified tensor view must be the only view
                bound.</para>
              </listitem>

              <listitem>
                <para>The tensor view must not be bound to a derived block
                (derived from a complex block).</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>

            <para>If the tensor view is bound to a derived block (derived from
            a complex block), the complex block must be destroyed to free the
            block and associated data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <function>vsip_<replaceable>d</replaceable>blockrelease_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockrebind_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockfind_<replaceable>p</replaceable></function>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtbind"><function>vsip_<replaceable>d</replaceable>tbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtcreate"><function>vsip_<replaceable>d</replaceable>tcreate_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dtdestroy"><function>vsip_<replaceable>d</replaceable>tdestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtbind">
      <title>vsip_<replaceable>d</replaceable>tbind_<replaceable>p</replaceable></title>

      <para>Bind a tensor view to a block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a tensor object or returns null if it fails. If the
            view create is successful, it: (1) binds the tensor view object to
            the block object; (2) sets the offset from the beginning of the
            data array to the beginning of the tensor, the stride between
            successive scalar elements along the Z, Y, and X axes, the number
            of scalar elements along the Z, Y, and X axes; (3) then returns a
            pointer to the created tensor view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tbind_f(const vsip_block_f *block, vsip_offset offset,
                           vsip_stride z_stride, vsip_length z_length,
                           vsip_stride y_stride, vsip_length y_length,
                           vsip_stride x_stride, vsip_length x_length);
vsip_tview_i *vsip_tbind_i(const vsip_block_i *block, vsip_offset offset,
                           vsip_stride z_stride, vsip_length z_length,
                           vsip_stride y_stride, vsip_length y_length,
                           vsip_stride x_stride, vsip_length x_length);
vsip_ctview_f *vsip_ctbind_f(const vsip_cblock_f *block, vsip_offset offset,
                             vsip_stride z_stride, vsip_length z_length,
                             vsip_stride y_stride, vsip_length y_length,
                             vsip_stride x_stride, vsip_length x_length);
vsip_ctview_i *vsip_ctbind_i(const vsip_cblock_i *block, vsip_offset offset,
                             vsip_stride z_stride, vsip_length z_length,
                             vsip_stride y_stride, vsip_length y_length,
                             vsip_stride x_stride, vsip_length x_length);
vsip_tview_bl *vsip_tbind_bl(const vsip_block_bl *block, vsip_offset offset,
                             vsip_stride z_stride, vsip_length z_length,
                             vsip_stride y_stride, vsip_length y_length,
                             vsip_stride x_stride, vsip_length x_length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>block</term>

                <listitem>
                  <para>Pointer to a block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>offset</term>

                <listitem>
                  <para>Tensor view offset in elements relative to the base of
                  block object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>z_stride</term>

                <listitem>
                  <para>Stride between successive elements along the Z
                  axis.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>z_length</term>

                <listitem>
                  <para>Length in elements along the Z axis.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y_stride</term>

                <listitem>
                  <para>Stride between successive elements along the Y
                  axis.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y_length</term>

                <listitem>
                  <para>Length in elements along the Y axis.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x_stride</term>

                <listitem>
                  <para>Stride between successive elements along the X
                  axis.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x_length</term>

                <listitem>
                  <para>Length in elements along the X axis.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created tensor view object, or null
            if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The block object must be valid.</para>
              </listitem>

              <listitem>
                <para>The offset must be less than the length of the block’s
                data array.</para>
              </listitem>

              <listitem>
                <para>The z length, z stride, y length, y stride, x length, x
                stride, and offset arguments must not specify a tensor view
                that exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the function
            updates the bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <function>vsip_<replaceable>d</replaceable>blockrelease_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockrebind_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockfind_<replaceable>p</replaceable></function>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtcreate"><function>vsip_<replaceable>d</replaceable>tcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtdestroy"><function>vsip_<replaceable>d</replaceable>tdestroy_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dtalldestroy"><function>vsip_<replaceable>d</replaceable>talldestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtcloneview">
      <title>vsip_<replaceable>d</replaceable>tcloneview_<replaceable>p</replaceable></title>

      <para>Create a clone of a tensor view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a new tensor view object, copies all of the
            attributes of the source tensor view object to the new tensor view
            object, and then bind the new tensor view object to the block
            object of the source tensor view object. This function returns
            null on a memory allocation (creation) failure; otherwise, it
            returns a pointer to the new tensor view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tcloneview_f(const vsip_tview_f *T);
vsip_ctview_f *vsip_ctcloneview_f(const vsip_ctview_f *T);
vsip_tview_i *vsip_tcloneview_i(const vsip_tview_i *T);
vsip_ctview_i *vsip_ctcloneview_i(const vsip_ctview_i *T);
vsip_tview_bl *vsip_tcloneview_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created tensor view object clone,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Note to Implementors: In development mode, it should also
            increment the number of bindings recorded in the
            vsip_<replaceable>d</replaceable>block_<replaceable>p</replaceable>
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtcreate">
      <title>vsip_<replaceable>d</replaceable>tcreate_<replaceable>p</replaceable></title>

      <para>Creates a block object and tensor view (object) of the
      block.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a block object with an P ,M ,N element VSIPL data
            array, it creates an P by M by N dense tensor view object and then
            binds the block object to it.</para>

            <para>The function</para>

            <programlisting>vsip_tview_<replaceable>p</replaceable> *vsip_tcreate_<replaceable>p</replaceable>(P, M, N, VSIP_TRAILING, hint);</programlisting>

            <para>returns the same result as</para>

            <programlisting>vsip_tbind_<replaceable>p</replaceable>(vsip_blockcreate_<replaceable>p</replaceable>(P*M*N, hint),(vsip_offset)0,
             (vsip_stride)M*N, (vsip_length)P,     /* Z stride, length */
             (vsip_stride)N, (vsip_length)M,       /* Y stride, length */
             (vsip_stride)1, (vsip_length)N);      /* X stride, length */</programlisting>

            <para>or</para>

            <programlisting>vsip_tview_<replaceable>p</replaceable> *vsip_tcreate_<replaceable>p</replaceable>(P, M, N, VSIP_LEADING, hint);</programlisting>

            <para>returns the same result as</para>

            <programlisting>vsip_tbind_<replaceable>p</replaceable>(vsip_blockcreate_<replaceable>p</replaceable>(P*M*N, hint),(vsip_offset)0,
             (vsip_stride)1, (vsip_length)P,       /* Z stride, length */
             (vsip_stride)P, (vsip_length)M,       /* Y stride, length */
             (vsip_stride)P*M, (vsip_length)N);    /* X stride, length */</programlisting>

            <para>except that
            <function>vsip_tcreate_<replaceable>p</replaceable></function>
            returns a null if
            <code>vsip_blockcreate_<replaceable>p</replaceable>(P*M*N,
            hint)</code> returns a null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tcreate_f(vsip_length P, vsip_length M, vsip_length N,
                             vsip_tmajor major, vsip_memory_hint hint);
vsip_tview_i *vsip_tcreate_i(vsip_length P, vsip_length M, vsip_length N,
                             vsip_tmajor major, vsip_memory_hint hint);
vsip_ctview_f *vsip_ctcreate_f(vsip_length P, vsip_length M, vsip_length N,
                               vsip_tmajor major, vsip_memory_hint hint);
vsip_ctview_i *vsip_ctcreate_i(vsip_length P, vsip_length M, vsip_length N,
                               vsip_tmajor major, vsip_memory_hint hint);
vsip_tview_bl *vsip_tcreate_bl(vsip_length P, vsip_length M, vsip_length N,
                               vsip_tmajor major, vsip_memory_hint hint);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>P</term>

                <listitem>
                  <para>Number of elements (Z length) along Z axis of a
                  tensor.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>M</term>

                <listitem>
                  <para>Number of elements (Y length) along Y axis of a
                  tensor.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of elements (X length) along X axis of a
                  tensor.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>major</term>

                <listitem>
                  <para>Trailing or leading index is the unit stride
                  direction.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>hint</term>

                <listitem>
                  <para>Memory hint</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created tensor view object, or null
            if it fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The lengths, P, M and N, must be greater than
                zero.</para>
              </listitem>

              <listitem>
                <para>The major memory direction must be a valid member of the
                vsip_tmajor enumeration.</para>
              </listitem>

              <listitem>
                <para>The memory hint must be a valid member of the
                vsip_memory_hint enumeration.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Note to Implementors: In development mode, it should also
            update the bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <function>vsip_<replaceable>d</replaceable>blockrelease_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockrebind_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockfind_<replaceable>p</replaceable></function>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtbind"><function>vsip_<replaceable>d</replaceable>tbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtdestroy"><function>vsip_<replaceable>d</replaceable>tdestroy_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dtalldestroy"><function>vsip_<replaceable>d</replaceable>talldestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtdestroy">
      <title>vsip_<replaceable>d</replaceable>tdestroy_<replaceable>p</replaceable></title>

      <para>Destroy (free) a tensor view object and return a pointer to the
      associated block object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Frees a tensor view object from the block object that it was
            bound to, destroys the tensor view object, and then returns a
            pointer to the block object. If the tensor view argument is null,
            it returns null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_f *vsip_tdestroy_f(vsip_tview_f *T);
vsip_cblock_f *vsip_ctdestroy_f(vsip_ctview_f *T);
vsip_block_i *vsip_tdestroy_i(vsip_tview_i *T);
vsip_cblock_i *vsip_ctdestroy_i(vsip_ctview_i *T);
vsip_block_bl *vsip_tdestroy_bl(vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the block object to which the tensor
            view was bound, or null if the calling argument was null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid. An argument of
                null is not an error.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An argument of null is not an error.</para>

            <para>Note to Implementors: In development mode, the function
            updates bindings (reference count) recorded in the block
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><link
            linkend="dblockcreate"><function>vsip_<replaceable>d</replaceable>blockcreate_<replaceable>p</replaceable></function></link>,
            <link
            linkend="blockbind"><function>vsip_<replaceable>d</replaceable>blockbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dblockadmit"><function>vsip_<replaceable>d</replaceable>blockadmit_<replaceable>p</replaceable></function></link>,
            <function>vsip_<replaceable>d</replaceable>blockrelease_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockrebind_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>blockfind_<replaceable>p</replaceable></function>,
            <link
            linkend="dblockdestroy"><function>vsip_<replaceable>d</replaceable>blockdestroy_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtbind"><function>vsip_<replaceable>d</replaceable>tbind_<replaceable>p</replaceable></function></link>,
            <link
            linkend="dtcreate"><function>vsip_<replaceable>d</replaceable>tcreate_<replaceable>p</replaceable></function></link>,
            and <link
            linkend="dtalldestroy"><function>vsip_<replaceable>d</replaceable>talldestroy_<replaceable>p</replaceable></function></link></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtget">
      <title>vsip_<replaceable>d</replaceable>tget_<replaceable>p</replaceable></title>

      <para>Get the value of a specified element of a tensor view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the value of the specified element of a tensor view
            object. Returns <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>x</m:mi>

                    <m:mi>h,i,j</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_tget_f(const vsip_tview_f *x,
                          vsip_index h, vsip_index i, vsip_index j);
vsip_cscalar_f vsip_ctget_f(const vsip_ctview_f *x,
                            vsip_index h, vsip_index i, vsip_index j);
vsip_scalar_i vsip_tget_i(const vsip_tview_i *x,
                          vsip_index h, vsip_index i, vsip_index j);
vsip_cscalar_i vsip_ctget_i(const vsip_ctview_i *x,
                            vsip_index h, vsip_index i, vsip_index j);
vsip_scalar_bl vsip_tget_bl(const vsip_tview_bl *x,
                            vsip_index h, vsip_index i, vsip_index j);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Tensor view object</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>h</term>

                <listitem>
                  <para>Tensor index h of (h, i, j)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>i</term>

                <listitem>
                  <para>Tensor index i of (h, i, j)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Tensor index j of (h, i, j)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the specified element of a Tensor view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must be a valid index of the tensor
                view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable><replaceable>s</replaceable>put_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetattrib">
      <title>vsip_<replaceable>d</replaceable>tgetattrib_<replaceable>p</replaceable></title>

      <para>Get the attributes of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Retrieves the attributes: offset, Z length, Z stride, Y
            length, Y stride, X length, X stride, and (pointer to) bound block
            object of a tensor view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>
typedef struct 
{
  vsip_offset offset;
  vsip_stride z_length;
  vsip_length z_stride;
  vsip_stride y_length;
  vsip_length y_stride;
  vsip_stride x_length;
  vsip_length x_stride;
  vsip_block_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_tattr_<replaceable>p</replaceable>;
typedef struct 
{
  vsip_offset offset;
  vsip_stride z_length;
  vsip_length z_stride;
  vsip_stride y_length;
  vsip_length y_stride;
  vsip_stride x_length;
  vsip_length x_stride;
  vsip_cblock_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_ctattr_<replaceable>p</replaceable>;

void vsip_tgetattrib_f(const vsip_tview_f *T, vsip_tattr_f *attrib);
void vsip_tgetattrib_i(const vsip_tview_i *T, vsip_tattr_i *attrib);
void vsip_tgetattrib_bl(const vsip_tview_bl *T, vsip_tattr_bl *attrib);
void vsip_ctgetattrib_f(const vsip_ctview_f *T, vsip_ctattr_f *attrib);
void vsip_ctgetattrib_i(const vsip_ctview_i *T, vsip_ctattr_i *attrib);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attrib</term>

                <listitem>
                  <para>Pointer to output tensor attribute structure.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the tensor attribute structure must be
                valid – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The block attribute can be read (get), but cannot be
            set.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetblock">
      <title>vsip_<replaceable>d</replaceable>tgetblock_<replaceable>p</replaceable></title>

      <para>Get the block attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns a pointer to the VSIPL block object to which the
            tensor view object is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_block_f *vsip_tgetblock_f(const vsip_tview_f *T);
vsip_cblock_f *vsip_ctgetblock_f(const vsip_ctview_f *T);
vsip_block_i *vsip_tgetblock_i(const vsip_tview_i *T);
vsip_cblock_i *vsip_ctgetblock_i(const vsip_ctview_i *T);
vsip_block_bl *vsip_tgetblock_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the block object to which the tensor
            view object is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The functions
            vsip_<replaceable>d</replaceable>vgetattrib_<replaceable>p</replaceable>
            and
            vsip_<replaceable>d</replaceable>vputattrib_<replaceable>p</replaceable>
            are not symmetric since you can get the block object but you
            cannot put the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetoffset">
      <title>vsip_<replaceable>d</replaceable>tgetoffset_<replaceable>p</replaceable></title>

      <para>Get the offset attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the offset (in elements) to the first scalar element
            of a tensor view from the start of the block object to which it is
            bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_offset vsip_tgetoffset_f(const vsip_tview_f *T);
vsip_offset vsip_ctgetoffset_f(const vsip_ctview_f *T);
vsip_offset vsip_tgetoffset_i(const vsip_tview_i *T);
vsip_offset vsip_ctgetoffset_i(const vsip_ctview_i *T);
vsip_offset vsip_tgetoffset_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the offset attribute of the tensor view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetxlength">
      <title>vsip_<replaceable>d</replaceable>tgetxlength_<replaceable>p</replaceable></title>

      <para>Get the X length attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the length of (number of elements along) the X axis
            of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_tgetxlength_f(const vsip_tview_f *T);
vsip_length vsip_ctgetxlength_f(const vsip_ctview_f *T);
vsip_length vsip_tgetxlength_i(const vsip_tview_i *T);
vsip_length vsip_ctgetxlength_i(const vsip_ctview_i *T);
vsip_length vsip_tgetxlength_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the X length attribute of the tensor
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetxstride">
      <title>vsip_<replaceable>d</replaceable>tgetxstride_<replaceable>p</replaceable></title>

      <para>Get the X stride attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the stride (in elements of the bound block) between
            successive elements along the X axis of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_stride vsip_tgetxstride_f(const vsip_tview_f *T);
vsip_stride vsip_ctgetxstride_f(const vsip_ctview_f *T);
vsip_stride vsip_tgetxstride_i(const vsip_tview_i *T);
vsip_stride vsip_ctgetxstride_i(const vsip_ctview_i *T);
vsip_stride vsip_tgetxstride_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the X stride attribute of the tensor
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetylength">
      <title>vsip_<replaceable>d</replaceable>tgetylength_<replaceable>p</replaceable></title>

      <para>Get the Y length attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the length of (number of elements along) the Y axis
            of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_tgetylength_f(const vsip_tview_f *T);
vsip_length vsip_ctgetylength_f(const vsip_ctview_f *T);
vsip_length vsip_tgetylength_i(const vsip_tview_i *T);
vsip_length vsip_ctgetylength_i(const vsip_ctview_i *T);
vsip_length vsip_tgetylength_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the Y length attribute of the tensor
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetystride">
      <title>vsip_<replaceable>d</replaceable>tgetystride_<replaceable>p</replaceable></title>

      <para>Get the Y stride attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the stride (in elements of the bound block) between
            successive elements along the Y axis of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_stride vsip_tgetystride_f(const vsip_tview_f *T);
vsip_stride vsip_ctgetystride_f(const vsip_ctview_f *T);
vsip_stride vsip_tgetystride_i(const vsip_tview_i *T);
vsip_stride vsip_ctgetystride_i(const vsip_ctview_i *T);
vsip_stride vsip_tgetystride_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the Y stride attribute of the tensor
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetzlength">
      <title>vsip_<replaceable>d</replaceable>tgetzlength_<replaceable>p</replaceable></title>

      <para>Get the Z length attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the length of (number of elements along) the Z axis
            of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_tgetzlength_f(const vsip_tview_f *T);
vsip_length vsip_ctgetzlength_f(const vsip_ctview_f *T);
vsip_length vsip_tgetzlength_i(const vsip_tview_i *T);
vsip_length vsip_ctgetzlength_i(const vsip_ctview_i *T);
vsip_length vsip_tgetzlength_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the Z length attribute of the tensor
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtgetzstride">
      <title>vsip_<replaceable>d</replaceable>tgetzstride_<replaceable>p</replaceable></title>

      <para>Get the Z stride attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns the stride (in elements of the bound block) between
            successive elements along the Z axis of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_stride vsip_tgetzstride_f(const vsip_tview_f *T);
vsip_stride vsip_ctgetzstride_f(const vsip_ctview_f *T);
vsip_stride vsip_tgetzstride_i(const vsip_tview_i *T);
vsip_stride vsip_ctgetzstride_i(const vsip_ctview_i *T);
vsip_stride vsip_tgetzstride_bl(const vsip_tview_bl *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns the value of the Z stride attribute of the tensor
            view object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtimagview">
      <title>vsip_timagview_<replaceable>p</replaceable></title>

      <para>Create a tensor view object of the imaginary part of a complex
      tensor from a complex tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real tensor view object from the “imaginary part
            of a complex” tensor view object, or returns null if it
            fails.</para>

            <para>On success, the function creates a derived block object,
            derived from the complex block object, which is bound to the
            imaginary data part of the original complex block and then binds a
            real tensor view object to the block. The new tensor encompasses
            the imaginary part of the source complex tensor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_timagview_f(const vsip_ctview_f *T);
vsip_tview_i *vsip_timagview_i(const vsip_ctview_i *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created “imaginary” part tensor
            view object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The derived block object, derived from the complex block
            object cannot be destroyed or released. The parent complex block
            object may be released (if it is bound to user data), and
            destroying the complex block is the only way to free the memory
            associated with the derived block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The complex tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure. This function should not be
            confused with the function
            vsip_simag_<replaceable>p</replaceable>() which is a copy operator
            (copies the imaginary data).</para>

            <para>There are no requirements on offset or stride of a real view
            on its derived block. By using
            vsip_tgetattrib_<replaceable>p</replaceable>, information about
            the layout of the view on the block may be obtained.</para>

            <caution>
              <para>Using attribute information, and the block bound to the
              tensor, to bind new tensors outside the data space of the
              original tensor produced by
              vsip_simagview_<replaceable>p</replaceable> will produce
              non-portable code. Portable code may be produced by: (1)
              remaining inside the data space of the tensor, (2) by not
              assuming a set relationship of strides and offsets, and (3) by
              using the get attributes functions to obtain necessary
              information within the application code to understand the layout
              for each implementation.</para>
            </caution>

            <para>Note to Implementors:<itemizedlist>
                <listitem>
                  <para>The resulting derived block must have a property which
                  prevents it from being released or destroyed.</para>
                </listitem>

                <listitem>
                  <para>In development mode, block binding count (reference
                  count) recorded in the block object is incremented.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtmatrixview">
      <title>vsip_<replaceable>d</replaceable>tmatrixview_<replaceable>p</replaceable></title>

      <para>Create a matrix view of a 2-D slice of the tensor view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a matrix view object of a 2-D slice of the tensor
            view. The 2-D slice, or plane, is specified to be one of Y-X, Z-X,
            or Z-Y planes at a specified index along the remaining
            axis.</para>

            <informalequation>
              <m:math display="block">
                <m:mtable columnalign="left">
                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>M</m:mi>

                          <m:mi>*,*</m:mi>
                        </m:msub>

                        <m:mo>=</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>i,*,*</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Y-X Submatrix</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>M</m:mi>

                          <m:mi>*,*</m:mi>
                        </m:msub>

                        <m:mo>=</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>*,i,*</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Z-X Submatrix</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>M</m:mi>

                          <m:mi>*,*</m:mi>
                        </m:msub>

                        <m:mo>=</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>*,*,i</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Z-Y Submatrix</m:mtext>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>
              </m:math>
            </informalequation>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_TMYX = 0, // Y-X Submatrix
  VSIP_TMZX = 1, // Z-X Submatrix
  VSIP_TMZY = 2  // Z-Y Submatrix
} vsip_tmslice;

vsip_mview_f *vsip_tmatrixview_f(const vsip_tview_f *T,
                                 vsip_tmslice slice, vsip_index i);
vsip_mview_i *vsip_tmatrixview_i(const vsip_tview_i *T,
                                 vsip_tmslice slice, vsip_index i);
vsip_cmview_f *vsip_ctmatrixview_f(const vsip_ctview_f *T,
                                   vsip_tmslice slice, vsip_index i);
vsip_cmview_i *vsip_ctmatrixview_i(const vsip_ctview_i *T,
                                   vsip_tmslice slice, vsip_index i);
vsip_mview_bl *vsip_tmatrixview_bl(const vsip_tview_bl *T,
                                   vsip_tmslice slice, vsip_index i);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>slice</term>

                <listitem>
                  <para>slice of the tensor.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>i</term>

                <listitem>
                  <para>Index of the axis normal to the slice.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created matrix view object, or null
            if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The slice must be a valid member of the vsip_tmslice
                enumeration.</para>
              </listitem>

              <listitem>
                <para>The index, i, must be a valid index of the appropriate
                axis of the tensor view object.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the block binding
            count (reference count) recorded in the block object is
            incremented.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtput">
      <title>vsip_<replaceable>d</replaceable>tput_<replaceable>p</replaceable></title>

      <para>Put (Set) the value of a specified element of a tensor view
      object</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the value of the specified element of a tensor
            view object.</para>

            <informalequation>
              <m:math display="block">
                <m:mrow>
                  <m:msub>
                    <m:mi>y</m:mi>

                    <m:mi>h,i,j</m:mi>
                  </m:msub>

                  <m:mo>←</m:mo>

                  <m:mi>x</m:mi>
                </m:mrow>
              </m:math>
            </informalequation>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_tput_f(const vsip_tview_f *y,
                 vsip_index h, vsip_index i, vsip_index j,
                 vsip_scalar_f x);
void vsip_ctput_f(const vsip_ctview_f *y,
                  vsip_index h, vsip_index i, vsip_index j,
                  vsip_cscalar_f x);
void vsip_tput_i(const vsip_tview_i *y,
                 vsip_index h, vsip_index i, vsip_index j,
                 vsip_scalar_i x);
void vsip_ctput_i(const vsip_ctview_i *y,
                  vsip_index h, vsip_index i, vsip_index j,
                  vsip_cscalar_i x);
void vsip_tput_bl(const vsip_tview_bl *y,
                  vsip_index h, vsip_index i, vsip_index j,
                  vsip_scalar_bl x);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Tensor view object of destination.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>h</term>

                <listitem>
                  <para>Tensor index h of (h, i, j)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>i</term>

                <listitem>
                  <para>Tensor index i of (h, i, j)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Tensor index j of (h, i, j)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Scalar value to put in tensor.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The index must be a valid index of the tensor
                view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable><replaceable>s</replaceable>get_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputattrib">
      <title>vsip_<replaceable>d</replaceable>tputattrib_<replaceable>p</replaceable></title>

      <para>Put (Set) the attributes of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Sets the attributes of offset, Z length, Z stride, Y length,
            Y stride, X length, and X stride of a tensor view object. As a
            programmer convenience, it returns a pointer to the tensor view
            object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef struct 
{
  vsip_offset offset;
  vsip_stride z_length;
  vsip_length z_stride;
  vsip_stride y_length;
  vsip_length y_stride;
  vsip_stride x_length;
  vsip_length x_stride;
  vsip_block_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_tattr_<replaceable>p</replaceable>;
typedef struct 
{
  vsip_offset offset;
  vsip_stride z_length;
  vsip_length z_stride;
  vsip_stride y_length;
  vsip_length y_stride;
  vsip_stride x_length;
  vsip_length x_stride;
  vsip_cblock_<replaceable>p</replaceable> *block; /* Get only, ignored on Put */
} vsip_ctattr_<replaceable>p</replaceable>;

vsip_tview_f *vsip_tputattrib_f(vsip_tview_f *T, const vsip_tattr_f *attrib);
vsip_tview_i *vsip_tputattrib_i(vsip_tview_i *T, const vsip_tattr_i *attrib);
vsip_tview_bl *vsip_tputattrib_bl(vsip_tview_bl *T, const vsip_tattr_bl *attrib);
vsip_ctview_f *vsip_ctputattrib_f(vsip_ctview_f *T, const vsip_ctattr_f *attrib);
vsip_ctview_i *vsip_ctputattrib_i(vsip_ctview_i *T, const vsip_ctattr_i *attrib);
vsip_ctview_bl *vsip_ctputattrib_bl(vsip_ctview_bl *T, const vsip_tattr_bl *attrib);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>attrib</term>

                <listitem>
                  <para>Pointer to a tensor attribute structure</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the tensor attribute structure must be
                valid – non-null.</para>
              </listitem>

              <listitem>
                <para>The z length, z stride, y length, y stride, x length, x
                stride, and offset arguments must not specify a tensor view
                that exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The functions
            <function>vsip_tgetattrib_<replaceable>p</replaceable></function>
            and<function>
            vsip_tputattrib_<replaceable>p</replaceable></function> are not
            symmetric since you can “get” the block object but you cannot
            “put” the block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputoffset">
      <title>vsip_<replaceable>d</replaceable>tputoffset_<replaceable>p</replaceable></title>

      <para>Put (Set) the offset attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the offset (in elements) to the first scalar
            element of a tensor view, from the start of the block object’s
            data array, to which it is bound.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tputoffset_f(vsip_tview_f *T, vsip_offset offset);
vsip_ctview_f *vsip_ctputoffset_f(vsip_ctview_f *T, vsip_offset offset);
vsip_tview_i *vsip_tputoffset_i(vsip_tview_i *T, vsip_offset offset);
vsip_ctview_i *vsip_ctputoffset_i(vsip_ctview_i *T, vsip_offset offset);
vsip_tview_bl *vsip_tputoffset_bl(vsip_tview_bl *T, vsip_offset offset);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>offset</term>

                <listitem>
                  <para>Offset in elements relative to the start of the block
                  object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The offset argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputxlength">
      <title>vsip_<replaceable>d</replaceable>tputxlength_<replaceable>p</replaceable></title>

      <para>Put (Set) the X length attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the length of (number of elements along) the X
            axis of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_<replaceable>p</replaceable> *vsip_tputxlength_<replaceable>p</replaceable>(vsip_tview_<replaceable>p</replaceable> *T, vsip_length length);
vsip_ctview_<replaceable>p</replaceable> *vsip_ctputxlength_<replaceable>p</replaceable>(vsip_ctview_<replaceable>p</replaceable> *T, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Length of the X axis</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The length argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputxstride">
      <title>vsip_<replaceable>d</replaceable>tputxstride_<replaceable>p</replaceable></title>

      <para>Put (Set) the X stride attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the stride (in elements of the bound block)
            between successive elements along the X axis of a tensor
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tputxstride_f(vsip_tview_f *T, vsip_stride stride);
vsip_ctview_f *vsip_ctputxstride_f(vsip_ctview_f *T, vsip_stride stride);
vsip_tview_i *vsip_tputxstride_i(vsip_tview_i *T, vsip_stride stride);
vsip_ctview_i *vsip_ctputxstride_i(vsip_ctview_i *T, vsip_stride stride);
vsip_tview_bl *vsip_tputxstride_bl(vsip_tview_bl *T, vsip_stride stride);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>stride</term>

                <listitem>
                  <para>Stride in elements between successive elements along
                  the X axis.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The stride argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>An X stride of zero may be used to define a tensor view
            where each Z-Y slice is filled with a constant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputylength">
      <title>vsip_<replaceable>d</replaceable>tputylength_<replaceable>p</replaceable></title>

      <para>Put (Set) the Y length attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the length of (number of elements along) the Y
            axis of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tputylength_f(vsip_tview_f *T, vsip_length length);
vsip_ctview_f *vsip_ctputylength_f(vsip_ctview_f *T, vsip_length length);
vsip_tview_i *vsip_tputylength_i(vsip_tview_i *T, vsip_length length);
vsip_ctview_i *vsip_ctputylength_i(vsip_ctview_i *T, vsip_length length);
vsip_tview_bl *vsip_tputylength_bl(vsip_tview_bl *T, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Length of the Y axis.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The length argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputystride">
      <title>vsip_<replaceable>d</replaceable>tputystride_<replaceable>p</replaceable></title>

      <para>Put (Set) the Y stride attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the stride (in elements of the bound block)
            between successive elements along the Y axis of a tensor
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tputystride_f(vsip_tview_f *T, vsip_stride stride);
vsip_ctview_f *vsip_ctputystride_f(vsip_ctview_f *T, vsip_stride stride);
vsip_tview_i *vsip_tputystride_i(vsip_tview_i *T, vsip_stride stride);
vsip_ctview_i *vsip_ctputystride_i(vsip_ctview_i *T, vsip_stride stride);
vsip_tview_bl *vsip_tputystride_bl(vsip_tview_bl *T, vsip_stride stride);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>stride</term>

                <listitem>
                  <para>Stride in elements between successive elements along
                  the Y axis.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The stride argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>A Y stride of zero may be used to define a tensor view where
            each Z-X slice is filled with a constant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputzlength">
      <title>vsip_<replaceable>d</replaceable>tputzlength_<replaceable>p</replaceable></title>

      <para>Put (Set) the Z length attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the length of (number of elements along) the Z
            axis of a tensor view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tputylength_f(vsip_tview_f *T, vsip_length length);
vsip_ctview_f *vsip_ctputylength_f(vsip_ctview_f *T, vsip_length length);
vsip_tview_i *vsip_tputylength_i(vsip_tview_i *T, vsip_length length);
vsip_ctview_i *vsip_ctputylength_i(vsip_ctview_i *T, vsip_length length);
vsip_tview_bl *vsip_tputylength_bl(vsip_tview_bl *T, vsip_length length);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>length</term>

                <listitem>
                  <para>Length of the Z axis.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The length must be greater than zero.</para>
              </listitem>

              <listitem>
                <para>The length argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtputzstride">
      <title>vsip_<replaceable>d</replaceable>tputzstride_<replaceable>p</replaceable></title>

      <para>Put (Set) the Z stride attribute of a tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Puts (sets) the stride (in elements of the bound block)
            between successive elements along the Z axis of a tensor
            view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tputzstride_f(vsip_tview_f *T, vsip_stride stride);
vsip_ctview_f *vsip_ctputzstride_f(vsip_ctview_f *T, vsip_stride stride);
vsip_tview_i *vsip_tputzstride_i(vsip_tview_i *T, vsip_stride stride);
vsip_ctview_i *vsip_ctputzstride_i(vsip_ctview_i *T, vsip_stride stride);
vsip_tview_bl *vsip_tputzstride_bl(vsip_tview_bl *T, vsip_stride stride);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>stride</term>

                <listitem>
                  <para>Stride in elements between successive elements along
                  the Z axis.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the source tensor view object as a
            programming convenience.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The stride argument must not specify a tensor view that
                exceeds the bounds of the data array of the associated
                block.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>A Z stride of zero may be used to define a tensor view where
            each Y-X slice is filled with a constant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="trealview">
      <title>vsip_trealview_<replaceable>p</replaceable></title>

      <para>Create a tensor view object of the real part of a complex tensor
      from a complex tensor view object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a real tensor view object from the “real part of a
            complex” tensor view object, or returns null if it fails.</para>

            <para>On success, the function creates a derived block object
            (derived from the complex block object). The derived block object
            is bound to the real data part of the original complex block and
            then binds a real tensor view object to the block. The new tensor
            encompasses the real part of the input complex tensor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_trealview_f(const vsip_ctview_f *T);
vsip_tview_i *vsip_trealview_i(const vsip_ctview_i *T);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created “real” part tensor view
            object, or null if the memory allocation for new object
            fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The derived block object, derived from the complex block
            object cannot be destroyed or released. The parent complex block
            object may be released (if it is bound to user data), and
            destroying the complex block is the only way to free the memory
            associated with the derived block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The complex tensor view object must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>This function should not be confused with the function
            <code>vsip_sreal_<replaceable>p</replaceable>()</code> which is a
            copy operator (copies the real data).</para>

            <para>There are no requirements on offset or stride of a real view
            on its derived block. By using
            <function>vsip_tgetattrib_<replaceable>p</replaceable></function>,
            information about the layout of the view on the block may be
            obtained.</para>

            <caution>
              <para>Using attribute information, and the block bound to the
              tensor, to bind new tensors outside the data space of the
              original tensor produced by
              vsip_srealview_<replaceable>p</replaceable> will produce
              non-portable code. Portable code may be produced by: (1)
              remaining inside the data space of the tensor, (2) by not
              assuming a set relationship of strides and offsets, and (3) by
              using the get attributes functions to obtain necessary
              information within the application code to understand the layout
              for each implementation.</para>
            </caution>

            <para>Note to Implementors:</para>

            <itemizedlist>
              <listitem>
                <para>The resulting derived block must have a property which
                prevents it from being released or destroyed.</para>
              </listitem>

              <listitem>
                <para>In development mode, block binding count (reference
                count) recorded in the block object is incremented.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtsubview">
      <title>vsip_<replaceable>d</replaceable>tsubview_<replaceable>p</replaceable></title>

      <para>Create a tensor view object that is a subview of tensor view
      object.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a tensor view object from a subview of a tensor
            view, or returns null if it fails. The subview is a P by M by N
            tensor view whose (0,0,0) element corresponds with the (Z index, Y
            index, X index) element of the source tensor view.</para>

            <para>(The subview is relative to the source view, Z stride, Y
            stride, and X strides are inherited from the source view).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_tview_f *vsip_tsubview_f(const vsip_tview_f *T,
                              vsip_index z, vsip_index y, vsip_index x,
                              vsip_length P, vsip_length M, vsip_length N);
vsip_ctview_f *vsip_ctsubview_f(const vsip_ctview_f *T,
                                vsip_index z, vsip_index y, vsip_index x,
                                vsip_length P, vsip_length M, vsip_length N);
vsip_tview_i *vsip_tsubview_i(const vsip_tview_i *T,
                              vsip_index z, vsip_index y, vsip_index x,
                              vsip_length P, vsip_length M, vsip_length N);
vsip_ctview_i *vsip_ctsubview_i(const vsip_ctview_i *T,
                                vsip_index z, vsip_index y, vsip_index x,
                                vsip_length P, vsip_length M, vsip_length N);
vsip_tview_bl *vsip_tsubview_bl(const vsip_tview_bl *T,
                                vsip_index z, vsip_index y, vsip_index x,
                                vsip_length P, vsip_length M, vsip_length N);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>z</term>

                <listitem>
                  <para>The index (Z index, Y index, X index) of the source
                  matrix view object is mapped to the index (0,0,0) of the
                  subview tensor object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>The index (Z index, Y index, X index) of the source
                  matrix view object is mapped to the index (0,0,0) of the
                  subview tensor object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>The index (Z index, Y index, X index) of the source
                  matrix view object is mapped to the index (0,0,0) of the
                  subview tensor object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>P</term>

                <listitem>
                  <para>Number of elements (Z length) along Z axis of tensor
                  subview.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>M</term>

                <listitem>
                  <para>Number of elements (Y length) along Y axis of tensor
                  subview.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>N</term>

                <listitem>
                  <para>Number of elements (X length) along X axis of tensor
                  subview.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created subview tensor view object,
            or null if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The matrix view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The matrix index (Z index, Y index, X index) must be a
                valid index of the tensor view.</para>
              </listitem>

              <listitem>
                <para>The subview must not extend beyond the bounds of the
                source tensor view.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, it should also
            increment the number of bindings (reference count) recorded in the
            block object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dttransview">
      <title>vsip_<replaceable>d</replaceable>ttransview_<replaceable>p</replaceable></title>

      <para>Create a transposed tensor view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a tensor view object that provides a transposed view
            of a specified tensor view, or returns null if it fails. On
            success, it binds the new tensor view object to the same block
            object as the source tensor view object and sets its attributes to
            view the transpose of the source tensor object.</para>

            <informalequation>
              <m:math display="block">
                <m:mtable>
                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>No-transpose</m:mtext>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>VSIP_TTRANS_NOP</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,j,i</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Y-X transpose</m:mtext>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>VSIP_TTRANS_YX</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>i,h,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Z-Y transpose</m:mtext>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>VSIP_TTRANS_ZY</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>j,i,h</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Z-X transpose</m:mtext>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>VSIP_TTRANS_ZX</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>i,j,h</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Y-X &amp; Z-Y transpose</m:mtext>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>VSIP_TTRANS_YXZY</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>h,i,j</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>j,h,i</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Y-X &amp; Z-X transpose</m:mtext>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>VSIP_TTRANS_YXZX</m:mtext>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>
              </m:math>
            </informalequation>

            <para>Where “*” denotes the set of all valid indices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_TTRANS_NOP = 0,  /* No transpose */
  VSIP_TTRANS_YX = 1,   /* Y – X transpose */
  VSIP_TTRANS_ZY = 2,   /* Z – Y transpose */
  VSIP_TTRANS_ZX = 3,   /* Z – X transpose */
  VSIP_TTRANS_YXZY = 4, /* Y – X &amp; Z – Y transpose */
  VSIP_TTRANS_YXZX = 5  /* Y – X &amp; Z – X transpose */
} vsip_ttrans;

vsip_tview_f *vsip_ttransview_f(const vsip_tview_f *T, vsip_ttrans trans);
vsip_tview_i *vsip_ttransview_i(const vsip_tview_i *T, vsip_ttrans trans);
vsip_ctview_f *vsip_cttransview_f(const vsip_ctview_f *T, vsip_ttrans trans);
vsip_ctview_i *vsip_cttransview_i(const vsip_ctview_i *T, vsip_ttrans trans);
vsip_tview_bl *vsip_ttransview_bl(const vsip_tview_bl *T, vsip_ttrans trans);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>trans</term>

                <listitem>
                  <para>Specifies transpose type.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created tensor view object, or null
            if the create fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The transpose type must be a valid member of the
                vsip_ttrans enumeration.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dtvecview">
      <title>vsip_<replaceable>d</replaceable>tvectview_<replaceable>p</replaceable></title>

      <para>Create a vector view of a 1-D slice of the tensor view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Creates a vector view of a 1-D slice of the tensor view, or
            returns null if it fails. The 1-D slice is specified to be one of
            X, Y, or Z, at a specified index along the other axes.</para>

            <informalequation>
              <m:math display="block">
                <m:mtable columnalign="left">
                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>v</m:mi>

                          <m:mi>*</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>i,j,*</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>X Subvector</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>v</m:mi>

                          <m:mi>*</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>i,*,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Y Subvector</m:mtext>
                    </m:mtd>
                  </m:mtr>

                  <m:mtr>
                    <m:mtd>
                      <m:mrow>
                        <m:msub>
                          <m:mi>v</m:mi>

                          <m:mi>*</m:mi>
                        </m:msub>

                        <m:mo>←</m:mo>

                        <m:msub>
                          <m:mi>T</m:mi>

                          <m:mi>*,i,j</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mtd>

                    <m:mtd>
                      <m:mtext>Z Subvector</m:mtext>
                    </m:mtd>
                  </m:mtr>
                </m:mtable>
              </m:math>
            </informalequation>

            <para>Where “*” denotes the set of all valid indices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>typedef enum 
{
  VSIP_TVX = 0, /* X Subvector */
  VSIP_TVY = 1, /* Y Subvector */
  VSIP_TVZ = 2  /* Z Subvector */
} vsip_tvslice;

vsip_vview_f *vsip_tvectview_f(const vsip_tview_f *T, vsip_tvslice slice, 
                               vsip_index i, vsip_index j);
vsip_vview_i *vsip_tvectview_i(const vsip_tview_i *T, vsip_tvslice slice,
                               vsip_index i, vsip_index j);
vsip_cvview_f *vsip_ctvectview_f(const vsip_ctview_f *T, vsip_tvslice slice,
                                 vsip_index i, vsip_index j);
vsip_cvview_i *vsip_ctvectview_i(const vsip_ctview_i *T, vsip_tvslice slice,
                                 vsip_index i, vsip_index j);
vsip_vview_bl *vsip_tvectview_bl(const vsip_tview_bl *T, vsip_tvslice slice,
                                 vsip_index i, vsip_index j);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>T</term>

                <listitem>
                  <para>Tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>slice</term>

                <listitem>
                  <para>1-D slice is along the slice axis.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>i</term>

                <listitem>
                  <para>First fixed tensor index.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>Second fixed tensor index.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return Value</term>

          <listitem>
            <para>Returns a pointer to the created vector view object, or null
            if the memory allocation for new object fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The tensor view object must be valid.</para>
              </listitem>

              <listitem>
                <para>The slice must be valid member of the vsip_tvslice
                enumeration.</para>
              </listitem>

              <listitem>
                <para>The indices, i and j, must be valid indices of their
                appropriate axes of the tensor view object.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is important for the application to check the return
            value for a memory allocation failure.</para>

            <para>Note to Implementors: In development mode, the block binding
            count (reference count) recorded in the block object is
            incremented.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</chapter>
