<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="vector"
	 xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Vector &amp; Elementwise Operations</title>

  <section>
    <title>Introduction</title>

    <para>This section covers, for the most part, simple operations that are
    done on individual elements or corresponding pairs of elements of VSIPL
    objects. Historically this section started out as only pertaining to
    vector objects; however it was soon realized that, for instance, adding
    two vectors by element and adding two matrices by element, or taking a
    Sine or Cosine for each element of a vector or a matrix, are fundamentally
    the same. So the section was extended to cover as many elementwise
    operations as seemed reasonable without regard to the shape of the
    underlying object.</para>

    <section>
      <title>Name Space</title>

      <para>An attempt has been made to regularize the name space. For the
      root names the following contractions have been used. Not all the
      contractions used are here, but these are the most common</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>add</entry>

              <entry>a or add</entry>
            </row>

            <row>
              <entry>divide</entry>

              <entry>div</entry>
            </row>

            <row>
              <entry>equal</entry>

              <entry>e</entry>
            </row>

            <row>
              <entry>greater than</entry>

              <entry>g or gt</entry>
            </row>

            <row>
              <entry>less than</entry>

              <entry>l or lt</entry>
            </row>

            <row>
              <entry>logical</entry>

              <entry>l</entry>
            </row>

            <row>
              <entry>magnitude</entry>

              <entry>mg or mag</entry>
            </row>

            <row>
              <entry>maximum</entry>

              <entry>max</entry>
            </row>

            <row>
              <entry>minimum</entry>

              <entry>min</entry>
            </row>

            <row>
              <entry>multiply</entry>

              <entry>m or mul</entry>
            </row>

            <row>
              <entry>not equal</entry>

              <entry>ne</entry>
            </row>

            <row>
              <entry>root</entry>

              <entry>rt</entry>
            </row>

            <row>
              <entry>scalar</entry>

              <entry>s</entry>
            </row>

            <row>
              <entry>square</entry>

              <entry>sq</entry>
            </row>

            <row>
              <entry>subtract</entry>

              <entry>sb or sub</entry>
            </row>

            <row>
              <entry>value</entry>

              <entry>val</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <note>
        <para><itemizedlist>
            <listitem>
              <para>Magnitude has its normal meaning. For example for real we
              have <inlineequation>
                  <m:math display="inline">
                    <m:mrow>
                      <m:mi>a</m:mi>

                      <m:mo>⇔</m:mo>

                      <m:mrow>
                        <m:mrow>
                          <m:mo>|</m:mo>

                          <m:mi>a</m:mi>

                          <m:mo>|</m:mo>
                        </m:mrow>

                        <m:mo>=</m:mo>

                        <m:msqrt>
                          <m:msup>
                            <m:mi>x</m:mi>

                            <m:mn>2</m:mn>
                          </m:msup>
                        </m:msqrt>
                      </m:mrow>
                    </m:mrow>
                  </m:math>
                </inlineequation> and for Complex we have <inlineequation>
                  <m:math display="inline">
                    <m:mrow>
                      <m:mi>a</m:mi>

                      <m:mo>⇔</m:mo>

                      <m:mrow>
                        <m:mrow>
                          <m:mo>|</m:mo>

                          <m:mi>a</m:mi>

                          <m:mo>|</m:mo>
                        </m:mrow>

                        <m:mo>=</m:mo>

                        <m:msqrt>
                          <m:mrow>
                            <m:msup>
                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mi>Re</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:mi>a</m:mi>
                                  </m:mfenced>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>

                              <m:mn>2</m:mn>
                            </m:msup>

                            <m:mo>+</m:mo>

                            <m:msup>
                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mi>Im</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:mi>a</m:mi>
                                  </m:mfenced>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>

                              <m:mn>2</m:mn>
                            </m:msup>
                          </m:mrow>
                        </m:msqrt>
                      </m:mrow>
                    </m:mrow>
                  </m:math>
                </inlineequation> where the positive square root is
              used.</para>
            </listitem>

            <listitem>
              <para>Most functions which return a value and are not void will
              have a "val" contraction at the end of their root name. One of
              the exceptions are any functions which are typed as
              boolean.</para>
            </listitem>
          </itemizedlist></para>
      </note>
    </section>

    <section>
      <title>Root Names</title>

      <para>The following table contains all the root names for the
      elementwise operations. Using these roots, and the function name
      encoder, names may be derived for all the functions. The root names are
      in alphabetical order. Note that the root name may encompass some
      functionality that might otherwise be done using the function name
      encoder rules. For instance, the root arg used for finding the argument
      of a complex number has no depth associated with it since its classical
      definition encompasses the depth functionality. Some functions have
      purposely had some of the function name made part of the root name. For
      instance, cmagsq is only done on complex, so the c was made part of the
      root name. Moving function name encoder functionality into the root name
      can only be done if the functionality is degenerate over the name space
      of the function. For instance, cmagsq is only defined in VSIPL for
      complex inputs so the complex portion of the functionality may be made
      part of the root name since there is no need to include real input
      functionality.</para>

      <para>Note that some root names (such as add, mul, etc.) have more than
      one man page associated with them. This is because Scalar operations
      with Vectors (Matrices) are placed on a separate man page from
      Vector/matrix operations with Vectors (Matrices).</para>

      <para>It also should be noted that not every possible expansion of the
      function name, with root, are being included as VSIPL defined functions.
      This is a very large name space so only functionality which is
      considered as necessary and useful is being included. What is necessary
      and useful is an active area of debate and discussion.</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Root Name</entry>

              <entry align="center">Expansion</entry>

              <entry align="center">Associated Man Pages and Comments</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>acos</entry>

              <entry>Arccosine</entry>

              <entry><function>vsip_<replaceable>ds</replaceable>acos_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>add</entry>

              <entry>Add</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>add_<replaceable>p</replaceable></function>
              (Vector/Matrix add
              Vector/Matrix)</para><para><function>vsip_<replaceable>ds</replaceable>sadd_<replaceable>p</replaceable></function>
              (Scalar add Vector/Matrix) </para></entry>
            </row>

            <row>
              <entry>alltrue</entry>

              <entry>All True</entry>

              <entry><function>vsip_<replaceable>s</replaceable>alltrue_bl</function></entry>
            </row>

            <row>
              <entry>am</entry>

              <entry>Add and Multiply</entry>

              <entry><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>and</entry>

              <entry>AND</entry>

              <entry><function>vsip_<replaceable>s</replaceable>and_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>anytrue</entry>

              <entry>Any True</entry>

              <entry><function>vsip_<replaceable>s</replaceable>anytrue_bl</function></entry>
            </row>

            <row>
              <entry>arg</entry>

              <entry>Argument</entry>

              <entry><function>vsip_<replaceable>s</replaceable>arg_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>asin</entry>

              <entry>Arcsine</entry>

              <entry><function>vsip_<replaceable>ds</replaceable>asin_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>atan</entry>

              <entry>Arctangent</entry>

              <entry><function>vsip_<replaceable>ds</replaceable>atan_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>atan2</entry>

              <entry>Arctangent of Two Arguments</entry>

              <entry><function>vsip_<replaceable>ds</replaceable>atan2_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>conj</entry>

              <entry>Complex Conjugate</entry>

              <entry><function>vsip_<replaceable>s</replaceable>conj_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>clip</entry>

              <entry>Clip</entry>

              <entry><function>vsip_<replaceable>s</replaceable>clip_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cmagsq</entry>

              <entry>Complex Magnitude Squared</entry>

              <entry><function>vsip_<replaceable>s</replaceable>cmagsq_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cmaxmgsq</entry>

              <entry>Complex Max Magnitude Squared</entry>

              <entry><function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cmaxmgsqval</entry>

              <entry>Complex Max Mag Squared Value</entry>

              <entry><function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cminmgsq</entry>

              <entry>Complex Min Magnitude Squared</entry>

              <entry><function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cminmgsqval</entry>

              <entry>Complex Min Mag Squared Value</entry>

              <entry><function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cmplx</entry>

              <entry>Complex</entry>

              <entry><function>vsip_<replaceable>s</replaceable>cmplx_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cos</entry>

              <entry>Cosine</entry>

              <entry><function>vsip_<replaceable>ds</replaceable>cos_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>cosh</entry>

              <entry>Hyperbolic Cosine</entry>

              <entry><function>vsip_<replaceable>ds</replaceable>cosh_<replaceable>p</replaceable></function></entry>
            </row>

            <row>
              <entry>div</entry>

              <entry>Divide</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></function>
              (Vector/Matrix divide Vector/Matrix)
              </para><para><function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>div_<replaceable>p</replaceable></function>
              (Scalar divide Vector/Matrix)
              </para><para><function>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></function>
              (Vector/Matrix divide Scalar) </para></entry>
            </row>

            <row>
              <entry>euler</entry>

              <entry>Euler</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>euler_<replaceable>p</replaceable></function>
              (Vector/Matrix Euler)</para></entry>
            </row>

            <row>
              <entry>exp</entry>

              <entry>Exponential (Base e)</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>exp10</entry>

              <entry>Exponential (Base 10)</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>exp10_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>expoavg</entry>

              <entry>Exponential Average</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>expoavg_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>fill</entry>

              <entry>Fill</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>fill_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>gather</entry>

              <entry>Gather</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>gather</function></para></entry>
            </row>

            <row>
              <entry>hypot</entry>

              <entry>Hypotenuse</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>hypot_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>imag</entry>

              <entry>Imaginary</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>indexbool</entry>

              <entry>Index a Boolean</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>indexbool</function></para></entry>
            </row>

            <row>
              <entry>invclip</entry>

              <entry>Inverse Clip</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>invclip_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>jmul</entry>

              <entry>Conjugate Multiply</entry>

              <entry><para><function>vsip_c<replaceable>s</replaceable>jmul_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>leq</entry>

              <entry>Logical Equal</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>leq_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>lge</entry>

              <entry>Logical Greater Than or Equal</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>lge_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>lgt</entry>

              <entry>Logical Greater Than</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>lgt_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>lle</entry>

              <entry>Logical Less Than or Equal</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>lle_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>llt</entry>

              <entry>Logical Less Than</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>llt_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>lne</entry>

              <entry>Logical Not Equal</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>lne_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>log</entry>

              <entry>Log (Base e)</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>log_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>log10</entry>

              <entry>Log (Base 10)</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>log10_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>ma</entry>

              <entry>Multiply and Add</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>mag</entry>

              <entry>Magnitude</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>mag_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>max</entry>

              <entry>Maximum</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>maxmg</entry>

              <entry>Maximum Magnitude</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>maxmg_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>maxmgval</entry>

              <entry>Maximum Magnitude Value</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>maxval</entry>

              <entry>Maximum Value</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>meansqval</entry>

              <entry>Mean Square Value</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>meansqval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>meanval</entry>

              <entry>Mean Value</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>meanval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>min</entry>

              <entry>Minimum</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>minmg</entry>

              <entry>Minimum Magnitude</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>minmg_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>minmgval</entry>

              <entry>Minimum Magnitude Value</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>minval</entry>

              <entry>Minimum Value</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>msa</entry>

              <entry>Multiply, Scalar Add</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>msb</entry>

              <entry>Multiply and Subtract</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>mul</entry>

              <entry>Multiply</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>mul_<replaceable>p</replaceable></function>
              (Vector/Matrix multiply Vector/Matrix)
              </para><para><function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>mul_<replaceable>p</replaceable></function>
              (Scalar multiply Vector/Matrix)</para></entry>
            </row>

            <row>
              <entry>vmmul</entry>

              <entry>Vector Matrix Elementwise Multiply</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>v<replaceable>d</replaceable>mmul_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>neg</entry>

              <entry>Negate</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>neg_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>not</entry>

              <entry>NOT</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>not_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>or</entry>

              <entry>OR</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>or_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>polar</entry>

              <entry>Polar</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>ramp</entry>

              <entry>Ramp</entry>

              <entry><para><function>vsip_vramp_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>real</entry>

              <entry>Real</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>recip</entry>

              <entry>Reciprocal</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>recip_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>rect</entry>

              <entry>Rectangular</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>rect_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>rsqrt</entry>

              <entry>Reciprocal Square Root</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>rsqrt_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sam</entry>

              <entry>Scalar Add, Multiply</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sbm</entry>

              <entry>Subtract and Multiply</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>scatter</entry>

              <entry>Scatter</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>scatter_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sin</entry>

              <entry>Sine</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sin_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sinh</entry>

              <entry>Hyperbolic Sine</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sinh_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sma</entry>

              <entry>Scalar Multiply, Add</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>smsa</entry>

              <entry>Scalar Multiply, Scalar Add</entry>

              <entry><para><function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sq</entry>

              <entry>Square</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sq_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sqrt</entry>

              <entry>Square Root</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sqrt_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sub</entry>

              <entry>Subtract</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sub_<replaceable>p</replaceable></function>
              (Vector/Matrix subtract Vector/Matrix)
              </para><para><function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>sub_<replaceable>p</replaceable></function>
              (Scalar subtract Vector/Matrix) </para></entry>
            </row>

            <row>
              <entry>sumsqval</entry>

              <entry>Sum of Squares Value</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sumsqval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>sumval</entry>

              <entry>Sum Value</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>sumval_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>swap</entry>

              <entry>Swap</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>swap_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>tan</entry>

              <entry>Tangent</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>tan_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>tanh</entry>

              <entry>Hyperbolic Tangent</entry>

              <entry><para><function>vsip_<replaceable>ds</replaceable>tanh_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>vmodulate</entry>

              <entry>Vector Modulate</entry>

              <entry><para><function>vsip_vmodulate_<replaceable>p</replaceable></function></para></entry>
            </row>

            <row>
              <entry>xor</entry>

              <entry>Exclusive OR</entry>

              <entry><para><function>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></function></para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section>
      <title>In-Place Functionality</title>

      <para>Most simple elementwise functions may be done in-place. The
      meaning of in-place is not necessarily always clear. The following rules
      will define in-place for the Vector and Elementwise functions.</para>

      <orderedlist>
        <listitem>
          <para>The sign (negative or positive) of the stride of objects used
          for in place must be the same.</para>
        </listitem>

        <listitem>
          <para>For functions, like <function>cos</function>, of a single
          argument with a single result of the same type and precision,
          in-place means the result replaces the input.</para>
        </listitem>

        <listitem>
          <para>For functions, like <function>add</function>, of multiple
          arguments with a single result of the same type and precision,
          in-place means the result replaces one of the inputs.</para>
        </listitem>

        <listitem>
          <para>For functions, of one or more vector/matrix/tensor arguments
          and one or more scalar, with a single result of the same type and
          precision, in-place means the result replaces one of the
          inputs.</para>
        </listitem>

        <listitem>
          <para>For a function, like <function>arg</function>, which takes a
          complex input and outputs a real output of the same precision
          in-place means the output can be placed in a real view or an
          imaginary view of the input.</para>
        </listitem>

        <listitem>
          <para>For polar which takes a complex input and outputs two real
          outputs in-place means one output may be placed in a real view of
          the input and the other output may be placed in the imaginary view
          of the input. Note either output can go in either view.</para>
        </listitem>

        <listitem>
          <para>For <function>rect</function> which takes two real inputs and
          gives a complex output in-place means the inputs can be views of the
          real and imaginary portion of the output. Note either input can go
          in either view.</para>
        </listitem>

        <listitem>
          <para>For <function>euler</function> which takes a single real input
          and produces a complex output then in-place means the real input can
          be either a real view or imaginary view of the output.</para>
        </listitem>
      </orderedlist>

      <para>It should be noted that for functions where no input is conformant
      with any output then no in-place operation is defined. In-place
      operations which transform real views to complex views or complex views
      to real views are only allowed when the real view is an imaginary view
      or a real view of the complex view. This means, for instance, that a
      view of a block of data which overlays a complex views data so that both
      real and imaginary words of the complex view are incorporated in the
      real view are not to be used for in-place operations. It also means that
      the input or output real view must exactly overlay the real or imaginary
      view of the complex view, and the stride through the vectors (real and
      imaginary) must both go in the same direction.</para>

      <para>The application programmer should only use in-place functionality
      for functions required to support this functionality by the
      specification. If an implementation provides an in-place functionality
      that is not required by the VSIPL specification, then the application
      programmer should not use it. Using non-required functionality will
      result in portability problems. The following table indicates required
      in-place functionality for vector and elementwise functions.</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Root Name</entry>

              <entry align="center">In-Place ?</entry>

              <entry align="center">Reason/Comment</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>acos</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>add</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>alltrue</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>am</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>and</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>anytrue</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>arg</entry>

              <entry>yes</entry>

              <entry>For in-place output must be into a real view or imaginary
              view. Output to a real view encompassing both real and imaginary
              words of the input vector is not allowed.</entry>
            </row>

            <row>
              <entry>asin</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>atan</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>atan2</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>conj</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>clip</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>cmagsq</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>cmaxmgsq</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>cmaxmgsqval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>cminmgsq</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>cminmgsqval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>cmplx</entry>

              <entry>no</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>cos</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>cosh</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>div</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>euler</entry>

              <entry>yes</entry>

              <entry>In-place input must be a real or imaginary view of the
              output vector.</entry>
            </row>

            <row>
              <entry>exp</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>exp10</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>expoavg</entry>

              <entry>no</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>fill</entry>

              <entry>NA</entry>

              <entry>No source</entry>
            </row>

            <row>
              <entry>gather</entry>

              <entry>no</entry>

              <entry>Not an elementwise operation</entry>
            </row>

            <row>
              <entry>hypot</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>imag</entry>

              <entry>yes</entry>

              <entry>Harmless if output is an imaginary view of the input
              vector, destructive if output is a real view. Output to a
              compacted real view containing both real and imaginary words
              from the complex input view is not allowed.</entry>
            </row>

            <row>
              <entry>indexbool</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>invclip</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>jmul</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>leq</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>lge</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>lgt</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>lle</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>llt</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>lne</entry>

              <entry>no</entry>

              <entry>Different source and destination types</entry>
            </row>

            <row>
              <entry>log</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>log10</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>ma</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>mag</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>max</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>maxmg</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>maxmgval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>maxval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>meansqval</entry>

              <entry>MA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>meanval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>min</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>minmg</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>minmgval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>minval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>msa</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>msb</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>mul</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>neg</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>not</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>or</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>polar</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>ramp</entry>

              <entry>NA</entry>

              <entry>No source</entry>
            </row>

            <row>
              <entry>randcreate</entry>

              <entry>NA</entry>

              <entry>Not a function on views</entry>
            </row>

            <row>
              <entry>randg</entry>

              <entry>NA</entry>

              <entry>No Source</entry>
            </row>

            <row>
              <entry>randu</entry>

              <entry>NA</entry>

              <entry>No Source</entry>
            </row>

            <row>
              <entry>real</entry>

              <entry>yes</entry>

              <entry>Harmless if output is a real view of the input,
              destructive if output is imaginary view. Output to a compacted
              real view containing both real and imaginary words from the
              complex input view is not allowed.</entry>
            </row>

            <row>
              <entry>recip</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>rect</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>rsqrt</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sam</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sbm</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>scatter</entry>

              <entry>no</entry>

              <entry>Not an elementwise operation</entry>
            </row>

            <row>
              <entry>sin</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sinh</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sma</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>smsa</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sq</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sqrt</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sub</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>sumsqval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>sumval</entry>

              <entry>NA</entry>

              <entry>Returns scalar value</entry>
            </row>

            <row>
              <entry>swap</entry>

              <entry>Harmless</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>tan</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>tanh</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>vmodulate</entry>

              <entry>no</entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry>xor</entry>

              <entry>yes</entry>

              <entry><para/></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section>
      <title>Example Programs</title>

      <para>Many of the examples in this clause are designed to be run-able,
      although no guarantees are made. Note that all code requires including
      the standard VSIPL header file, "vsip.h".</para>

      <para>Note that for brevity, the examples don't follow a careful
      programming style. For instance when doing a create, the return should
      always be checked for a null pointer to determine if the create
      failed.</para>
    </section>
  </section>

  <section>
    <title>Elementary Math Functions</title>

    <para>The following functions constitute by element application of
    elementary math operations on vectors and matrices. These include
    trigonometric functions, natural (base e) and base 10 logarithmic and
    exponential functions, and the square root function. These functions are
    defined for real floats with the exception of base e logarithm, the base e
    exponential, and the square root which are also defined for complex
    floats.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Arccosine</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Arcsine</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function></entry>

            <entry>Vetor/Matrix Arctangent</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Arctangent of Two Arguments</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Cosine</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>cosh_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Hyperbolic Cosine</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Exponential</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>exp10_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Exponential Base 10</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>log_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Log</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>log10_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Log Base 10</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Sine</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>sinh_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Hyperbolic Sine</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sqrt_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Square Root</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function></entry>

            <entry>Vecto/Matrix Tangent</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>tanh_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Hyperbolic Tangent</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="sacos">
      <title>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></title>

      <para>Computes the principal radian value [0, +] of the arccosine for
      each element of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>cos</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>cos</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vacos_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_macos_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Element values outside the interval [-1, 1] are a domain
            error. Results of domain errors are implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate arccos for seven evenly spaced values from -1 to
            1:</para>

            <programlisting><xi:include href="examples/acos.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sasin">
      <title>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></title>

      <para>Computes the principal radian value <inlineequation>
          <m:math display="inline">
            <m:mrow>
              <m:mo>[</m:mo>

              <m:mrow>
                <m:mrow>
                  <m:mo>-</m:mo>

                  <m:mfrac bevelled="true">
                    <m:mi>π</m:mi>

                    <m:mn>2</m:mn>
                  </m:mfrac>
                </m:mrow>

                <m:mo>,</m:mo>

                <m:mfrac bevelled="true">
                  <m:mi>π</m:mi>

                  <m:mn>2</m:mn>
                </m:mfrac>
              </m:mrow>

              <m:mo>]</m:mo>
            </m:mrow>
          </m:math>
        </inlineequation> of the arcsine for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>sin</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>sin</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vasin_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_masin_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Element values outside the interval [-1, 1] are a domain
            error. Results of domain errors are implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate Arcsine for seven evenly spaced values from -1 to
            1:</para>

            <programlisting><xi:include href="examples/asin.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="satan">
      <title>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></title>

      <para>Computes the principal radian value <inlineequation>
          <m:math display="inline">
            <m:mrow>
              <m:mo>[</m:mo>

              <m:mrow>
                <m:mrow>
                  <m:mo>-</m:mo>

                  <m:mfrac bevelled="true">
                    <m:mi>π</m:mi>

                    <m:mn>2</m:mn>
                  </m:mfrac>
                </m:mrow>

                <m:mo>,</m:mo>

                <m:mfrac bevelled="true">
                  <m:mi>π</m:mi>

                  <m:mn>2</m:mn>
                </m:mfrac>
              </m:mrow>

              <m:mo>]</m:mo>
            </m:mrow>
          </m:math>
        </inlineequation> of the arctangent for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>tan</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>tan</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vatan_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_matan_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Element values outside the interval [-1, 1] are a domain
            error. Results of domain errors are implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate arg = atan(y/x) in each quadrant at the midpoint
            and on each axis :</para>

            <programlisting><xi:include href="examples/atan.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="satan2">
      <title>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></title>

      <para>Computes the four quadrant radian value <inlineequation>
          <m:math display="inline">
            <m:mrow>
              <m:mo>[</m:mo>

              <m:mrow>
                <m:mrow>
                  <m:mo>-</m:mo>

                  <m:mi>π</m:mi>
                </m:mrow>

                <m:mo>,</m:mo>

                <m:mi>π</m:mi>
              </m:mrow>

              <m:mo>]</m:mo>
            </m:mrow>
          </m:math>
        </inlineequation> of the arc tangent of the ratio of the elements of
      two input vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>tan</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:mfrac>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mfrac>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>tan</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:mfrac>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mfrac>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>The rules for calculating
            <function>vsip_satan2_<replaceable>p</replaceable></function> are
            the same as for the ANSI C math function
            <function>atan2</function>. The following table may be used to
            calculate <function>atan2</function>, although other methods may
            also be used.</para>

            <informaltable>
              <tgroup cols="2">
                <thead>
                  <row>
                    <entry align="center">If</entry>

                    <entry align="center">Then</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>&gt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>≠</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>a</m:mi>

                                <m:mi>b</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mi>cos</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mrow>
                                <m:mi>b</m:mi>

                                <m:mo>/</m:mo>

                                <m:msqrt>
                                  <m:mrow>
                                    <m:msup>
                                      <m:mi>a</m:mi>

                                      <m:mi>2</m:mi>
                                    </m:msup>

                                    <m:mo>+</m:mo>

                                    <m:msup>
                                      <m:mi>b</m:mi>

                                      <m:mi>2</m:mi>
                                    </m:msup>
                                  </m:mrow>
                                </m:msqrt>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>&lt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>&lt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>a</m:mi>

                                <m:mi>b</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mi>cos</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mrow>
                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mi>b</m:mi>
                                </m:mrow>

                                <m:mo>/</m:mo>

                                <m:msqrt>
                                  <m:mrow>
                                    <m:msup>
                                      <m:mi>a</m:mi>

                                      <m:mi>2</m:mi>
                                    </m:msup>

                                    <m:mo>+</m:mo>

                                    <m:msup>
                                      <m:mi>b</m:mi>

                                      <m:mi>2</m:mi>
                                    </m:msup>
                                  </m:mrow>
                                </m:msqrt>
                              </m:mrow>

                              <m:mo>-</m:mo>

                              <m:mi>π</m:mi>
                            </m:mrow>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>&lt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>&gt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>a</m:mi>

                                <m:mi>b</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mi>cos</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mrow>
                                <m:mi>b</m:mi>

                                <m:mo>/</m:mo>

                                <m:msqrt>
                                  <m:mrow>
                                    <m:msup>
                                      <m:mi>a</m:mi>

                                      <m:mi>2</m:mi>
                                    </m:msup>

                                    <m:mo>+</m:mo>

                                    <m:msup>
                                      <m:mi>b</m:mi>

                                      <m:mi>2</m:mi>
                                    </m:msup>
                                  </m:mrow>
                                </m:msqrt>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>&gt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>a</m:mi>

                                <m:mi>0</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mfrac bevelled="true">
                              <m:mi>π</m:mi>

                              <m:mn>2</m:mn>
                            </m:mfrac>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>&lt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>a</m:mi>

                                <m:mi>0</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mrow>
                              <m:mo>-</m:mo>
                            </m:mrow>

                            <m:mfrac bevelled="true">
                              <m:mi>π</m:mi>

                              <m:mn>2</m:mn>
                            </m:mfrac>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>&gt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>0</m:mi>

                                <m:mi>b</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mrow>
                              <m:mn>0</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>&lt;</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>0</m:mi>

                                <m:mi>b</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mrow>
                              <m:mi>π</m:mi>
                            </m:mrow>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>

                  <row>
                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mi>a</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />
                          <m:mrow>
                            <m:mi>b</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>0</m:mi>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>

                    <entry><inlineequation>
                        <m:math display="inline">
                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>tan</m:mi>

                                <m:mrow>
                                  <m:mo>-</m:mo>

                                  <m:mn>1</m:mn>
                                </m:mrow>
                              </m:msup>

                              <m:mo>⁡</m:mo>

                              <m:mfrac>
                                <m:mi>0</m:mi>

                                <m:mi>0</m:mi>
                              </m:mfrac>
                            </m:mrow>

                            <m:mo>≡</m:mo>

                            <m:mtext>Undefined or NaN</m:mtext>
                          </m:mrow>
                        </m:math>
                      </inlineequation></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>Note that the use of “+” is not meant to denote an exact
            number, but it is expected (but not required) to be accurate to
            the ! machine precision for the data type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vatan2_f(vsip_vview_f const *a, vsip_vview_f const *b, 
                   vsip_vview_f const *r);
void vsip_matan2_f(vsip_mview_f const *a, vsip_mview_f const *b, 
                   vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix corresponding to
                  numerator</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix corresponding to
                  denominator</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The domain of atan2(x, y) is not valid for both x and y zero
            and the result is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate arg = atan2(y/x) in each quadrant at the midpoint
            and on each axis :</para>

            <programlisting><xi:include href="examples/atan2.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>hypot_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="scos">
      <title>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></title>

      <para>Computes the cosine for each element of a vector/matrix. Element
      angle values are in radians.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>cos</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>cos</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcos_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_mcos_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Behavior of element values outside of the closed interval
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mo>[</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mo>-</m:mo>

                        <m:mrow>
                          <m:mi>2</m:mi>

                          <m:mo>⁢</m:mo>

                          <m:mi>π</m:mi>
                        </m:mrow>
                      </m:mrow>

                      <m:mo>,</m:mo>

                      <m:mrow>
                        <m:mi>2</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>π</m:mi>
                      </m:mrow>
                    </m:mrow>

                    <m:mo>]</m:mo>
                  </m:mrow>
                </m:math>
              </inlineequation> is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Input arguments are expressed in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Print cosine values for angles evenly spaced between zero
            and 2 pi :</para>

            <programlisting><xi:include href="examples/cos.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="scosh">
      <title>vsip_<replaceable>s</replaceable>cosh_<replaceable>p</replaceable></title>

      <para>Computes the hyperbolic cosine for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>cosh</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>cosh</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcosh_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_mcosh_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow behavior and domain restrictions are implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Input arguments are expressed in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/cosh.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>sinh_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tanh_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsexp">
      <title>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></title>

      <para>Computes the exceptional function value for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Real:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mi>e</m:mi>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:msup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mi>e</m:mi>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:msup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Complex:</para>

            <para>Let <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mi>σ</m:mi>

                      <m:mo>=</m:mo>

                      <m:mrow>
                        <m:mi>Re</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>a</m:mi>
                        </m:mfenced>
                      </m:mrow>
                    </m:mrow>

                    <m:mo>,</m:mo>

                    <m:mrow>
                      <m:mi>ω</m:mi>

                      <m:mo>=</m:mo>

                      <m:mrow>
                        <m:mi>Im</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:mi>a</m:mi>
                        </m:mfenced>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>e</m:mi>

                                <m:msub>
                                  <m:mi>σ</m:mi>

                                  <m:mi>k</m:mi>
                                </m:msub>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mrow>
                                    <m:mi>cos</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:msub>
                                      <m:mi>ω</m:mi>

                                      <m:mi>k</m:mi>
                                    </m:msub>
                                  </m:mrow>

                                  <m:mo>+</m:mo>

                                  <m:mrow>
                                    <m:mi>j</m:mi>

                                    <m:mo>⁢</m:mo>

                                    <m:mrow>
                                      <m:mi>sin</m:mi>

                                      <m:mo>⁡</m:mo>

                                      <m:msub>
                                        <m:mi>ω</m:mi>

                                        <m:mi>k</m:mi>
                                      </m:msub>
                                    </m:mrow>
                                  </m:mrow>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:msup>
                              <m:mi>e</m:mi>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>σ</m:mi>

                                  <m:mi>k</m:mi>
                                </m:msub>

                                <m:mo>+</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>⁢</m:mo>

                                  <m:msub>
                                    <m:mi>ω</m:mi>

                                    <m:mi>k</m:mi>
                                  </m:msub>
                                </m:mrow>
                              </m:mrow>
                            </m:msup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k,l</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mi>e</m:mi>

                                <m:msub>
                                  <m:mi>σ</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>
                              </m:msup>

                              <m:mo>⁢</m:mo>

                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mrow>
                                    <m:mi>cos</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:msub>
                                      <m:mi>ω</m:mi>

                                      <m:mi>k,l</m:mi>
                                    </m:msub>
                                  </m:mrow>

                                  <m:mo>+</m:mo>

                                  <m:mrow>
                                    <m:mi>j</m:mi>

                                    <m:mo>⁢</m:mo>

                                    <m:mrow>
                                      <m:mi>sin</m:mi>

                                      <m:mo>⁡</m:mo>

                                      <m:msub>
                                        <m:mi>ω</m:mi>

                                        <m:mi>k,l</m:mi>
                                      </m:msub>
                                    </m:mrow>
                                  </m:mrow>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:msup>
                              <m:mi>e</m:mi>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>σ</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>

                                <m:mo>+</m:mo>

                                <m:msub>
                                  <m:mi>ω</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>
                              </m:mrow>
                            </m:msup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>l</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vexp_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_cvexp_f(vsip_cvview_f const *a, vsip_cvview_f const *r);
void vsip_mexp_f(vsip_mview_f const *a, vsip_mview_f const *r);
void vsip_cmexp_f(vsip_cmview_f const *a, vsip_cmview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow will occur if a (real part for complex) element is
            greater than the natural log of the maximum defined number. The
            result of an overflow is implementation dependent.</para>

            <para>Underflow will occur if a (real part for complex) element is
            less than the negative of the natural log of the maximum defined
            number. The result of an underflow is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Input arguments are expressed in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate a = exp(x) for x = {0,1,...,N} :</para>

            <programlisting><xi:include href="examples/exp.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>exp10_<replaceable>p</replaceable></function>,<function>
            vsip_<replaceable>ds</replaceable>log_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>log10_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sexp10">
      <title>vsip_<replaceable>s</replaceable>exp10_<replaceable>p</replaceable></title>

      <para>Computes the base 10 exceptional for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mn>10</m:mn>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:msup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mn>10</m:mn>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:msup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vexp10_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_mexp10_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow will occur if a (real part for complex) element is
            greater than the natural log of the maximum defined number. The
            result of an overflow is implementation dependent.</para>

            <para>Underflow will occur if a (real part for complex) element is
            less than the negative of the natural log of the maximum defined
            number. The result of an underflow is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Input arguments are expressed in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate a = 10^x for x = {0,1,...,N} :</para>

            <programlisting><xi:include href="examples/exp10.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></function>,<function>
            vsip_<replaceable>ds</replaceable>log_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>log10_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dslog">
      <title>vsip_<replaceable>ds</replaceable>log_<replaceable>p</replaceable></title>

      <para>Computes the natural logarithm for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Real:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>log</m:mi>

                              <m:mi>e</m:mi>
                            </m:msub>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>log</m:mi>

                              <m:mi>e</m:mi>
                            </m:msub>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Complex:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msub>
                                <m:mi>log</m:mi>

                                <m:mi>e</m:mi>
                              </m:msub>

                              <m:mo>⁡</m:mo>

                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mrow>
                                <m:mi>arg</m:mi>

                                <m:mo>⁡</m:mo>

                                <m:mfenced>
                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>k</m:mi>
                                  </m:msub>
                                </m:mfenced>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k,l</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msub>
                                <m:mi>log</m:mi>

                                <m:mi>e</m:mi>
                              </m:msub>

                              <m:mo>⁡</m:mo>

                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:mrow>
                                <m:mi>arg</m:mi>

                                <m:mo>⁡</m:mo>

                                <m:mfenced>
                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>k,l</m:mi>
                                  </m:msub>
                                </m:mfenced>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>l</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vlog_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_cvlog_f(vsip_cvview_f const *a, vsip_cvview_f const *r);
void vsip_mlog_f(vsip_mview_f const *a, vsip_mview_f const *r);
void vsip_cmlog_f(vsip_cmview_f const *a, vsip_cmview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>For the real case, arguments less than or equal to zero are
            not in the domain of log and the result is implementation
            dependent.</para>

            <para>For the complex case, arguments where both the real and
            imaginary portions are zero are not defined and the result is
            implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate a = log(x^2) for x = {0,1,...,N} :</para>

            <programlisting><xi:include href="examples/log.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>exp10_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>log10_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="slog10">
      <title>vsip_<replaceable>s</replaceable>log10_<replaceable>p</replaceable></title>

      <para>Compute the base ten logarithm for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>log</m:mi>

                              <m:mi>10</m:mi>
                            </m:msub>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>log</m:mi>

                              <m:mi>10</m:mi>
                            </m:msub>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vlog10_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_mlog10_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Arguments less than or equal to zero are not in the domain
            of log and the result is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Input arguments are expressed in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate a = log10(x^2) for x = {0,1,...,N} :</para>

            <programlisting><xi:include href="examples/log10.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>exp10_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>log10_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="ssin">
      <title>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></title>

      <para>Compute the sine for each element of a vector/matrix. Element
      angle values are in radians.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>sin</m:mo>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>sin</m:mo>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsin_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_msin_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Behavior of element values outside of the closed interval
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mo>[</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mo>-</m:mo>

                        <m:mrow>
                          <m:mi>2</m:mi>

                          <m:mo>⁢</m:mo>

                          <m:mi>π</m:mi>
                        </m:mrow>
                      </m:mrow>

                      <m:mo>,</m:mo>

                      <m:mrow>
                        <m:mi>2</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>π</m:mi>
                      </m:mrow>
                    </m:mrow>

                    <m:mo>]</m:mo>
                  </m:mrow>
                </m:math>
              </inlineequation> is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Input arguments are expressed in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Print a sine wave for seven evenly spaced values between
            zero and two pi :</para>

            <programlisting><xi:include href="examples/sin.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="ssinh">
      <title>vsip_<replaceable>s</replaceable>sinh_<replaceable>p</replaceable></title>

      <para>Compute the hyperbolic sine for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>sinh</m:mo>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>sinh</m:mo>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsinh_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_msinh_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow behavior and domain restrictions are implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Print sinh(x) for x=0,1,...,6 :</para>

            <programlisting><xi:include href="examples/sinh.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>cosh_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>tanh_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssqrt">
      <title>vsip_<replaceable>ds</replaceable>sqrt_<replaceable>p</replaceable></title>

      <para>Compute the square root for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Real:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msqrt>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:msqrt>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msqrt>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:msqrt>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Complex:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>φ</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>≡</m:mo>

                          <m:mrow>
                            <m:mi>arg</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>k</m:mi>
                              </m:msub>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd/>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msqrt>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:msqrt>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:mrow>
                                  <m:mi>cos</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfrac>
                                    <m:msub>
                                      <m:mi>φ</m:mi>

                                      <m:mi>k</m:mi>
                                    </m:msub>

                                    <m:mi>2</m:mi>
                                  </m:mfrac>
                                </m:mrow>

                                <m:mo>+</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>⁢</m:mo>

                                  <m:mrow>
                                    <m:mi>sin</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfrac>
                                      <m:msub>
                                        <m:mi>φ</m:mi>

                                        <m:mi>k</m:mi>
                                      </m:msub>

                                      <m:mi>2</m:mi>
                                    </m:mfrac>
                                  </m:mrow>
                                </m:mrow>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>φ</m:mi>

                            <m:mi>k,l</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>≡</m:mo>

                          <m:mrow>
                            <m:mi>arg</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>k</m:mi>
                              </m:msub>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd/>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k,l</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msqrt>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:msqrt>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:mrow>
                                  <m:mi>cos</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfrac>
                                    <m:msub>
                                      <m:mi>φ</m:mi>

                                      <m:mi>k,l</m:mi>
                                    </m:msub>

                                    <m:mi>2</m:mi>
                                  </m:mfrac>
                                </m:mrow>

                                <m:mo>+</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>⁢</m:mo>

                                  <m:mrow>
                                    <m:mi>sin</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfrac>
                                      <m:msub>
                                        <m:mi>φ</m:mi>

                                        <m:mi>k,l</m:mi>
                                      </m:msub>

                                      <m:mi>2</m:mi>
                                    </m:mfrac>
                                  </m:mrow>
                                </m:mrow>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>l</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsqrt_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_msqrt_f(vsip_mview_f const *a, vsip_mview_f const *r);
void vsip_cvsqrt_f(vsip_cvview_f const *a, vsip_cvview_f const *r);
void vsip_cmsqrt_f(vsip_cmview_f const *a, vsip_cmview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>For square root calculation in the real case the argument
            must be greater than or equal to zero to be within the domain of
            the function. Results for cases where the argument is less than
            zero is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Compute <inlineequation>
                <m:math display="inline">
                  <m:msqrt>
                    <m:mrow>
                      <m:mi>2</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:msup>
                        <m:mi>e</m:mi>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo/>

                          <m:mi>n</m:mi>

                          <m:mo/>

                          <m:mfrac>
                            <m:mi>π</m:mi>

                            <m:mi>4</m:mi>
                          </m:mfrac>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:msqrt>
                </m:math>
              </inlineequation> for n=0,1...,7</para>

            <programlisting><xi:include href="examples/sqrt.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>rsqrt_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="stan">
      <title>vsip_<replaceable>s</replaceable>tan_<replaceable>p</replaceable></title>

      <para>Compute the tangent for each element of a vector/matrix. Element
      angle values are in radians.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>tan</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>tan</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vtan_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_mtan_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Behavior of element values outside of the closed interval
            <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mo>[</m:mo>

                    <m:mrow>
                      <m:mrow>
                        <m:mo>-</m:mo>

                        <m:mrow>
                          <m:mi>2</m:mi>

                          <m:mo>⁢</m:mo>

                          <m:mi>π</m:mi>
                        </m:mrow>
                      </m:mrow>

                      <m:mo>,</m:mo>

                      <m:mrow>
                        <m:mi>2</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>π</m:mi>
                      </m:mrow>
                    </m:mrow>

                    <m:mo>]</m:mo>
                  </m:mrow>
                </m:math>
              </inlineequation> is implementation dependent.</para>

            <para>For element values <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mrow>
                      <m:mo>(</m:mo>

                      <m:mrow>
                        <m:mi>n</m:mi>

                        <m:mo>+</m:mo>

                        <m:mrow>
                          <m:mn>1</m:mn>

                          <m:mo>/</m:mo>

                          <m:mn>2</m:mn>
                        </m:mrow>
                      </m:mrow>

                      <m:mo>)</m:mo>
                    </m:mrow>

                    <m:mo>⁢</m:mo>

                    <m:mi>π</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, the tan function has a singularity. The
            results of these values are implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Calculate a= tan(x) in each quadrant at the midpoint:</para>

            <programlisting><xi:include href="examples/tan.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>acos_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>asin_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cos_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>sin_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="stanh">
      <title>vsip_<replaceable>s</replaceable>tanh_<replaceable>p</replaceable></title>

      <para>Compute the hyperbolic tangent for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>tanh</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>tanh</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vtan_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_mtan_f(vsip_mview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Print tanh(x) for x=0,1,...,6:</para>

            <programlisting><xi:include href="examples/tanh.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>cosh_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>sinh_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Unary Operations</title>

    <para>The following functions represent operations done on a single
    vector/matrix.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>s</replaceable>arg_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Argument</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>ceil_<replaceable>p</replaceable>_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Ceiling</entry>
          </row>

          <row>
            <entry><function>vsip_c<replaceable>s</replaceable>conj_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Conjugate</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>cumsum_<replaceable>p</replaceable></function></entry>

            <entry>Cumulative Sum</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>euler_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Euler</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>floor_<replaceable>p</replaceable>_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Floor</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>mag_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Magnitude</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>cmagsq_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Complex Magnitude Squared</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>meanval_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Mean Value</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>meansqval_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Mean Square Value</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vmodulate_<replaceable>p</replaceable></function></entry>

            <entry>Vector Modulate</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>neg_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Negate</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>recpi_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Reciprocal</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>round_<replaceable>p</replaceable>_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Round</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>rsqrt_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Reciprocal Square Root</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sq_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Square</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sumval_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Sum Value</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sumsqval_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Sum of Squares Value</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="sarg">
      <title>vsip_<replaceable>s</replaceable>arg_<replaceable>p</replaceable></title>

      <para>Compute the radian value argument, in the interval <inlineequation>
          <m:math display="inline">
            <m:mrow>
              <m:mo>[</m:mo>

              <m:mrow>
                <m:mrow>
                  <m:mo>-</m:mo>

                  <m:mi>π</m:mi>
                </m:mrow>

                <m:mo>,</m:mo>

                <m:mi>π</m:mi>
              </m:mrow>

              <m:mo>]</m:mo>
            </m:mrow>
          </m:math>
        </inlineequation>, for each element of a complex vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>tan</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mfrac bevelled="true">
                                <m:mrow>
                                  <m:mi>Im</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:msub>
                                      <m:mi>a</m:mi>

                                      <m:mi>j</m:mi>
                                    </m:msub>
                                  </m:mfenced>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>Re</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:msub>
                                      <m:mi>a</m:mi>

                                      <m:mi>j</m:mi>
                                    </m:msub>
                                  </m:mfenced>
                                </m:mrow>
                              </m:mfrac>

                              <m:mo>)</m:mo>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msup>
                              <m:mi>tan</m:mi>

                              <m:mrow>
                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:msup>

                            <m:mo>⁡</m:mo>

                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mfrac bevelled="true">
                                <m:mrow>
                                  <m:mi>Im</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:msub>
                                      <m:mi>a</m:mi>

                                      <m:mi>i,j</m:mi>
                                    </m:msub>
                                  </m:mfenced>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>Re</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:msub>
                                      <m:mi>a</m:mi>

                                      <m:mi>i,j</m:mi>
                                    </m:msub>
                                  </m:mfenced>
                                </m:mrow>
                              </m:mfrac>

                              <m:mo>)</m:mo>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_varg_f(vsip_cvview_f const *a, vsip_vview_f const *r);
void vsip_marg_f(vsip_cmview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>For in-place the output argument may be either the derived
            real view or the imaginary view of the input complex view.
            In-place is not defined if the output data is not either a real or
            imaginary view of the input data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be “in-place” as
                described in the restrictions, or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/arg.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>euler_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sceil">
      <title>vsip_<replaceable>s</replaceable>ceil_<replaceable>p</replaceable>_<replaceable>p</replaceable></title>

      <para>For each element in the input view round to the smallest integral
      value not less than the input and place the result in the output view
      elementwise.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>⌈</m:mo>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>i</m:mi>
                            </m:msub>

                            <m:mo>⌉</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>⌈</m:mo>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⌉</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vceil_f_f(vsip_vview_f const *x, vsip_vview_f const *r);
void vsip_vceil_f_i(vsip_vview_f const *x, vsip_vview_i const *r);
void vsip_mceil_f_f(vsip_mview_f const *x, vsip_mview_f const *r);
void vsip_mceil_f_i(vsip_mview_f const *x, vsip_mview_i const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Although there is no VSIPL requirement to fully support IEEE
            754 the intent of this function is to support the round to
            +INFINITY functionality as described in IEEE 754.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>floor_<replaceable>p</replaceable>_<replaceable>p</replaceable></function>
            and
            <function>vsip_<replaceable>s</replaceable>round_<replaceable>p</replaceable>_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="csconj">
      <title>vsip_c<replaceable>s</replaceable>conj_<replaceable>p</replaceable></title>

      <para>Compute the conjugate for each element of a complex
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msubsup>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>

                            <m:mo>*</m:mo>
                          </m:msubsup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:msubsup>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>

                            <m:mo>*</m:mo>
                          </m:msubsup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cvconj_<replaceable>f</replaceable>(vsip_cvview_<replaceable>f</replaceable> const *a, vsip_cvview_<replaceable>f</replaceable> const *r);
void vsip_cmconj_<replaceable>f</replaceable>(vsip_cmview_<replaceable>f</replaceable> const *a, vsip_cmview_<replaceable>f</replaceable> const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/conj.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>neg_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dscumsum">
      <title>vsip_<replaceable>ds</replaceable>cumsum_<replaceable>p</replaceable></title>

      <para>Compute the cumulative sum of the elements of a vector.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>n</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>∑</m:mo>

                              <m:mrow>
                                <m:mi>i</m:mi>

                                <m:mo>=</m:mo>

                                <m:mi>0</m:mi>
                              </m:mrow>

                              <m:mi>n</m:mi>
                            </m:munderover>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>i</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>n</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Row:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>m,n</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>∑</m:mo>

                              <m:mrow>
                                <m:mi>i</m:mi>

                                <m:mo>=</m:mo>

                                <m:mi>0</m:mi>
                              </m:mrow>

                              <m:mi>n</m:mi>
                            </m:munderover>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>m,i</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>m</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>n</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Column:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>m,n</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>∑</m:mo>

                              <m:mrow>
                                <m:mi>i</m:mi>

                                <m:mo>=</m:mo>

                                <m:mi>0</m:mi>
                              </m:mrow>

                              <m:mi>n</m:mi>
                            </m:munderover>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>i,n</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>m</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>n</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcumsum_f(const vsip_vview_f *x, const vsip_vview_f *r);
void vsip_vcumsum_i(const vsip_vview_i *x, const vsip_vview_i *r);
void vsip_cvcumsum_f(const vsip_cvview_f *x, const vsip_cvview_f *r);
void vsip_cvcumsum_i(const vsip_cvview_i *x, const vsip_cvview_i *r);
void vsip_mcumsum_f(const vsip_mview_f *x, vsip_major dir, 
                    const vsip_mview_f *r);
void vsip_mcumsum_i(const vsip_mview_i *x, vsip_major dir, 
                    const vsip_mview_i *r);
void vsip_cmcumsum_f(const vsip_cmview_f *x, vsip_major dir, 
                     const vsip_cmview_f *r);
void vsip_cmcumsum_i(const vsip_cmview_i *x, vsip_major dir, 
                     const vsip_cmview_i *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>dir</term>

                <listitem>
                  <para>For matrix cumulative sum specifies the direction the
                  sum is done over.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The following cause a runtime VSIPL error if compiled in
            development mode. If compiled in production mode the results will
            be implementation dependent.</para>

            <orderedlist>
              <listitem>
                <para>Arguments for input and output must be the same
                size.</para>
              </listitem>

              <listitem>
                <para>Arguments passed to the function must be defined and
                must not be null.</para>
              </listitem>

              <listitem>
                <para>The input and output views must either be the same or
                must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Used to compute boxcar integration, moving average, and
            other sliding window functions.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="seuler">
      <title>vsip_<replaceable>s</replaceable>euler_<replaceable>p</replaceable></title>

      <para>Computes the complex numbers corresponding to the angle of a unit
      vector in the complex plane for each element of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mrow>
                                <m:mi>cos</m:mi>

                                <m:mo>⁡</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>+</m:mo>

                              <m:mrow>
                                <m:mi>j</m:mi>

                                <m:mo>⁢</m:mo>

                                <m:mrow>
                                  <m:mi>sin</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>k</m:mi>
                                  </m:msub>
                                </m:mrow>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:msup>
                              <m:mi>e</m:mi>

                              <m:mrow>
                                <m:mi>j</m:mi>

                                <m:mo>⁢</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k</m:mi>
                                </m:msub>
                              </m:mrow>
                            </m:msup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mrow>
                                <m:mi>cos</m:mi>

                                <m:mo>⁡</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>+</m:mo>

                              <m:mrow>
                                <m:mi>j</m:mi>

                                <m:mo>⁢</m:mo>

                                <m:mrow>
                                  <m:mi>sin</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>k,l</m:mi>
                                  </m:msub>
                                </m:mrow>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:msup>
                              <m:mi>e</m:mi>

                              <m:mrow>
                                <m:mi>j</m:mi>

                                <m:mo>⁢</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>k,l</m:mi>
                                </m:msub>
                              </m:mrow>
                            </m:msup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>k</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>l</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_veuler_f(vsip_vview_f const *a, vsip_cvview_f const *r);
void vsip_meuler_f(vsip_mview_f const *a, vsip_cmview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In-place operation implies that the input is either a
            derived real or imaginary view of the output view.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be “in-place” as
                described in the restrictions, or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The result for large arguments may not be accurate and is
            limited by the method of conversion of the argument to its
            principal value.</para>

            <para>The speed may be adversely impacted for large arguments
            because of conversion of the argument to its principal
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/euler.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>exp_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vmodulate_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sfloor">
      <title>vsip_<replaceable>s</replaceable>floor_<replaceable>p</replaceable>_<replaceable>p</replaceable></title>

      <para>For each element in the input view round to the largest integral
      value not greater than the input and place the result in the output view
      elementwise.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>⌊</m:mo>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>i</m:mi>
                            </m:msub>

                            <m:mo>⌋</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>⌊</m:mo>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⌋</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vfloor_f_f(vsip_vview_f const *x, vsip_vview_f const *r);
void vsip_vfloor_f_i(vsip_vview_f const *x, vsip_vview_i const *r);
void vsip_mfloor_f_f(vsip_mview_f const *x, vsip_mview_f const *r);
void vsip_mfloor_f_i(vsip_mview_f const *x, vsip_mview_i const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Although there is no VSIPL requirement to fully support IEEE
            754 the intent of this function is to support the round to
            +INFINITY functionality as described in IEEE 754.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>ceil_<replaceable>p</replaceable>_p</function>
            and
            <function>vsip_<replaceable>s</replaceable>round_<replaceable>p</replaceable>_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsmag">
      <title>vsip_<replaceable>ds</replaceable>mag_<replaceable>p</replaceable></title>

      <para>Compute the magnitude for each element of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmag_f(vsip_vview_f const *a, vsip_vview_f const *r);
void vsip_cvmag_f(vsip_cvview_f const *a, vsip_vview_f const *r);
void vsip_mmag_f(vsip_mview_f const *a, vsip_mview_f const *r);
void vsip_cmmag_f(vsip_cmview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In the complex case in-place implies that the output is
            either a real view or an imaginary view of the input vector.
            Output views that do not exactly match either a real view, or an
            imaginary view, are not defined for in-place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>Arguments passed to the function whose data space
                overlap with different offsets or strides may cause
                overwriting of data before it is used.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/mag.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>cmagsq_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="scmagsq">
      <title>vsip_<replaceable>s</replaceable>cmagsq_<replaceable>p</replaceable></title>

      <para>Computes the square of the magnitudes for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:mrow>
                                    <m:mi>Re</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:msub>
                                        <m:mi>a</m:mi>

                                        <m:mi>j</m:mi>
                                      </m:msub>
                                    </m:mfenced>
                                  </m:mrow>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>

                              <m:mo>+</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:mrow>
                                    <m:mi>Im</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:msub>
                                        <m:mi>a</m:mi>

                                        <m:mi>j</m:mi>
                                      </m:msub>
                                    </m:mfenced>
                                  </m:mrow>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:msup>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>

                              <m:mi>2</m:mi>
                            </m:msup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>j</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>N</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:maligngroup/>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:mrow>
                                    <m:mi>Re</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:msub>
                                        <m:mi>a</m:mi>

                                        <m:mi>i,j</m:mi>
                                      </m:msub>
                                    </m:mfenced>
                                  </m:mrow>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>

                              <m:mo>+</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:mrow>
                                    <m:mi>Im</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:msub>
                                        <m:mi>a</m:mi>

                                        <m:mi>i,j</m:mi>
                                      </m:msub>
                                    </m:mfenced>
                                  </m:mrow>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:msup>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>

                              <m:mi>2</m:mi>
                            </m:msup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for</m:mtext>

                          <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>

                          <m:mrow>
                            <m:mi>i</m:mi>

                            <m:mo>=</m:mo>

                            <m:mn>0</m:mn>

                            <m:mo>,</m:mo>

                            <m:mn>1</m:mn>

                            <m:mo>,</m:mo>

                            <m:mi>...</m:mi>

                            <m:mo>,</m:mo>

                            <m:mrow>
                              <m:mi>M</m:mi>

                              <m:mo>-</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>;</m:mo>

                              <m:mtext>for</m:mtext>

                              <m:mspace depth="0.5ex" height="0.5ex" width="1ex"/>
                            </m:mrow>

                            <m:mrow>
                              <m:mi>j</m:mi>

                              <m:mo>=</m:mo>

                              <m:mn>0</m:mn>

                              <m:mo>,</m:mo>

                              <m:mn>1</m:mn>

                              <m:mo>,</m:mo>

                              <m:mi>...</m:mi>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mn>1</m:mn>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcmagsq_f(vsip_cvview_f const *a, vsip_vview_f const *r);
void vsip_mcmagsq_f(vsip_cmview_f const *a, vsip_mview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>There is no requirement that intermediate overflows do not
            occur. Domain restrictions and overflow behavior are
            implementation dependent.</para>

            <para>In-place functionality requires that the output be either a
            real view or an imaginary view of the input vector. Output views
            that encompass both real and imaginary portions of the input, or
            which do not exactly overlay a real or imaginary view of the input
            are not defined for in-place operations.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>Arguments passed to the function whose data space
                overlap with different offsets or strides may cause
                overwriting of data before it is used.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The order of summation is not specified, therefore
            significant numerical errors can potentially occur.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/magsq.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>mag_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsmeanval">
      <title>vsip_<replaceable>ds</replaceable>meanval_<replaceable>p</replaceable></title>

      <para>Returns the mean value of the elements of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>mean<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mfrac>
                              <m:mi>1</m:mi>

                              <m:mi>N</m:mi>
                            </m:mfrac>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>mean<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mfrac>
                              <m:mi>1</m:mi>

                              <m:mrow>
                                <m:mi>M</m:mi>

                                <m:mo>⁢</m:mo>

                                <m:mi>N</m:mi>
                              </m:mrow>
                            </m:mfrac>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:mrow>
                                <m:munderover>
                                  <m:mo>∑</m:mo>

                                  <m:mrow>
                                    <m:mi>i</m:mi>

                                    <m:mo>=</m:mo>

                                    <m:mi>0</m:mi>
                                  </m:mrow>

                                  <m:mrow>
                                    <m:mi>M</m:mi>

                                    <m:mo>-</m:mo>

                                    <m:mi>1</m:mi>
                                  </m:mrow>
                                </m:munderover>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vmeanval_f(vsip_vview_f const *a);
vsip_cscalar_f vsip_cvmeanval_f(vsip_cvview_f const *a);
vsip_scalar_f vsip_mmeanval_f(vsip_mview_f const *a);
vsip_cscalar_f vsip_cmmeanval_f(vsip_cmview_f const *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the mean value of the elements of the
            vector/matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/meanval.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>meansqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>ds</replaceable>sumval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>sumsqval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsmeansqval">
      <title>vsip_<replaceable>ds</replaceable>meansqval_<replaceable>p</replaceable></title>

      <para>Returns the mean magnitude squared value of the elements of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>meansq<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mfrac>
                              <m:mi>1</m:mi>

                              <m:mi>N</m:mi>
                            </m:mfrac>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>meansq<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mfrac>
                              <m:mi>1</m:mi>

                              <m:mrow>
                                <m:mi>M</m:mi>

                                <m:mo>⁢</m:mo>

                                <m:mi>N</m:mi>
                              </m:mrow>
                            </m:mfrac>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:mrow>
                                <m:munderover>
                                  <m:mo>∑</m:mo>

                                  <m:mrow>
                                    <m:mi>i</m:mi>

                                    <m:mo>=</m:mo>

                                    <m:mi>0</m:mi>
                                  </m:mrow>

                                  <m:mrow>
                                    <m:mi>M</m:mi>

                                    <m:mo>-</m:mo>

                                    <m:mi>1</m:mi>
                                  </m:mrow>
                                </m:munderover>

                                <m:msup>
                                  <m:mrow>
                                    <m:mo>|</m:mo>

                                    <m:msub>
                                      <m:mi>a</m:mi>

                                      <m:mi>i,j</m:mi>
                                    </m:msub>

                                    <m:mo>|</m:mo>
                                  </m:mrow>

                                  <m:mi>2</m:mi>
                                </m:msup>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vmeansqval_f(vsip_vview_f const *a);
vsip_scalar_f vsip_cvmeansqval_f(vsip_cvview_f const *a);
vsip_scalar_f vsip_mmeansqval_f(vsip_mview_f const *a);
vsip_scalar_f vsip_cmmeansqval_f(vsip_cmview_f const *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the mean of the squares of all the elements of the
            vector/matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector/matrix passed to the function must be defined
                and must not be null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/meansqval.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>meanval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>ds</replaceable>sumval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>sumsqval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvmodulate">
      <title>vsip_<replaceable>d</replaceable>vmodulate_<replaceable>p</replaceable></title>

      <para>Computes the modulation of a real vector by a specified complex
      frequency.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>k</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mrow>
                                    <m:mi>cos</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:mrow>
                                        <m:mrow>
                                          <m:mi>k</m:mi>

                                          <m:mo>⁢</m:mo>

                                          <m:mi>ν</m:mi>
                                        </m:mrow>

                                        <m:mo>+</m:mo>

                                        <m:mi>φ</m:mi>
                                      </m:mrow>
                                    </m:mfenced>
                                  </m:mrow>

                                  <m:mo>+</m:mo>

                                  <m:mrow>
                                    <m:mi>j</m:mi>

                                    <m:mo>⁢</m:mo>

                                    <m:mrow>
                                      <m:mi>sin</m:mi>

                                      <m:mo>⁡</m:mo>

                                      <m:mfenced>
                                        <m:mrow>
                                          <m:mrow>
                                            <m:mi>k</m:mi>

                                            <m:mo>⁢</m:mo>

                                            <m:mi>ν</m:mi>
                                          </m:mrow>

                                          <m:mo>+</m:mo>

                                          <m:mi>φ</m:mi>
                                        </m:mrow>
                                      </m:mfenced>
                                    </m:mrow>
                                  </m:mrow>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>=</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>k</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msup>
                                <m:mi>e</m:mi>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>⁢</m:mo>

                                  <m:mrow>
                                    <m:mo>(</m:mo>

                                    <m:mrow>
                                      <m:mrow>
                                        <m:mi>k</m:mi>

                                        <m:mo>⁢</m:mo>

                                        <m:mi>ν</m:mi>
                                      </m:mrow>

                                      <m:mo>+</m:mo>

                                      <m:mi>φ</m:mi>
                                    </m:mrow>

                                    <m:mo>)</m:mo>
                                  </m:mrow>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for k = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Where ν is the frequency in radians per index and φ is the
            initial phase.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vmodulate_f(const vsip_vview_f *a,
                               vsip_scalar_f nu,
                               vsip_scalar_f phi,
                               const vsip_cvview_f *r);
vsip_scalar_f vsip_cvmodulate_f(const vsip_cvview_f *a,
                                vsip_scalar_f nu,
                                vsip_scalar_f phi,
                                const vsip_cvview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>nu</term>

                <listitem>
                  <para>Scalar frequency in radians per index</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>phi</term>

                <listitem>
                  <para>Scalar initial phase in radians.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns a value to be used as the initial phase argument for
            the next call of <function>vsip_vmodulate_f</function>. For a
            vector of length N, the return value would be Nν + φ.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The return value would be used as the initial phase # in the
            next frame if the modulation function intended to be continuous
            but processed by frames.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/modulate.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>euler_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsneg">
      <title>vsip_<replaceable>ds</replaceable>neg_<replaceable>p</replaceable></title>

      <para>Computes the negation for each element of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vneg_i(const vsip_vview_i *a, const vsip_vview_i *r);
void vsip_vneg_f(const vsip_vview_f *a, const vsip_vview_f *r);
void vsip_cvneg_f(const vsip_cvview_f *a, const vsip_cvview_f *r);
void vsip_mneg_i(const vsip_mview_i *a, const vsip_mview_i *r);
void vsip_mneg_f(const vsip_mview_f *a, const vsip_mview_f *r);
void vsip_cmneg_f(const vsip_cmview_f *a, const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/neg.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_c<replaceable>s</replaceable>conj_<replaceable>p</replaceable></function>,
            and
            vsip_<replaceable>ds</replaceable>sub_<replaceable>p</replaceable></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsrecip">
      <title>vsip_<replaceable>ds</replaceable>recip_<replaceable>p</replaceable></title>

      <para>Computes the reciprocal for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:mi>1</m:mi>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:mi>1</m:mi>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vrecip_f(const vsip_vview_f *a, const vsip_vview_f *r);
void vsip_cvrecip_f(const vsip_cvview_f *a, const vsip_cvview_f *r);
void vsip_mrecip_f(const vsip_mview_f *a, const vsip_mview_f *r);
void vsip_cmrecip_f(const vsip_cmview_f *a, const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The inverse of zero is not defined. The result of the
            reciprocal of zero is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/recip.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>rsqrt_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sround">
      <title>vsip_<replaceable>s</replaceable>round_<replaceable>p</replaceable>_<replaceable>p</replaceable></title>

      <para>For each element in the input view round to the nearest integral
      value.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>For each element in the input view round to the nearest
            integral value. If two integral values are equally near, round to
            the value whose least significant bit is zero.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vround_f_f(const vsip_vview_f *x, const vsip_vview_f *r);
void vsip_vround_f_i(const vsip_vview_f *x, const vsip_vview_i *r);
void vsip_mround_f_f(const vsip_mview_f *x, const vsip_mview_f *r);
void vsip_mround_f_i(const vsip_mview_f *x, const vsip_mview_i *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Although there is no VSIPL requirement to fully support IEEE
            754 the intent of this function is to support the round to nearest
            functionality as described in IEEE 754.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>ceil_<replaceable>p</replaceable>_<replaceable>p</replaceable></function>
            and
            <function>vsip_<replaceable>s</replaceable>floor_<replaceable>p</replaceable>_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsrsqrt">
      <title>vsip_<replaceable>ds</replaceable>rsqrt_<replaceable>p</replaceable></title>

      <para>Computes the reciprocal of the square root for each element of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:mi>1</m:mi>

                            <m:msqrt>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:msqrt>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:mi>1</m:mi>

                            <m:msqrt>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:msqrt>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vrsqrt_f(const vsip_vview_f *a, const vsip_vview_f *r);
void vsip_mrsqrt_f(const vsip_mview_f *a, const vsip_mview_f *r);
</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Input arguments less than or equal to zero are not in the
            domain of the function. The result is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/round.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>recip_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssq">
      <title>vsip_<replaceable>ds</replaceable>sq_<replaceable>p</replaceable></title>

      <para>Computes the square for each element of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsq_f(const vsip_vview_f *a, const vsip_vview_f *r);
void vsip_msq_f(const vsip_mview_f *a, const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Overflow will occur if an element’s magnitude is greater
            than the square root of the maximum defined number. The result of
            an overflow is implementation dependent.</para>

            <para>Underflow will occur if an element’s magnitude is less than
            the square root of the minimum defined number. The result of an
            underflow is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sq.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For complex, use
            <function>vsip_<replaceable>s</replaceable>cmagsq_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssumval">
      <title>vsip_<replaceable>ds</replaceable>sumval_<replaceable>p</replaceable></title>

      <para>Returns the sum of the elements of a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>sum<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>sum<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:mrow>
                                <m:munderover>
                                  <m:mo>∑</m:mo>

                                  <m:mrow>
                                    <m:mi>i</m:mi>

                                    <m:mo>=</m:mo>

                                    <m:mi>0</m:mi>
                                  </m:mrow>

                                  <m:mrow>
                                    <m:mi>M</m:mi>

                                    <m:mo>-</m:mo>

                                    <m:mi>1</m:mi>
                                  </m:mrow>
                                </m:munderover>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_i vsip_vsumval_i(const vsip_vview_i *a);
vsip_cscalar_i vsip_cvsumval_i(const vsip_cvview_i *a);
vsip_scalar_i vsip_msumval_i(const vsip_mview_i *a);
vsip_cscalar_i vsip_cmsumval_i(const vsip_cmview_i *a);
vsip_scalar_f vsip_vsumval_f(const vsip_vview_f *a);
vsip_cscalar_f vsip_cvsumval_f(const vsip_cvview_f *a);
vsip_scalar_f vsip_msumval_f(const vsip_mview_f *a);
vsip_cscalar_f vsip_cmsumval_f(const vsip_cmview_f *a);
vsip_scalar_vi vsip_vsumval_bl(const vsip_vview_bl *a);
vsip_scalar_vi vsip_msumval_bl(const vsip_mview_bl *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>If the input is a Boolean type, then the function returns an
            integer value of type <type>vsip_scalar_vi</type> consisting of
            the number of true values. Otherwise, it returns a scalar sum of
            the elements of the same type and precision as the input
            vector/matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If an overflow occurs, the result is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector/matrix passed to the function must be defined
                and must not be null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>A Boolean is defined so that zero is false and anything else
            is true. The boolean sumval function returns the number of non
            false values in a boolean object. The return type of
            <type>vsip_scalar_vi</type> for the boolean case was chosen since
            it resolves to an unsigned integer type large enough to represent
            the size of a vector, matrix, or tensor. This allows us to
            portably specify the integer return type. The order of summation
            is not specified, therefore significant numerical errors can
            potentially occur.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sumval.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>meanval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>ds</replaceable>meansqval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>sumsqval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssumsqval">
      <title>vsip_<replaceable>ds</replaceable>sumsqval_<replaceable>p</replaceable></title>

      <para>Returns the sum of the squares of the elements of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>sumsq<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>sumsq<m:malignmark/></m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:munderover>
                                <m:mo>∑</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>=</m:mo>

                                  <m:mi>0</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>N</m:mi>

                                  <m:mo>-</m:mo>

                                  <m:mi>1</m:mi>
                                </m:mrow>
                              </m:munderover>

                              <m:mrow>
                                <m:munderover>
                                  <m:mo>∑</m:mo>

                                  <m:mrow>
                                    <m:mi>i</m:mi>

                                    <m:mo>=</m:mo>

                                    <m:mi>0</m:mi>
                                  </m:mrow>

                                  <m:mrow>
                                    <m:mi>M</m:mi>

                                    <m:mo>-</m:mo>

                                    <m:mi>1</m:mi>
                                  </m:mrow>
                                </m:munderover>

                                <m:msup>
                                  <m:mrow>
                                    <m:mo>(</m:mo>

                                    <m:msub>
                                      <m:mi>a</m:mi>

                                      <m:mi>i,j</m:mi>
                                    </m:msub>

                                    <m:mo>)</m:mo>
                                  </m:mrow>

                                  <m:mi>2</m:mi>
                                </m:msup>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vsumsqval_f(const vsip_vview_f *a);
vsip_scalar_f vsip_msumsqval_f(const vsip_mview_f *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the sum of the vector elements squared.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If an overflow occurs, the result is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The vector/matrix passed to the function must be defined
                and must not be null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The order of summation is not specified, therefore
            significant numerical errors can potentially occur.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sumsqval.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>meanval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>ds</replaceable>meansqval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>sumval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Binary Operations</title>

    <para>The following man pages represent operations requiring two inputs,
    either two vectors/matrices or a vector/matrix and a scalar for
    input.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>add_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Add</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sadd_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Add</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Divide</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Divide</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Scalar Divide</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>expoavg_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Exponential Average</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>hypot_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Hypotenuse</entry>
          </row>

          <row>
            <entry><function>vsip_c<replaceable>s</replaceable>jmul_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Conjugate Multiply (Elementwise)</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>mul_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Multiply (Elementwise)</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>smul_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Multiply</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vdmmul_<replaceable>p</replaceable></function></entry>

            <entry>Vector-Matrix Multiply (Elementwise)</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>sub_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Subtract</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>ssub_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Subtract</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dsadd">
      <title>vsip_<replaceable>ds</replaceable>add_<replaceable>p</replaceable></title>

      <para>Computes the sum, by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>+</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>+</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vadd_<replaceable>i</replaceable>(const vsip_vview_<replaceable>i</replaceable> *a, const vsip_vview_<replaceable>i</replaceable> *b,
                 const vsip_vview_<replaceable>i</replaceable> *r);
void vsip_vadd_<replaceable>f</replaceable>(const vsip_vview_<replaceable>f</replaceable> *a, const vsip_vview_<replaceable>f</replaceable> *b,
                 const vsip_vview_<replaceable>f</replaceable> *r);
void vsip_rcvadd_<replaceable>f</replaceable>(const vsip_vview_<replaceable>f</replaceable> *a, const vsip_cvview_<replaceable>f</replaceable> *b,
                   const vsip_cvview_<replaceable>f</replaceable> *r);
void vsip_cvadd_<replaceable>f</replaceable>(const vsip_cvview_<replaceable>f</replaceable> *a, const vsip_cvview_<replaceable>f</replaceable> *b,
                  const vsip_cvview_<replaceable>f</replaceable> *r);
void vsip_madd_<replaceable>i</replaceable>(const vsip_mview_<replaceable>i</replaceable> *a, const vsip_mview_<replaceable>i</replaceable> *b, 
                 const vsip_mview_<replaceable>i</replaceable> *r);
void vsip_madd_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *a, const vsip_mview_<replaceable>f</replaceable> *b,
                 const vsip_mview_<replaceable>f</replaceable> *r);
void vsip_rcmadd_<replaceable>f</replaceable>(const vsip_mview_<replaceable>f</replaceable> *a, const vsip_cmview_<replaceable>f</replaceable> *b,
                   const vsip_cmview_<replaceable>f</replaceable> *r);
void vsip_cmadd_<replaceable>f</replaceable>(const vsip_cmview_<replaceable>f</replaceable> *a, const vsip_cmview_<replaceable>f</replaceable> *b,
                  const vsip_cmview_<replaceable>f</replaceable> *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If an overflow occurs, the result is implementation
            dependent.</para>

            <para>In the case of a mixed data type, for instance a real vector
            added to a complex vector, in-place implies the real input may be
            a real or imaginary view of the output. Input views which
            encompass both real and imaginary segments of the output, or which
            do not exactly overlay the real or imaginary view of the output,
            are not defined for in-place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/add.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>sadd_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssadd">
      <title>vsip_<replaceable>ds</replaceable>sadd_<replaceable>p</replaceable></title>

      <para>Computes the sum, by element, of a scalar and a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>+</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>+</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svadd_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_i *r);
void vsip_svadd_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_f *r);
void vsip_rscvadd_f(vsip_scalar_f alpha, const vsip_cvview_f *b, 
                    const vsip_cvview_f *r);
void vsip_csvadd_f(vsip_cscalar_f alpha, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_smadd_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_i *r);
void vsip_smadd_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_f *r);
void vsip_rscmadd_f(vsip_scalar_f alpha, const vsip_cmview_f *b, 
                    const vsip_cmview_f *r);
void vsip_csmadd_f(vsip_cscalar_f alpha, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sadd.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>add_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsdiv">
      <title>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></title>

      <para>Computes the quotient, by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vdiv_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_f *r);
void vsip_rcvdiv_f(const vsip_vview_f *a, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_crvdiv_f(const vsip_cvview_f *a, const vsip_vview_f *b, 
                   const vsip_cvview_f *r);
void vsip_cvdiv_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                  const vsip_cvview_f *r);
void vsip_mdiv_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_f *r);
void vsip_rcmdiv_f(const vsip_mview_f *a, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);
void vsip_crmdiv_f(const vsip_cmview_f *a, const vsip_mview_f *b, 
                   const vsip_cmview_f *r);
void vsip_cmdiv_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                  const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Results of division by zero are implementation
            dependent.</para>

            <para>Overflows and underflows are possible. Results are
            implementation dependent.</para>

            <para>In the case of a mixed data type, for instance a real vector
            divided by a complex vector, in-place implies the real input may
            be a real or imaginary view of the output. Input views which
            encompass both real and imaginary segments of the output, or which
            do not exactly overlay the real or imaginary view of the output,
            are not defined for in-place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/div.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>div_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssdiv">
      <title>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>div_<replaceable>p</replaceable></title>

      <para>Computes the quotient, by element, of a scalar and a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:mi>α</m:mi>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:mi>α</m:mi>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svdiv_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_f *r);
void vsip_rscvdiv_f(vsip_scalar_f alpha, const vsip_cvview_f *b, 
                    const vsip_cvview_f *r);
void vsip_csvdiv_f(vsip_cscalar_f alpha, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_smdiv_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_f *r);
void vsip_rscmdiv_f(vsip_scalar_f alpha, const vsip_cmview_f *b, 
                    const vsip_cmview_f *r);
void vsip_csmdiv_f(vsip_cscalar_f alpha, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The result of division by zero is implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sdiv.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dSsdiv">
      <title>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></title>

      <para>Computes the quotient, by element, of a vector/matrix and a
      scalar.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mi>β</m:mi>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mfrac>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mi>β</m:mi>
                          </m:mfrac>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsdiv_f(const vsip_vview_f *a, vsip_scalar_f beta, 
                  const vsip_vview_f *r);
void vsip_cvrsdiv_f(const vsip_cvview_f *a, vsip_scalar_f beta, 
                    const vsip_cvview_f *r);
void vsip_msdiv_f(const vsip_mview_f *a, vsip_scalar_f beta, 
                  const vsip_mview_f *r);
void vsip_cmrsdiv_f(const vsip_cmview_f *a, vsip_scalar_f beta, 
                    const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Division by zero is not defined and the result is
            implementation specific.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>This function was included for those who require increased
            accuracy when doing a divide. It is recommended that
            <function>vsip_dssmul_p</function> be used if increased accuracy
            is not required. The increased accuracy of using vector/matrix
            scalar divide is implementation dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/ssdiv.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>The function
            <function>vsip_<replaceable>ds</replaceable>smul_<replaceable>p</replaceable></function>
            is recommended for most cases where the multiplying scalar is the
            inverse of the divisor of
            <function>vsip_<replaceable>ds</replaceable>sdiv_<replaceable>p</replaceable></function>.
            <function>vsip_<replaceable>ds</replaceable>smul_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>ds</replaceable>div_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>div_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsexpoavg">
      <title>vsip_<replaceable>ds</replaceable>expoavg_<replaceable>p</replaceable></title>

      <para>Computes an exponential weighted average, by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>c</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mi>α</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:mrow>
                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mn>1</m:mn>

                                  <m:mo>-</m:mo>

                                  <m:mi>α</m:mi>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>c</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>c</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mi>α</m:mi>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:mrow>
                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mn>1</m:mn>

                                  <m:mo>-</m:mo>

                                  <m:mi>α</m:mi>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>c</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>where α is the weighting factor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vexpoavg_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                     const vsip_vview_f *c);
void vsip_mexpoavg_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                     const vsip_mview_f *c);
void vsip_cvexpoavg_f(vsip_scalar_f alpha, const vsip_cvview_f *b, 
                      const vsip_cvview_f *c);
void vsip_cmexpoavg_f(vsip_scalar_f alpha, const vsip_cmview_f *b, 
                      const vsip_cmview_f *c);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Scalar weighting factor</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Division by zero is not defined and the result is
            implementation specific.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If this function is called <inlineequation>
                <m:math display="inline">
                  <m:mi>L</m:mi>
                </m:math>
              </inlineequation> times with input vectors <inlineequation>
                <m:math display="inline">
                  <m:msub>
                    <m:mi>b</m:mi>

                    <m:mi>l</m:mi>
                  </m:msub>
                </m:math>
              </inlineequation> (and recursively with vector <inlineequation>
                <m:math display="inline">
                  <m:mi>c</m:mi>
                </m:math>
              </inlineequation>) and the weight is set equal to the inverse of
            the iteration number <inlineequation>
                <m:math display="inline">
                  <m:mi>l</m:mi>
                </m:math>
              </inlineequation>, (<inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>α</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mn>1</m:mn>

                      <m:mo>/</m:mo>

                      <m:mi>l</m:mi>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation>), then the result will be an average of the
            vectors <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:mi>c</m:mi>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mfrac>
                        <m:mi>1</m:mi>

                        <m:mi>L</m:mi>
                      </m:mfrac>

                      <m:mo>⁢</m:mo>

                      <m:mrow>
                        <m:munderover>
                          <m:mo>∑</m:mo>

                          <m:mrow>
                            <m:mi>l</m:mi>

                            <m:mo>=</m:mo>

                            <m:mi>1</m:mi>
                          </m:mrow>

                          <m:mi>L</m:mi>
                        </m:munderover>

                        <m:msub>
                          <m:mi>b</m:mi>

                          <m:mi>l</m:mi>
                        </m:msub>
                      </m:mrow>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/expoavg.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="shypot">
      <title>vsip_<replaceable>s</replaceable>hypot_<replaceable>p</replaceable></title>

      <para>Computes the square root of the sum of squares, by element, of two
      input vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:msqrt>
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>

                              <m:mo>+</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:msub>
                                    <m:mi>b</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>
                            </m:mrow>
                          </m:msqrt>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:msqrt>
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>i,j</m:mi>
                                  </m:msub>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>

                              <m:mo>+</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>(</m:mo>

                                  <m:msub>
                                    <m:mi>b</m:mi>

                                    <m:mi>i,j</m:mi>
                                  </m:msub>

                                  <m:mo>)</m:mo>
                                </m:mrow>

                                <m:mn>2</m:mn>
                              </m:msup>
                            </m:mrow>
                          </m:msqrt>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vhypot_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                   const vsip_vview_f *r);
void vsip_mhypot_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                   const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The implementation shall ensure that intermediate overflows
            do not occur.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/hypot.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>This is a companion function for
            <function>vsip_<replaceable>s</replaceable>atan2_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="csjmul">
      <title>vsip_s<replaceable>s</replaceable>jmul_<replaceable>p</replaceable></title>

      <para>Computes the product of a complex vector/matrix with the conjugate
      of a second complex vector/matrix, by element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:msubsup>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>

                              <m:mn>*</m:mn>
                            </m:msubsup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:msubsup>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>

                              <m:mn>*</m:mn>
                            </m:msubsup>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_cvjmul_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_cmjmul_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of conjugate multiplier input
                  vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Results of underflows or overflows are implementation
            dependent.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/jmul.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>mul_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>mul_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vdmmul_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsmul">
      <title>vsip_<replaceable>ds</replaceable>mul_<replaceable>p</replaceable></title>

      <para>Computes the product, by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmul_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_i *r);
void vsip_vmul_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_f *r);
void vsip_rcvmul_f(const vsip_vview_f *a, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_cvmul_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                  const vsip_cvview_f *r);
void vsip_mmul_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_i *r);
void vsip_mmul_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_f *r);
void vsip_rcmmul_f(const vsip_mview_f *a, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);
void vsip_cmmul_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                  const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In the case of a mixed data type, for instance a real vector
            multiplied by a complex vector, in-place implies the real input
            may be a real or imaginary view of the output. Input views which
            encompass both real and imaginary segments of the output, or which
            do not exactly overlay the real or imaginary view of the output,
            are not defined for in-place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/mul.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_c<replaceable>s</replaceable>jmul_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>mul_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>v<replaceable>d</replaceable>mmul_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssmul">
      <title>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>mul_<replaceable>p</replaceable></title>

      <para>Computes the product, by element, of a scalar and a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svmul_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_f *r);
void vsip_rscvmul_f(vsip_scalar_f alpha, const vsip_cvview_f *b, 
                    const vsip_cvview_f *r);
void vsip_csvmul_f(vsip_cscalar_f alpha, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_smmul_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_f *r);
void vsip_rscmmul_f(vsip_scalar_f alpha, const vsip_cmview_f *b, 
                    const vsip_cmview_f *r);
void vsip_csmmul_f(vsip_cscalar_f alpha, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/smul.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_c<replaceable>s</replaceable>jmul_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>ds</replaceable>mul_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>v<replaceable>d</replaceable>mmul_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvdmmul">
      <title>vsip_<replaceable>d</replaceable>v<replaceable>d</replaceable>mmul_<replaceable>p</replaceable></title>

      <para>Computes the product, by element, of a vector and the rows or
      columns of a matrix</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmmul_f(const vsip_vview_f *a, const vsip_mview_f *b, 
                  vsip_major major, const vsip_mview_f *r);
void vsip_cvmmul_f(const vsip_cvview_f *a, const vsip_cmview_f *b, 
                   vsip_major major, const vsip_cmview_f *r);
void vsip_rvcmmul_f(const vsip_vview_f *a, const vsip_cmview_f *b, 
                    vsip_major major, const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>Vector view - by rows: length N, by columns: length
                  M</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>Matrix view - size M by N</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>major</term>

                <listitem>
                  <para>Apply by element to the rows or the columns</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>Result matrix view - size M by N</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following: Assuming an
            input matrix B of size M rows by N columns then we have the
            following conditions:</para>

            <orderedlist>
              <listitem>
                <para>The input and output views must be conformant.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The major argument must be valid. <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>major</m:mi>

                        <m:mo>∈</m:mo>

                        <m:mrow>
                          <m:mo>{</m:mo>

                          <m:mrow>
                            <m:mi>VSIP_ROW</m:mi>

                            <m:mo>,</m:mo>

                            <m:mi>VSIP_COL</m:mi>
                          </m:mrow>

                          <m:mo>}</m:mo>
                        </m:mrow>
                      </m:mrow>
                    </m:math>
                  </inlineequation></para>
              </listitem>

              <listitem>
                <para>The input and output matrix views must be identical
                views of the same block (in-place), or must not overlap. The
                input vector view and output matrix view must not
                overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><parameter/></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_c<replaceable>s</replaceable>jmul_<replaceable>p</replaceable></function>,
            <function>vsip_d<replaceable>s</replaceable>mul_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>mul_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dssub">
      <title>vsip_<replaceable>ds</replaceable>sub_<replaceable>p</replaceable></title>

      <para>Computes the difference, by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsub_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_i *r);
void vsip_vsub_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_f *r);
void vsip_rcvsub_f(const vsip_vview_f *a, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_crvsub_f(const vsip_cvview_f *a, const vsip_vview_f *b, 
                   const vsip_cvview_f *r);
void vsip_cvsub_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                  const vsip_cvview_f *r);
void vsip_msub_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_i *r);
void vsip_msub_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_f *r);
void vsip_rcmsub_f(const vsip_mview_f *a, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);
void vsip_crmsub_f(const vsip_cmview_f *a, const vsip_mview_f *b, 
                   const vsip_cmview_f *r);
void vsip_cmsub_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                  const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In the case of a mixed data type in-place implies the real
            input may be a real or imaginary view of the output. Input views
            which encompass both real and imaginary segments of the output, or
            which do not exactly overlay the real or imaginary view of the
            output, are not defined for in- place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sub.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dsssub">
      <title>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>sub_<replaceable>p</replaceable></title>

      <para>Computes the difference, by element, of a scalar and a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svsub_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_i *r);
void vsip_svsub_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_f *r);
void vsip_rscvsub_f(vsip_scalar_f alpha, const vsip_cvview_f *b, 
                    const vsip_cvview_f *r);
void vsip_csvsub_f(vsip_cscalar_f alpha, const vsip_cvview_f *b, 
                   const vsip_cvview_f *r);
void vsip_smsub_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_i *r);
void vsip_smsub_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_f *r);
void vsip_rscmsub_f(vsip_scalar_f alpha, const vsip_cmview_f *b, 
                    const vsip_cmview_f *r);
void vsip_csmsub_f(vsip_cscalar_f alpha, const vsip_cmview_f *b, 
                   const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>To subtract a scalar from a vector just multiply the scalar
            by minus one and use <function>vsip_svadd_f</function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/ssub.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Ternary Operations</title>

    <para>This section contains transformations which require three inputs;
    either three vectors, two vectors and a scalar, or two scalars and a
    vector.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function></entry>

            <entry>Vector Add and Multiply</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function></entry>

            <entry>Vector Multiply and Add</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function></entry>

            <entry>Vector Multiply, Scalar Add</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function></entry>

            <entry>Vector Multiply and Subtract</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function></entry>

            <entry>Vector Scalar Add, Vector Multiply</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function></entry>

            <entry>Vector Subtract and Multiply</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function></entry>

            <entry>Vector Scalar Multiply, Vector Add</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></entry>

            <entry>Vector Scalar Multiply, Scalar Add</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dvam">
      <title>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></title>

      <para>Computes the sum of two vectors and product of a third vector, by
      element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>+</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>⁢</m:mo>

                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vam_f(vsip_vview_f const *a, vsip_vview_f const *b, 
                vsip_vview_f const *c, vsip_vview_f const *r);
void vsip_cvam_f(vsip_cvview_f const *a, vsip_cvview_f const *b, 
                 vsip_cvview_f const *c, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/am.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvma">
      <title>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></title>

      <para>Computes the product of two vectors and sum of a third vector, by
      element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>*</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vma_f(vsip_vview_f const *a, vsip_vview_f const *b, 
                vsip_vview_f const *c, vsip_vview_f const *r);
void vsip_cvma_f(vsip_cvview_f const *a, vsip_cvview_f const *b, 
                 vsip_cvview_f const *c, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/ma.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvmsa">
      <title>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></title>

      <para>Computes the product of two vectors and sum of a scalar, by
      element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>*</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:mi>α</m:mi>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmsa_f(vsip_vview_f const *a, vsip_vview_f const *b, 
                 vsip_scalar_f alpha, vsip_vview_f const *r);
void vsip_cvmsa_f(vsip_cvview_f const *a, vsip_cvview_f const *b, 
                  vsip_scalar_f alpha, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/msa.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvmsb">
      <title>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></title>

      <para>Computes the product of two vectors and difference of a third
      vector, by element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>*</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>-</m:mo>

                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmsb_f(vsip_vview_f const *a, vsip_vview_f const *b, 
                 vsip_vview_f const *c, vsip_vview_f const *r);
void vsip_cvmsb_f(vsip_cvview_f const *a, vsip_cvview_f const *b, 
                  vsip_cvview_f const *c, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/msb.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsam_p</function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvsam">
      <title>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></title>

      <para>Computes the sum of a vector and a scalar, and product with a
      second vector, by element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>+</m:mo>

                                <m:mi>β</m:mi>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>*</m:mo>

                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsam_f(vsip_vview_f const *a, vsip_scalar_f beta, 
                 vsip_vview_f const *c, vsip_vview_f const *r);
void vsip_cvsam_f(vsip_cvview_f const *a, vsip_cscalar_f beta, 
                  vsip_cvview_f const *c, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sam.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvsbm">
      <title>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></title>

      <para>Computes the difference of two vectors, and product with a third
      vector, by element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>-</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>*</m:mo>

                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsbm_f(vsip_vview_f const *a, vsip_vview_f const *b, 
                 vsip_vview_f const *c, vsip_vview_f const *r);
void vsip_cvsbm_f(vsip_cvview_f const *a, vsip_cvview_f const *b, 
                  vsip_cvview_f const *c, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sbm.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable>,
            vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable>,
            vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable>,
            vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable>,
            vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable>,
            vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable>,
            and
            vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvsma">
      <title>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></title>

      <para>Computes the product of a vector and a scalar, and sum with a
      second vector, by element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>*</m:mo>

                                <m:mi>β</m:mi>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsma_f(vsip_vview_f const *a, vsip_scalar_f beta, 
                 vsip_vview_f const *c, vsip_vview_f const *r);
void vsip_cvsma_f(vsip_cvview_f const *a, vsip_cscalar_f beta, 
                  vsip_cvview_f const *c, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/sma.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="dvsmsa">
      <title>vsip_<replaceable>d</replaceable>vsmsa_<replaceable>p</replaceable></title>

      <para>Computes the product of a vector and a scalar, and sum with a
      second scalar, by element.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>*</m:mo>

                                <m:mi>β</m:mi>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>

                            <m:mo>+</m:mo>

                            <m:mi>γ</m:mi>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vsmsa_f(vsip_vview_f const *a, vsip_scalar_f beta, 
                  vsip_scalar_f gamma, vsip_vview_f const *r);
void vsip_cvsmsa_f(vsip_cvview_f const *a, vsip_cscalar_f beta, 
                   vsip_cscalar_f gamma, vsip_cvview_f const *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>gamma</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/smsa.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>d</replaceable>vam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vma_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsa_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vmsb_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsam_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>d</replaceable>vsbm_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>d</replaceable>vsma_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Logical Operations</title>

    <para>The following functions are of two types. The first type compare two
    vectors/matrices elementwise using a logical test and returns a Boolean
    true or false depending on the result of the test. The second type tests a
    Boolean vector/matrix and produces a Boolean true or false depending on
    the state of the Boolean vector.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>s</replaceable>alltrue_bl</function></entry>

            <entry>Vector/Matrix All True</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>anytrue_bl</function></entry>

            <entry>Vector/Matrix Any True</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>leq_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Logical Equal</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>d</replaceable>s<replaceable>s</replaceable>leq_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Logical Equal</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>lge_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Logical Greater Than or Equal</entry>
          </row>

          <row>
            <entry><function>vsip_s<replaceable>s</replaceable>lge_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Logical Greater Than or Equal</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>lgt_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Logical Greater Than</entry>
          </row>

          <row>
            <entry><function>vsip_s<replaceable>s</replaceable>lgt_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Logical Greater Than</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>lle_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Logical Less Than or Equal</entry>
          </row>

          <row>
            <entry><function>vsip_s<replaceable>s</replaceable>lle_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Logical Less Than or Equal</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>llt_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Logical Less Than</entry>
          </row>

          <row>
            <entry><function>vsip_s<replaceable>s</replaceable>llt_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Logical Less Than</entry>
          </row>

          <row>
            <entry><function>vsip_d<replaceable>s</replaceable>lne_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Logical Not Equal</entry>
          </row>

          <row>
            <entry><function>vsip_ds<replaceable>s</replaceable>lne_<replaceable>p</replaceable></function></entry>

            <entry>Scalar Vector/Matrix Logical Not Equal</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="dalltrue">
      <title>vsip_<replaceable>s</replaceable>alltrue_bl</title>

      <para>Returns true if all the elements of a vector/matrix are
      true.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>all</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>⋀</m:mo>

                              <m:mi>j</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mi>1</m:mi>
                              </m:mrow>
                            </m:munderover>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>all</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>⋀</m:mo>

                              <m:mi>j</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mi>1</m:mi>
                              </m:mrow>
                            </m:munderover>

                            <m:munderover>
                              <m:mo>⋀</m:mo>

                              <m:mi>i</m:mi>

                              <m:mrow>
                                <m:mi>M</m:mi>

                                <m:mo>-</m:mo>

                                <m:mi>1</m:mi>
                              </m:mrow>
                            </m:munderover>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>where<inlineequation>
                <m:math display="inline">
                  <m:mo>⋀</m:mo>
                </m:math>
              </inlineequation>denotes logical "AND".</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_bl vsip_valltrue_bl(const vsip_vview_bl *a);
vsip_scalar_bl vsip_malltrue_bl(const vsip_mview_bl *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns <emphasis>false</emphasis> if any of the elements
            are false, otherwise it returns <emphasis>true</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/alltrue.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>anytrue_bl</function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="anytrue">
      <title>vsip_<replaceable>s</replaceable>anytrue_bl</title>

      <para>Returns true if one or more elements of a vector/matrix are
      true.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>all</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>⋁</m:mo>

                              <m:mi>j</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mi>1</m:mi>
                              </m:mrow>
                            </m:munderover>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>all</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:munderover>
                              <m:mo>⋁</m:mo>

                              <m:mi>j</m:mi>

                              <m:mrow>
                                <m:mi>N</m:mi>

                                <m:mo>-</m:mo>

                                <m:mi>1</m:mi>
                              </m:mrow>
                            </m:munderover>

                            <m:munderover>
                              <m:mo>⋁</m:mo>

                              <m:mi>i</m:mi>

                              <m:mrow>
                                <m:mi>M</m:mi>

                                <m:mo>-</m:mo>

                                <m:mi>1</m:mi>
                              </m:mrow>
                            </m:munderover>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>where<inlineequation>
                <m:math display="inline">
                  <m:mo>⋁</m:mo>
                </m:math>
              </inlineequation>denotes logical "OR".</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_bl vsip_vanytrue_bl(const vsip_vview_bl *a);
vsip_scalar_bl vsip_manytrue_bl(const vsip_mview_bl *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns <emphasis>false</emphasis> if any of the elements
            are false, otherwise it returns <emphasis>true</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/anytrue.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>alltrue_bl</function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="leq">
      <title>vsip_<replaceable>ds</replaceable>leq_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “equal,” by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vleq_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_bl *r);
void vsip_cvleq_i(const vsip_cvview_i *a, const vsip_cvview_i *b, 
                  const vsip_vview_bl *r);
void vsip_vleq_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_bl *r);
void vsip_cvleq_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                  const vsip_vview_bl *r);
void vsip_mleq_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_bl *r);
void vsip_cmleq_i(const vsip_cmview_i *a, const vsip_cmview_i *b, 
                  const vsip_mview_bl *r);
void vsip_mleq_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_bl *r);
void vsip_cmleq_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/leq.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sleq">
      <title>vsip_<replaceable>ds</replaceable>sleq_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “equal,” by element, of a
      scalar constant with a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svleq_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_bl *r);
void vsip_csvleq_i(vsip_cscalar_i alpha, const vsip_cvview_i *b, 
                   const vsip_vview_bl *r);
void vsip_svleq_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_bl *r);
void vsip_csvleq_f(vsip_cscalar_f alpha, const vsip_cvview_f *b, 
                   const vsip_vview_bl *r);
void vsip_smleq_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_bl *r);
void vsip_csmleq_i(vsip_cscalar_i alpha, const vsip_cmview_i *b, 
                   const vsip_mview_bl *r);
void vsip_smleq_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_bl *r);
void vsip_csmleq_f(vsip_cscalar_f alpha, const vsip_cmview_f *b, 
                   const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>A scalar constant</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="lge">
      <title>vsip_<replaceable>ds</replaceable>lge_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “greater than or equal,” by
      element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>≥</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>≥</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vlge_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_bl *r);
void vsip_vlge_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_bl *r);
void vsip_mlge_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_bl *r);
void vsip_mlge_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example see example with
            <function>vsip_<replaceable>ds</replaceable>gather_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="slge">
      <title>vsip_<replaceable>ds</replaceable>slge_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “greater than or equal,” by
      element, of a scalar constant with a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>≥</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>≥</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svlge_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_bl *r);
void vsip_svlge_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_bl *r);
void vsip_smlge_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_bl *r);
void vsip_smlge_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>A scalar constant</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="lgt">
      <title>vsip_<replaceable>ds</replaceable>lgt_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “greater than,” by element, of
      two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>&gt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>&gt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vlgt_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_bl *r);
void vsip_vlgt_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_bl *r);
void vsip_mlgt_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_bl *r);
void vsip_mlgt_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example see example with
            <function>vsip_<replaceable>ds</replaceable>scatter_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="slgt">
      <title>vsip_<replaceable>ds</replaceable>slgt_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “greater than,” by element, of
      a scalar constant with a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>&gt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>&gt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svlgt_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_bl *r);
void vsip_svlgt_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_bl *r);
void vsip_smlgt_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_bl *r);
void vsip_smlgt_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>A scalar constant</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example see example included with
            <function>vsip_<replaceable>ds</replaceable>scatter_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="lle">
      <title>vsip_<replaceable>ds</replaceable>lle_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “less than or equal,” by
      element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>≤</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>≤</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vlle_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_bl *r);
void vsip_vlle_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_bl *r);
void vsip_mlle_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_bl *r);
void vsip_mlle_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/lle.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="slle">
      <title>vsip_<replaceable>ds</replaceable>slle_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “less than or equal,” by
      element, of a scalar constant with a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>≤</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>≤</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svlle_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_bl *r);
void vsip_svlle_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_bl *r);
void vsip_smlle_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_bl *r);
void vsip_smlle_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="llt">
      <title>vsip_<replaceable>ds</replaceable>llt_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “less than,” by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>&lt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>&lt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vllt_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_bl *r);
void vsip_vllt_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_bl *r);
void vsip_mllt_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_bl *r);
void vsip_mllt_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/llt.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sllt">
      <title>vsip_<replaceable>ds</replaceable>sllt_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “less than,” by element, of a
      scalar constant with a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>&lt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>&lt;</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svllt_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_bl *r);
void vsip_svllt_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_bl *r);
void vsip_smllt_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_bl *r);
void vsip_smllt_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="lne">
      <title>vsip_<replaceable>ds</replaceable>lne_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “not equal,” by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>≠</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>≠</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vlne_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_bl *r);
void vsip_cvlne_i(const vsip_cvview_i *a, const vsip_cvview_i *b, 
                  const vsip_vview_bl *r);
void vsip_vlne_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_bl *r);
void vsip_cvlne_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                  const vsip_vview_bl *r);
void vsip_mlne_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_bl *r);
void vsip_cmlne_i(const vsip_cmview_i *a, const vsip_cmview_i *b, 
                  const vsip_mview_bl *r);
void vsip_mlne_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_bl *r);
void vsip_cmlne_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of vector logical not equal see example included
            with
            <function>vsip_<replaceable>s</replaceable>alltrue_<replaceable>bl</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="slne">
      <title>vsip_<replaceable>ds</replaceable>slne_<replaceable>p</replaceable></title>

      <para>Computes the boolean comparison of “not equal,” by element, of a
      scalar constant with a vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mi>for i = 0, 1, ..., M-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" linebreak="newline"
                                  width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>≠</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mi>for j = 0, 1, ..., N-1</m:mi>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mi>alpha</m:mi>

                          <m:mo>≠</m:mo>

                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mtext>else</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>true;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mtext>else</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow/>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="3em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>false;</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_svlne_i(vsip_scalar_i alpha, const vsip_vview_i *b, 
                  const vsip_vview_bl *r);
void vsip_csvlne_i(vsip_scalar_i alpha, const vsip_cvview_i *b, 
                   const vsip_vview_bl *r);
void vsip_svlne_f(vsip_scalar_f alpha, const vsip_vview_f *b, 
                  const vsip_vview_bl *r);
void vsip_csvlne_f(vsip_cscalar_f alpha, const vsip_cvview_f *b, 
                   const vsip_vview_bl *r);
void vsip_smlne_i(vsip_scalar_i alpha, const vsip_mview_i *b, 
                  const vsip_mview_bl *r);
void vsip_scmlne_i(vsip_scalar_i alpha, const vsip_cmview_i *b, 
                   const vsip_mview_bl *r);
void vsip_smlne_f(vsip_scalar_f alpha, const vsip_mview_f *b, 
                  const vsip_mview_bl *r);
void vsip_scmlne_f(vsip_cscalar_f alpha, const vsip_cmview_f *b, 
                   const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Input scalar</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of Boolean output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>Since the input and output vectors are of a different
            precision there is no in-place functionality for this
            function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Selection Operations</title>

    <para>The selection operations include functions which select an element
    or elements from an input vector/matrix or a pair of input
    vectors/matrices based on some logical comparison between two input
    vectors/matrices or a comparison between the elements of a single input
    vector/matrix and some selection criterion.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_sclip_p</function></entry>

            <entry>Vector/Matrix Clip</entry>
          </row>

          <row>
            <entry><function>vsip_svfirst_p</function></entry>

            <entry>Vector Find First Vector Index</entry>
          </row>

          <row>
            <entry><function>vsip_sinvclip_p</function></entry>

            <entry>Vector/Matrix Inverted Clip</entry>
          </row>

          <row>
            <entry><function>vsip_sindexbool</function></entry>

            <entry>Vector/Matrix Index a Boolean</entry>
          </row>

          <row>
            <entry><function>vsip_smax_p</function></entry>

            <entry>Vector/Matrix Maximum</entry>
          </row>

          <row>
            <entry><function>vsip_smaxmg_p</function></entry>

            <entry>Vector/Matrix Maximum Magnitude</entry>
          </row>

          <row>
            <entry><function>vsip_scmaxmgsq_p</function></entry>

            <entry>Vector/Matrix Complex Max Magnitude Squared</entry>
          </row>

          <row>
            <entry><function>vsip_scmaxmgsqval_p</function></entry>

            <entry>Vector/Matrix Complex Max Mag Squared Value</entry>
          </row>

          <row>
            <entry><function>vsip_smaxmgval_p</function></entry>

            <entry>Vector/Matrix Maximum Magnitude Value</entry>
          </row>

          <row>
            <entry><function>vsip_smaxval_p</function></entry>

            <entry>Vector/Matrix Maximum Value</entry>
          </row>

          <row>
            <entry><function>vsip_smin_p</function></entry>

            <entry>Vector/Matrix Minimum</entry>
          </row>

          <row>
            <entry><function>vsip_sminmg_p</function></entry>

            <entry>Vector/Matrix Minimum Magnitude</entry>
          </row>

          <row>
            <entry><function>vsip_scminmgsq_p</function></entry>

            <entry>Vector/Matrix Complex Min Magnitude Squared</entry>
          </row>

          <row>
            <entry><function>vsip_scminmgsqval_p</function></entry>

            <entry>Vector/Matrix Complex Min Mag Squared Value</entry>
          </row>

          <row>
            <entry><function>vsip_sminmgval_p</function></entry>

            <entry>Vector/Matrix Minimum Magnitude Value</entry>
          </row>

          <row>
            <entry><function>vsip_sminval_p</function></entry>

            <entry>Vector/Matrix Minimum Magnitude Value</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="clip">
      <title>vsip_<replaceable>s</replaceable>clip_<replaceable>p</replaceable></title>

      <para>Computes the generalized double clip, by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>For a vector/matrix a, filter each element according to the
            following rules, in order, producing the output vector/matrix r.
            Note that once a rule is met for an element the following rules
            are ignored.</para>

            <informalfigure floatstyle="right">
              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/clip.svg" format="SVG" scale="20"/>
                </imageobject>

                <imageobject>
                  <imagedata fileref="images/clip.png" format="PNG" scale="20"/>
                </imageobject>
              </mediaobject>
            </informalfigure>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>{</m:mo>

                      <m:mtable columnalign="left">
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>≤</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>=</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>2</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>2</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>otherwise</m:mtext>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>
                    </m:mrow>

                    <m:mrow>
                      <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>{</m:mo>

                      <m:mtable columnalign="left">
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>≤</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>=</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>2</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>2</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>otherwise</m:mtext>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>
                    </m:mrow>

                    <m:mrow>
                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:mtext>for i = 0, 1, ..., M-1</m:mtext>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mtext>for j = 0, 1,..., N-1</m:mtext>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vclip_f(const vsip_vview_f *a, vsip_scalar_f t1, vsip_scalar_f t2, 
                  vsip_scalar_f c1, vsip_scalar_f c2, const vsip_vview_f *r);
void vsip_vclip_i(const vsip_vview_i *a, vsip_scalar_i t1, vsip_scalar_i t2, 
                  vsip_scalar_i c1, vsip_scalar_i c2, const vsip_vview_i *r);
void vsip_mclip_f(const vsip_mview_f *a, vsip_scalar_f t1, vsip_scalar_f t2, 
                  vsip_scalar_f c1, vsip_scalar_f c2, const vsip_mview_f *r);
void vsip_mclip_i(const vsip_mview_i *a, vsip_scalar_i t1, vsip_scalar_i t2, 
                  vsip_scalar_i c1, vsip_scalar_i c2, const vsip_mview_i *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t1</term>

                <listitem>
                  <para>Lower threshold</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t2</term>

                <listitem>
                  <para>Upper threshold</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c1</term>

                <listitem>
                  <para>Lower threshold clip value</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c2</term>

                <listitem>
                  <para>Upper threshold clip value</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The clipping rules are evaluated (in order) sequentially.
            Once a rule is met, the following rules are ignored. The variables
            t1 and t2 are unrestricted; it is not an error if t2 &lt;
            t1.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry><mediaobject>
                          <imageobject>
                            <imagedata fileref="images/clip1.svg" format="SVG"
                                       scale="20"/>
                          </imageobject>

                          <imageobject>
                            <imagedata fileref="images/clip1.png" format="PNG"
                                       scale="20"/>
                          </imageobject>
                        </mediaobject></entry>

                      <entry><para>Single-sided limiter</para><programlisting>vsip_vview_sp *x, *y;
vsip_scalar_sp alpha;
...
vsip_vclip_sp(x, -VSIP_MAX_SP, alpha,
              -VSIP_MAX_SP, alpha, y);</programlisting></entry>
                    </row>

                    <row>
                      <entry><mediaobject>
                          <imageobject>
                            <imagedata fileref="images/clip2.svg" format="SVG"
                                       scale="20"/>
                          </imageobject>

                          <imageobject>
                            <imagedata fileref="images/clip2.png" format="PNG"
                                       scale="20"/>
                          </imageobject>
                        </mediaobject></entry>

                      <entry><para>Double-sided symmetric
                      limiter</para><programlisting>vsip_vview_i16 *x, *y;
vsip_scalar_i16 alpha;
...
vsip_vclip_i16(x,- alpha, alpha, 
               -alpha, alpha, y);</programlisting></entry>
                    </row>

                    <row>
                      <entry><mediaobject>
                          <imageobject>
                            <imagedata fileref="images/clip3.svg" format="SVG"
                                       scale="20"/>
                          </imageobject>

                          <imageobject>
                            <imagedata fileref="images/clip3.png" format="PNG"
                                       scale="20"/>
                          </imageobject>
                        </mediaobject></entry>

                      <entry><para>Bi-level thresholder</para><programlisting>vsip_vview_uc *x, *y;
vsip_scalar_uc alpha;
...
vsip_vclip_i16(x, alpha, alpha, 0, 1, y);</programlisting></entry>
                    </row>

                    <row>
                      <entry><mediaobject>
                          <imageobject>
                            <imagedata fileref="images/clip4.svg" format="SVG"
                                       scale="20"/>
                          </imageobject>

                          <imageobject>
                            <imagedata fileref="images/clip4.png" format="PNG"
                                       scale="20"/>
                          </imageobject>
                        </mediaobject></entry>

                      <entry><para>Clip off hi &amp;
                      low</para><programlisting>vsip_vview_uc *x, *y;
vsip_scalar_uc alpha, beta;
...
vsip_vclip_i16(x, alpha, beta, 0, 0, y);</programlisting></entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>

            <programlisting><xi:include href="examples/clip.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>invclip_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="first">
      <title>vsip_<replaceable>d</replaceable>vfirst_<replaceable>p</replaceable></title>

      <para>Returns the index of the first element of a pair of vector view
      objects for which a user-specified binary scalar function, applied by
      element, returns true.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Given a starting index j, a pair of vectors x and y, and a
            user-specified binary function f(xj, yj) returns:</para>

            <informaltable>
              <tgroup cols="2">
                <thead>
                  <row>
                    <entry align="center">Vector Index Return Value</entry>

                    <entry align="center">When</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><parameter>j</parameter></entry>

                    <entry>j ≦ length where length is the length in elements
                    of the vector view objects x and y</entry>
                  </row>

                  <row>
                    <entry><parameter>length</parameter></entry>

                    <entry>f(xj, yj) is false for all vector indices j, such
                    that 0 &lt;= j &lt; length where length is the length in
                    elements of the vector view objects x and y</entry>
                  </row>

                  <row>
                    <entry><parameter>First vector index j for which f(xj, yj)
                    is true </parameter></entry>

                    <entry>otherwise</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>Where f(xj, yj) is a user-specified binary function that
            takes two scalar elements as arguments and returns a boolean
            value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_index vsip_vfirst_f(vsip_index j, 
                         vsip_bool (*f)(vsip_scalar_f, vsip_scalar_f), 
                         const vsip_vview_f *x, const vsip_vview_f *y);
vsip_index vsip_vfirst_i(vsip_index j, 
                         vsip_bool (*f)(vsip_scalar_i, vsip_scalar_i), 
                         const vsip_vview_i *x, const vsip_vview_i *y);
vsip_index vsip_vfirst_bl(vsip_index j, 
                          vsip_bool (*f)(vsip_scalar_bl, vsip_scalar_bl), 
                          const vsip_vview_bl *x, const vsip_vview_bl *y);
vsip_index vsip_vfirst_vi(vsip_index j, 
                          vsip_bool (*f)(vsip_index, vsip_index), 
                          const vsip_vview_vi *x, const vsip_vview_vi *y);
vsip_index vsip_vfirst_mi(vsip_index j, 
                          vsip_bool (*f)(vsip_scalar_mi, vsip_scalar_mi), 
                          const vsip_vview_mi *x, const vsip_vview_mi *y);
vsip_index vsip_vfirst_ti(vsip_index j, 
                          vsip_bool (*f)(vsip_scalar_ti, vsip_scalar_ti), 
                          const vsip_vview_ti *x, const vsip_vview_ti *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>j</term>

                <listitem>
                  <para>User specified starting index of search</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>f</term>

                <listitem>
                  <para>User specified binary function of two scalars,
                  returning a boolean</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Vector view object of x operand</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Vector view object of y operand</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>This function returns a vector index value of:</para>

            <orderedlist>
              <listitem>
                <para>j, if j is greater than the length of the vector view
                arguments</para>
              </listitem>

              <listitem>
                <para>The length, if <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>f</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:msub>
                            <m:mi>x</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>
                        </m:mfenced>
                      </m:mrow>
                    </m:math>
                  </inlineequation> is false for all k<inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>j</m:mi>

                        <m:mo>≤</m:mo>

                        <m:mi>k</m:mi>

                        <m:mo>&lt;</m:mo>

                        <m:mi>length</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation></para>
              </listitem>

              <listitem>
                <para>The first vector index <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>k</m:mi>

                        <m:mo>≥</m:mo>

                        <m:mi>j</m:mi>
                      </m:mrow>
                    </m:math>
                  </inlineequation>, for which <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:mi>f</m:mi>

                        <m:mo>⁡</m:mo>

                        <m:mfenced>
                          <m:msub>
                            <m:mi>x</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>

                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>k</m:mi>
                          </m:msub>
                        </m:mfenced>
                      </m:mrow>
                    </m:math>
                  </inlineequation> is not false.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the user-specified function must be valid
                - non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>There are no complex versions of this function. This is a
            consequence of supporting the implementation of complex blocks
            with split storage, which is not compatible with a vsip_cscalar_p
            data type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="invclip">
      <title>vsip_<replaceable>s</replaceable>invclip_<replaceable>p</replaceable></title>

      <para>Computes the generalized inverted double clip, by element, of two
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>For vector/matrix a, filter each element according to the
            following rules producing an output vector/matrix r. Note that
            once a rule is met for an element the following rules are
            ignored.</para>

            <informalfigure floatstyle="right">
              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/clip1.svg" format="SVG"
                             scale="20"/>
                </imageobject>

                <imageobject>
                  <imagedata fileref="images/clip1.png" format="PNG"
                             scale="20"/>
                </imageobject>
              </mediaobject>
            </informalfigure>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>

                      <m:mi>j</m:mi>
                    </m:msub>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>{</m:mo>

                      <m:mtable columnalign="left">
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>&lt;</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>=</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>2</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>2</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>≤</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>3</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>otherwise</m:mtext>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>
                    </m:mrow>

                    <m:mrow>
                      <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>

            <para>or</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>r</m:mi>

                      <m:mi>i,j</m:mi>
                    </m:msub>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mo>{</m:mo>

                      <m:mtable columnalign="left">
                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>&lt;</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>1</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>1</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>=</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>2</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>c</m:mi>

                              <m:mn>2</m:mn>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>if</m:mtext>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>≤</m:mo>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mn>3</m:mn>
                              </m:msub>
                            </m:mrow>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mspace depth="0ex" height="0ex" width="2em"/>

                            <m:mtext>otherwise</m:mtext>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>
                    </m:mrow>

                    <m:mrow>
                      <m:mtable>
                        <m:mtr>
                          <m:mtd>
                            <m:mtext>for i = 0, 1, ..., M-1</m:mtext>
                          </m:mtd>
                        </m:mtr>

                        <m:mtr>
                          <m:mtd>
                            <m:mtext>for j = 0, 1,..., N-1</m:mtext>
                          </m:mtd>
                        </m:mtr>
                      </m:mtable>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vinvclip_f(const vsip_vview_f *a, 
                     vsip_scalar_f t1, vsip_scalar_f t2, vsip_scalar_f t3, 
                     vsip_scalar_f c1, vsip_scalar_f c2, const vsip_vview_f *r);
void vsip_vinvclip_i(const vsip_vview_i *a, 
                     vsip_scalar_i t1, vsip_scalar_i t2, vsip_scalar_i t3, 
                     vsip_scalar_i c1, vsip_scalar_i c2, const vsip_vview_i *r);
void vsip_minvclip_f(const vsip_mview_f *a, 
                     vsip_scalar_f t1, vsip_scalar_f t2, vsip_scalar_f t3, 
                     vsip_scalar_f c1, vsip_scalar_f c2, const vsip_mview_f *r);
void vsip_minvclip_i(const vsip_mview_i *a, 
                     vsip_scalar_i t1, vsip_scalar_i t2, vsip_scalar_i t3, 
                     vsip_scalar_i c1, vsip_scalar_i c2, const vsip_mview_i *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t1</term>

                <listitem>
                  <para>Lower threshold</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t2</term>

                <listitem>
                  <para>Mid threshold</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t3</term>

                <listitem>
                  <para>Upper threshold</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c1</term>

                <listitem>
                  <para>Lower threshold clip value</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>c2</term>

                <listitem>
                  <para>Upper threshold clip value</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The clipping rules are evaluated (in order) sequentially.
            Once a rule is met, the following rules are ignored. The variables
            t1, t2, and t3 are unrestricted; it is not an error if the
            relationship <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>t</m:mi>

                      <m:mn>1</m:mn>
                    </m:msub>

                    <m:mo>≤</m:mo>

                    <m:msub>
                      <m:mi>t</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>

                    <m:mo>≤</m:mo>

                    <m:msub>
                      <m:mi>t</m:mi>

                      <m:mn>3</m:mn>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation> does not hold.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry><mediaobject>
                          <imageobject>
                            <imagedata fileref="images/clip1.svg" format="SVG"
                                       scale="20"/>
                          </imageobject>

                          <imageobject>
                            <imagedata fileref="images/clip1.png" format="PNG"
                                       scale="20"/>
                          </imageobject>
                        </mediaobject></entry>

                      <entry><para>Clip out small
                      values</para><programlisting>vsip_vview_i16 *x, *y;
vsip_scalar_i16 alpha;
...
vsip_vinvclip_i16(x,-alpha, 0, alpha,
                  -alpha, alpha, y);</programlisting></entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>clip_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="indexbool">
      <title>vsip_<replaceable>s</replaceable>indexbool_<replaceable>p</replaceable></title>

      <para>Computes an index vector of the indices of the non-false elements
      of the boolean vector/matrix, and returns the number of non-false
      elements.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Returns an index vector of the indices of the non-false
            elements of the boolean vector b, or boolean matrix B. The index
            vector is ordered; lower indices appear before higher indices. For
            a matrix, elements appear in the index vector in accord with the
            major ordering of the matrix. If no non-false elements are found,
            the index vector is unmodified, otherwise the length of the vector
            view is set equal to the number of non-false elements.</para>

            <para>The Return value is the number of non-false elements.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_length vsip_vindexbool(const vsip_vview_bl *b, vsip_vview_vi *index);
vsip_length vsip_mindexbool(const vsip_mview_bl *b, vsip_vview_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input boolean vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>The Return value is the number of non-false elements.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The length of the return index vector is dependent on the
            number of non-false values in the boolean object. The user must
            make sure that the index vector's length attribute is greater than
            or equal to the maximum number of non-false elements expected. If
            the index vector is re-used for multiple calls, its length may
            change after each call; therefore, the user should reset the
            length to the maximum value.</para>

            <para>No in-place operations are allowed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The index vector must be of length greater than or equal
                to the number of non-false boolean elements.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>VSIPL does not support zero length vectors. It is important
            to test the return value for zero to handle the case of no
            non-false elements.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>indexbool_<replaceable>p</replaceable></function>
            see
            <function>vsip_<replaceable>ds</replaceable>gather_<replaceable>p</replaceable></function>
            example.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>gather_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>ds</replaceable>scatter_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="smax">
      <title>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></title>

      <para>Computes the maximum, by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>max</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>,</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>max</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>,</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmax_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_f *r);
void vsip_mmax_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/max.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="maxmg">
      <title>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></title>

      <para>Computes the maximum magnitude (absolute value), by element, of
      two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>max</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>max</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmaxmg_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                   const vsip_vview_f *r);
void vsip_mmaxmg_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                   const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/maxmg.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For complex data use
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>.</para>

            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cmaxmgsq">
      <title>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></title>

      <para>Computes the maximum magnitude squared, by element, of two complex
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>max</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>

                              <m:mo>,</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>b</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>max</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>i,j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>

                              <m:mo>,</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>b</m:mi>

                                    <m:mi>i,j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcmaxmg_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                    const vsip_vview_f *r);
void vsip_mcmaxmg_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                    const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In-place operation for this function means the output vector
            is either a real view, or an imaginary view, of one of the input
            vectors. No in-place operation is defined for an output vector
            which contains both real and imaginary components of an input
            vector, or which does not exactly overlap a real view or an
            imaginary view of one of the input vectors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/cmaxmgsq.c"
                parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For real data use
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>.</para>

            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cmaxmgsqval">
      <title>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></title>

      <para>Returns the index and value of the maximum magnitude squared of
      the elements of a complex vector/matrix. The index is returned by
      reference as one of the arguments.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>0</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />
                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>0,0</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>0</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>0</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for i = 1,2,...,M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>

                          <m:mo>&gt;</m:mo>

                          <m:mi>max</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="2em"/>

                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>j</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>

                          <m:mo>&gt;</m:mo>

                          <m:mi>max</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mtext/>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="3em"/>

                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />
			
                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>i</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>j</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Where: <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msup>
                      <m:mrow>
                        <m:mo>|</m:mo>

                        <m:mi>a</m:mi>

                        <m:mo>|</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msup>

                    <m:mo>≡</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mo>(</m:mo>

                          <m:mrow>
                            <m:mi>Re</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>a</m:mi>
                            </m:mfenced>
                          </m:mrow>

                          <m:mo>)</m:mo>
                        </m:mrow>

                        <m:mn>2</m:mn>
                      </m:msup>

                      <m:mo>+</m:mo>

                      <m:msup>
                        <m:mrow>
                          <m:mo>(</m:mo>

                          <m:mrow>
                            <m:mi>Im</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>a</m:mi>
                            </m:mfenced>
                          </m:mrow>

                          <m:mo>)</m:mo>
                        </m:mrow>

                        <m:mn>2</m:mn>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vcmaxmgsqval_f(const vsip_cvview_f *a, vsip_scalar_vi *index);
vsip_scalar_f vsip_mcmaxmgsqval_f(const vsip_cmview_f *a, vsip_scalar_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Pointer to index, if null the index is not
                  returned</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the maximum magnitude squared value of the elements.
            The index is returned using the index pointer, if non-null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector/matrix has more than one element with
            identical maximum magnitude squared values, the index of the first
            maximum magnitude squared is returned in the index.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/cmaxmgsqval.c"
                parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For real data use
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>.</para>

            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="maxmgval">
      <title>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></title>

      <para>Returns the index and value of the maximum absolute value of the
      elements of a vector/matrix. The index is returned by reference as one
      of the arguments.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0,0</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>0</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>0</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for i = 1,2,...,M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>

                          <m:mo>&gt;</m:mo>

                          <m:mi>max</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="2em"/>

                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>j</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>

                          <m:mo>&gt;</m:mo>

                          <m:mi>max</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mtext/>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="3em"/>

                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>i</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>j</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vmaxmgval_f(const vsip_vview_f *a, vsip_scalar_vi *index);
vsip_scalar_f vsip_mmaxmgval_f(const vsip_mview_f *a, vsip_scalar_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Pointer to index, if null the index is not
                  returned</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the maximum absolute value of the elements. The
            index is returned using the index pointer, if non-null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector/matrix has more than one element with
            identical maximum absolute value values, the index of the first
            maximum absolute value is returned in the index.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/maxmgval.c"
                parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>sc</replaceable>maxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="maxval">
      <title>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></title>

      <para>Returns the index and value of the maximum value of the elements
      of a vector/matrix. The index is returned by reference as one of the
      arguments.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0,0</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>0</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>0</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for i = 1,2,...,M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>

                          <m:mo>&gt;</m:mo>

                          <m:mi>max</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="2em"/>

                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>j</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>

                          <m:mo>&gt;</m:mo>

                          <m:mi>max</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mtext/>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="3em"/>

                          <m:mi>max</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>i</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>j</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vmaxval_f(const vsip_vview_f *a, vsip_scalar_vi *index);
vsip_scalar_f vsip_mmaxval_f(const vsip_mview_f *a, vsip_scalar_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Pointer to index, if null the index is not
                  returned</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the maximum value of the elements. The index is
            returned using the index pointer, if non-null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector/matrix has more than one element with
            identical maximum values, the index of the first maximum is
            returned in the index.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/maxval.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>sc</replaceable>maxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="smin">
      <title>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></title>

      <para>Computes the minimum, by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>min</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>,</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>min</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>,</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmin_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_f *r);
void vsip_mmin_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>
            see example with
            <function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="minmg">
      <title>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></title>

      <para>Computes the minimum magnitude (absolute value), by element, of
      two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>min</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>min</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>

                              <m:mo>,</m:mo>

                              <m:mrow>
                                <m:mo>|</m:mo>

                                <m:msub>
                                  <m:mi>b</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>

                                <m:mo>|</m:mo>
                              </m:mrow>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vminmg_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                   const vsip_vview_f *r);
void vsip_mminmg_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                   const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>
            see example with
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For complex data use
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>.</para>

            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cminmgsq">
      <title>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></title>

      <para>Computes the maximum magnitude squared, by element, of two complex
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>min</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>

                              <m:mo>,</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>b</m:mi>

                                    <m:mi>j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>min</m:mi>

                          <m:mrow>
                            <m:mo>{</m:mo>

                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>a</m:mi>

                                    <m:mi>i,j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>

                              <m:mo>,</m:mo>

                              <m:msup>
                                <m:mrow>
                                  <m:mo>|</m:mo>

                                  <m:msub>
                                    <m:mi>b</m:mi>

                                    <m:mi>i,j</m:mi>
                                  </m:msub>

                                  <m:mo>|</m:mo>
                                </m:mrow>

                                <m:mi>2</m:mi>
                              </m:msup>
                            </m:mrow>

                            <m:mo>}</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcminmg_f(const vsip_cvview_f *a, const vsip_cvview_f *b, 
                    const vsip_vview_f *r);
void vsip_mcminmg_f(const vsip_cmview_f *a, const vsip_cmview_f *b, 
                    const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>None</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In-place operation for this function means the output vector
            is either a real view, or an imaginary view, of one of the input
            vectors. No in-place operation is defined for an output vector
            which contains both real and imaginary components of an input
            vector, or which does not exactly overlap a real view or an
            imaginary view of one of the input vectors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>
            see example of
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For real data use
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>.</para>

            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="cminmgsqval">
      <title>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></title>

      <para>Returns the index and value of the minimum magnitude squared of
      the elements of a complex vector/matrix. The index is returned by
      reference as one of the arguments.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>0</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>0,0</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>0</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>0</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for i = 1,2,...,M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>

                          <m:mo>&lt;</m:mo>

                          <m:mi>min</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="2em"/>

                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>j</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>

                          <m:mo>&lt;</m:mo>

                          <m:mi>min</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mtext/>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="3em"/>

                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:msup>
                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>

                            <m:mi>2</m:mi>
                          </m:msup>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>i</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>j</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Where: <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msup>
                      <m:mrow>
                        <m:mo>|</m:mo>

                        <m:mi>a</m:mi>

                        <m:mo>|</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msup>

                    <m:mo>≡</m:mo>

                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mo>(</m:mo>

                          <m:mrow>
                            <m:mi>Re</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>a</m:mi>
                            </m:mfenced>
                          </m:mrow>

                          <m:mo>)</m:mo>
                        </m:mrow>

                        <m:mn>2</m:mn>
                      </m:msup>

                      <m:mo>+</m:mo>

                      <m:msup>
                        <m:mrow>
                          <m:mo>(</m:mo>

                          <m:mrow>
                            <m:mi>Im</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>a</m:mi>
                            </m:mfenced>
                          </m:mrow>

                          <m:mo>)</m:mo>
                        </m:mrow>

                        <m:mn>2</m:mn>
                      </m:msup>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vcminmgsqval_f(const vsip_cvview_f *a, vsip_scalar_vi *index);
vsip_scalar_f vsip_mcminmgsqval_f(const vsip_cmview_f *a, vsip_scalar_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Pointer to index, if null the index is not
                  returned</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the minimum magnitude squared value of the elements.
            The index is returned using the index pointer, if non-null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector/matrix has more than one element with
            identical minimum magnitude squared values, the index of the first
            minimum magnitude squared is returned in the index.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>
            see
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>For real data use
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>.</para>

            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="minmgval">
      <title>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></title>

      <para>Returns the index and value of the minimum absolute value of the
      elements of a vector/matrix. The index is returned by reference as one
      of the arguments.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0,0</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>0</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>0</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for i = 1,2,...,M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>

                          <m:mo>&lt;</m:mo>

                          <m:mi>min</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="2em"/>

                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>j</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>

                          <m:mo>&lt;</m:mo>

                          <m:mi>min</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mtext/>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="3em"/>

                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>|</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>|</m:mo>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>i</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>j</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vminmgval_f(const vsip_vview_f *a, vsip_scalar_vi *index);
vsip_scalar_f vsip_mminmgval_f(const vsip_mview_f *a, vsip_scalar_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Pointer to index, if null the index is not
                  returned</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the minimum absolute value of the elements. The
            index is returned using the index pointer, if non-null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector/matrix has more than one element with
            identical minimum absolute value values, the index of the first
            minimum absolute value is returned in the index.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function>
            see example of
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>sc</replaceable>maxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="minval">
      <title>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></title>

      <para>Returns the index and value of the minimum value of the elements
      of a vector/matrix. The index is returned by reference as one of the
      arguments.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>0,0</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>0</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>0</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="0em"/>

                        <m:mtext>for i = 1,2,...,M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>

                          <m:mo>&lt;</m:mo>

                          <m:mi>min</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="1em"/>

                        <m:mtext>for j = 1,2,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="2em"/>

                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>j</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="0ex" height="0ex" width="2em"/>

                        <m:mtext>if</m:mtext>

                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>

                          <m:mo>&lt;</m:mo>

                          <m:mi>min</m:mi>
                        </m:mrow>
			<m:mspace width='.5em' />
                        <m:mtext>then</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mtext/>
                      </m:mtd>

                      <m:mtd>
                        <m:mrow>
                          <m:mspace depth="0ex" height="0ex" width="3em"/>

                          <m:mi>min</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>

                        <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                        <m:mrow>
                          <m:mi>index</m:mi>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:mi>i</m:mi>

                              <m:mo>,</m:mo>

                              <m:mi>j</m:mi>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>vsip_scalar_f vsip_vminval_f(const vsip_vview_f *a, vsip_scalar_vi *index);
vsip_scalar_f vsip_mminval_f(const vsip_mview_f *a, vsip_scalar_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>Pointer to index, if null the index is not
                  returned</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para>Returns the maximum value of the elements. The index is
            returned using the index pointer, if non-null.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>If the vector/matrix has more than one element with
            identical minimum values, the index of the first minimum is
            returned in the index.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>minval_<replaceable>p</replaceable></function>
            see example of
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>max_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmaxmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>sc</replaceable>maxmgsqval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxmgval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>maxval_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>min_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>minmg_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsq_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cminmgsqval_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>minmgval_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Bitwise and Boolean Logical Operations</title>

    <para>These functions correspond to by element application of bitwise
    logical operators to vectors/matrices of integers or logical operations to
    Boolean vectors/matrices.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>s</replaceable>and_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix AND</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>not_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix NOT</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>or_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix OR</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Exclusive OR</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="and">
      <title>vsip_<replaceable>s</replaceable>and_<replaceable>p</replaceable></title>

      <para>Computes the “AND,” by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>⋀</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⋀</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vand_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_i *r);
void vsip_mand_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_i *r);
void vsip_vand_bl(const vsip_vview_bl *a, const vsip_vview_bl *b, 
                  const vsip_vview_bl *r);
void vsip_mand_bl(const vsip_mview_bl *a, const vsip_mview_bl *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>For integers, the “AND” is bitwise, for booleans, it is
            logical.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/and.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>not_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>or_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="not">
      <title>vsip_<replaceable>s</replaceable>not_<replaceable>p</replaceable></title>

      <para>Computes the NOT (one's complement), by element, of a
      vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>¬</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mo>¬</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vnot_i(const vsip_vview_i *a, const vsip_vview_i *r);
void vsip_mnot_i(const vsip_mview_i *a, const vsip_mview_i *r);
void vsip_vnot_bl(const vsip_vview_bl *a, const vsip_vview_bl *r);
void vsip_mnot_bl(const vsip_mview_bl *a, const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>For integers, the “NOT” is bitwise, for booleans, it is
            logical.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/not.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>and_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>or_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="or">
      <title>vsip_<replaceable>s</replaceable>or_<replaceable>p</replaceable></title>

      <para>Computes the “OR,” by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>⋁</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⋁</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vor_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                const vsip_vview_i *r);
void vsip_mor_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                const vsip_mview_i *r);
void vsip_vor_bl(const vsip_vview_bl *a, const vsip_vview_bl *b, 
                 const vsip_vview_bl *r);
void vsip_mor_bl(const vsip_mview_bl *a, const vsip_mview_bl *b, 
                 const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>For integers, the “OR” is bitwise, for booleans, it is
            logical.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/or.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>and_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>not_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="xor">
      <title>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></title>

      <para>Computes the “XOR,” by element, of two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>⊕</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>⊕</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,...,M-1; for j =
                        0,1,...,N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vxor_i(const vsip_vview_i *a, const vsip_vview_i *b, 
                 const vsip_vview_i *r);
void vsip_mxor_i(const vsip_mview_i *a, const vsip_mview_i *b, 
                 const vsip_mview_i *r);
void vsip_vxor_bl(const vsip_vview_bl *a, const vsip_vview_bl *b, 
                  const vsip_vview_bl *r);
void vsip_mxor_bl(const vsip_mview_bl *a, const vsip_mview_bl *b, 
                  const vsip_mview_bl *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>For integers, the “XOR” is bitwise, for booleans, it is
            logical.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para><programlisting><xi:include href="examples/xor.c"
                  parse="text"/></programlisting></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>and_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>not_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>xor_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Element Generation and Copy</title>

    <para>The following functions generate elements to fill a vector/matrix
    view based upon scalar parameters. These include random numbers, scalar
    fills, and ramps.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>copy_<replaceable>p</replaceable>_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix/Tensor Copy</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>copyto_user_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Copy To User Memory</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>copyfrom_user_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Copy From User Memory</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>ds</replaceable>fill_<replaceable>p</replaceable></function></entry>

            <entry>Vector/Matrix Fill</entry>
          </row>

          <row>
            <entry><function>vsip_vramp_<replaceable>p</replaceable></function></entry>

            <entry>Vector Ramp</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="copy">
      <title>vsip_<replaceable>ds</replaceable>copy_<replaceable>p</replaceable>_<replaceable>p</replaceable></title>

      <para>Copy the source vector/matrix/tensor to the destination
      vector/matrix/tensor performing any necessary type conversion of the
      standard ANSI C scalar types.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Copies the source data of the source vector/matrix/tensor
            view object to the destination data of the destination
            vector/matrix/tensor view object performing any necessary type
            conversion of the standard ANSI C scalar types.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcopy_<replaceable>s</replaceable>_<replaceable>t</replaceable>(const vsip_vview_<replaceable>s</replaceable> *x, const vsip_vview_<replaceable>t</replaceable> *y);
void vsip_vcopy_vi_vi(const vsip_vview_vi *x, const vsip_vview_vi *y);
void vsip_vcopy_vi_i(const vsip_vview_vi *x, const vsip_vview_i *y);
void vsip_vcopy_i_vi(const vsip_vview_i *x, const vsip_vview_vi *y);
void vsip_vcopy_mi_mi(const vsip_vview_mi *x, const vsip_vview_mi *y);
void vsip_vcopy_ti_ti(const vsip_vview_ti *x, const vsip_vview_ti *y);
void vsip_vcopy_bl_<replaceable>t</replaceable>(const vsip_vview_bl *x, const vsip_vview_<replaceable>t</replaceable> *y);
void vsip_vcopy_<replaceable>s</replaceable>_bl(const vsip_vview_<replaceable>s</replaceable> *x, const vsip_vview_bl *y);
void vsip_cvcopy_<replaceable>s</replaceable>_<replaceable>t</replaceable>(const vsip_cvview_<replaceable>s</replaceable> *x, const vsip_cvview_<replaceable>t</replaceable> *y);
void vsip_mcopy_<replaceable>s</replaceable>_<replaceable>t</replaceable>(const vsip_mview_<replaceable>s</replaceable> *X, const vsip_mview_<replaceable>t</replaceable> *Y);
void vsip_mcopy_bl_<replaceable>t</replaceable>(const vsip_mview_bl *X, const vsip_mview_<replaceable>t</replaceable> *Y);
void vsip_mcopy_<replaceable>s</replaceable>_bl(const vsip_mview_<replaceable>s</replaceable> *X, const vsip_mview_bl *Y);
void vsip_cmcopy_<replaceable>s</replaceable>_<replaceable>t</replaceable>(const vsip_cmview_<replaceable>s</replaceable> *X, const vsip_cmview_<replaceable>t</replaceable> *Y);
void vsip_tcopy_<replaceable>s</replaceable>_<replaceable>t</replaceable>(const vsip_tview_<replaceable>s</replaceable> *X, const vsip_tview_<replaceable>t</replaceable> *Y);
void vsip_tcopy_bl_<replaceable>t</replaceable>(const vsip_tview_bl *X, const vsip_tview_<replaceable>t</replaceable> *Y);
void vsip_tcopy_<replaceable>s</replaceable>_bl(const vsip_tview_<replaceable>s</replaceable> *X, const vsip_tview_bl *Y);
void vsip_ctcopy_<replaceable>s</replaceable>_<replaceable>t</replaceable>(const vsip_ctview_<replaceable>s</replaceable> *X, const vsip_ctview_<replaceable>t</replaceable> *Y);</synopsis>

            <para>Where _<replaceable>s</replaceable>, and
            _<replaceable>t</replaceable> can be any combination of:</para>

            <informaltable>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry align="center"/>

                    <entry align="center">_s, _t</entry>

                    <entry align="center">ANSI C Type</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry morerows="9">_<replaceable>i</replaceable></entry>

                    <entry>_c</entry>

                    <entry>signed char</entry>
                  </row>

                  <row>
                    <entry>_si</entry>

                    <entry>short int</entry>
                  </row>

                  <row>
                    <entry>_i</entry>

                    <entry>int</entry>
                  </row>

                  <row>
                    <entry>_li</entry>

                    <entry>long int</entry>
                  </row>

                  <row>
                    <entry>_ll</entry>

                    <entry>long long int (non-ANSI)</entry>
                  </row>

                  <row>
                    <entry>_uc</entry>

                    <entry>unsigned char</entry>
                  </row>

                  <row>
                    <entry>_us</entry>

                    <entry>unsigned short int</entry>
                  </row>

                  <row>
                    <entry>_ui</entry>

                    <entry>unsigned int</entry>
                  </row>

                  <row>
                    <entry>_ul</entry>

                    <entry>unsigned long int</entry>
                  </row>

                  <row>
                    <entry>_ull</entry>

                    <entry>unsigned long long int (non-ANSI)</entry>
                  </row>

                  <row>
                    <entry morerows="2">_<replaceable>f</replaceable></entry>

                    <entry>_f</entry>

                    <entry>float</entry>
                  </row>

                  <row>
                    <entry>_d</entry>

                    <entry>double</entry>
                  </row>

                  <row>
                    <entry>_ld</entry>

                    <entry>long double</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <informaltable>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry align="center"/>

                    <entry align="center"/>

                    <entry align="center">VSIPL Type</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry/>

                    <entry>_vi</entry>

                    <entry>vsip_scalar_vi or vsip_index</entry>
                  </row>

                  <row>
                    <entry/>

                    <entry>_mi</entry>

                    <entry>vsip_scalar_mi</entry>
                  </row>

                  <row>
                    <entry/>

                    <entry>_ti</entry>

                    <entry>vsip_scalar_ti</entry>
                  </row>

                  <row>
                    <entry/>

                    <entry>_bl</entry>

                    <entry>vsip_scalar_bl or vsip_bool</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Source vector/matrix/tensor view object.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Destination vector/matrix/tensor view object.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If the source and destination overlap, the result is
            undefined.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Booleans as a source map false and true into 0 and 1 (or 0.0
            and 1.0) respectively. Booleans as a destination map 0 (or 0.0) to
            false and everything else to true.</para>

            <para>There are many possible different prototypes of this
            function. Most implementations will only support a small subset.
            Profiles may define required copy functionality. An example of the
            core profile required copies is below.</para>

            <para>Core Profile Required Copy functions</para>

            <informaltable>
              <tgroup cols="7">
                <colspec align="center"/>

                <thead>
                  <row>
                    <entry align="center">Vector</entry>

                    <entry align="center">_f</entry>

                    <entry align="center">_i</entry>

                    <entry align="center">_bl</entry>

                    <entry align="center">_vi</entry>

                    <entry align="center">_mi</entry>

                    <entry align="center">_ti</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry>_f</entry>

                    <entry>x</entry>

                    <entry>x</entry>

                    <entry>x</entry>

                    <entry/>

                    <entry/>

                    <entry/>
                  </row>

                  <row>
                    <entry>_i</entry>

                    <entry>x</entry>

                    <entry>x</entry>

                    <entry/>

                    <entry>x</entry>

                    <entry/>

                    <entry/>
                  </row>

                  <row>
                    <entry>_bl</entry>

                    <entry>x</entry>

                    <entry/>

                    <entry>x</entry>

                    <entry/>

                    <entry/>

                    <entry/>
                  </row>

                  <row>
                    <entry>_vi</entry>

                    <entry/>

                    <entry>x</entry>

                    <entry/>

                    <entry>x</entry>

                    <entry/>

                    <entry/>
                  </row>

                  <row>
                    <entry>_mi</entry>

                    <entry/>

                    <entry/>

                    <entry/>

                    <entry/>

                    <entry>x</entry>

                    <entry/>
                  </row>

                  <row>
                    <entry>_ti</entry>

                    <entry/>

                    <entry/>

                    <entry/>

                    <entry/>

                    <entry/>

                    <entry>x</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <informaltable>
              <tgroup cols="4">
                <colspec align="center"/>

                <thead>
                  <row>
                    <entry align="center">Matrix</entry>

                    <entry align="center">_f</entry>

                    <entry align="center">_i</entry>

                    <entry align="center">_bl</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry>_f</entry>

                    <entry>x</entry>

                    <entry/>

                    <entry/>
                  </row>

                  <row>
                    <entry>_i</entry>

                    <entry/>

                    <entry/>

                    <entry/>
                  </row>

                  <row>
                    <entry>_bl</entry>

                    <entry/>

                    <entry/>

                    <entry/>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>The “Core Profile” requires 11 vsip_vcopy + 1 vsip_mcopy + 1
            vsip_cvcopy + 1 vsip_cmcopy. There must be one base float _f type
            and one base integer _i type in a profile. (Typically the base
            types are float and int or double and int.) The base types must be
            fully supported in terms of the indicated table.</para>

            <para>If an implementation supports more than one float or integer
            type, it must support copy functions from/to that type to/from the
            base type as indicated by the table. For example, if the base
            types are float and int, and the library also supports long int
            and unsigned char, then the following additional copy routines are
            required to support the copy to/from the base int type:</para>

            <para>vsip_vcopy_i_li, vsip_vcopy_li_i, vsip_vcopy_i_uc,
            vsip_vcopy_uc_i</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>Prototype Examples:</para>

            <para>Convert unsigned char to signed int:</para>

            <programlisting>void vsip_vcopy_uc_i(const vsip_vview_uc *x, const vsip_vview_i *y); </programlisting>

            <para>Convert complex user-specified unsigned 12 bit integers to
            complex single precision floating point:</para>

            <programlisting>void vsip_cvcopy_i12_f(const vsip_cvview_i12 *x, const vsip_cvview_f *y); </programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="copyto_user">
      <title>vsip_<replaceable>ds</replaceable>copyto_user_<replaceable>p</replaceable></title>

      <para>Copy data referenced by a VSIPL view to user allocated
      memory.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>The functionality is demonstrated using pseudo C code and
            well-defined VSIPL functionality. The method described indicates
            functionality and not the actual method used by an
            implementation.</para>

            <para>VSIPL considers user data arrays to always have unit stride.
            Copy to user memory implies a major direction for matrices. The
            major argument in the prototypes indicates the major and minor
            stride in the user memory, and the direction of copy from the
            view. User memory has a unit stride in the major direction, and
            (for matrices) a stride the length of the major dimension in the
            minor direction.</para>

            <para>In the notation below the view object we copy from is a, and
            the memory we copy into is R and possibly I. The memory pointer I
            is used if the output data are split complex.</para>

            <para>The value N is the vector length (vsip_dvgetlength_p(a)) for
            vectors, and for matrices N is the row length
            (vsip_dmgetrowlength_p(a)). The value M is the column length for
            matrices (vsip_dmgetcollength_p(a)). The vector index is k and the
            matrix index is (j,k). Using the above notation we have the
            following functionality for the copy to user memory.</para>

            <para>For real vectors:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  *(R+k) = vsip_vget_<replaceable>p</replaceable>(a,k);</programlisting>

            <para>For interleaved-complex vectors:</para>

            <programlisting>for(k=0; k&lt;N; k++)
{
  *(R+2*k) = vsip_real_<replaceable>p</replaceable>(vsip_cvget_<replaceable>p</replaceable>(a,k));
  *(R+1+2*k) = vsip_imag_<replaceable>p</replaceable>(vsip_cvget_<replaceable>p</replaceable>(a,k));
}</programlisting>

            <para>For split-complex vectors:</para>

            <programlisting>for(k=0; k&lt;N; k++)
{
  *(R+k) = vsip_real_<replaceable>p</replaceable>(vsip_cvget_<replaceable>p</replaceable>(a,k));
  *(I+k) = vsip_imag_<replaceable>p</replaceable>(vsip_cvget_<replaceable>p</replaceable>(a,k));
}</programlisting>

            <para>For real matrices copied as column major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
    *(R+j+k*M) = vsip_mget_<replaceable>p</replaceable>(a,j,k);</programlisting>

            <para>For real matrices copied as row major:</para>

            <programlisting>for(j=0; j&lt;M; j++)
  for(k=0; k&lt;N; k++)
    *(R+k+j*N) = vsip_mget_<replaceable>p</replaceable>(a,j,k);</programlisting>

            <para>For interleaved-complex matrices copied as column
            major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
  {
    *(R+2*(j+k*M)) = vsip_real_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
    *(R+1+2*(j+k*M)) = vsip_image_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
  }</programlisting>

            <para>For split-complex matrices copied as column major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
  {
    *(R+j+k*M) = vsip_real_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
    *(I+j+k*M) = vsip_image_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
  }</programlisting>

            <para>For interleaved-complex matrices copied as row major:</para>

            <programlisting>for(j=0; j&lt;M; j++)
  for(k=0; k&lt;N; k++)
  {
    *(R+2*(k+j*N)) = vsip_real_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
    *(R+1+2*(k+j*N)) = vsip_image_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
  }</programlisting>

            <para>For split-complex matrices copied as row major:</para>

            <programlisting>for(j=0; j&lt;M; j++)
  for(k=0; k&lt;N; k++)
  {
    *(R+k+j*N) = vsip_real_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
    *(I+k+j*N) = vsip_image_<replaceable>p</replaceable>(vsip_cmget_<replaceable>p</replaceable>(a,j,k));
  }</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcopyto_user_<replaceable>p</replaceable>(const vsip_vview_<replaceable>p</replaceable> *a, vsip_scalar_<replaceable>p</replaceable>* const R);
void vsip_mcopyto_user_<replaceable>p</replaceable>(const vsip_mview_<replaceable>p</replaceable> *a, vsip_major major, 
                         vsip_scalar_<replaceable>p</replaceable>* const R);
void vsip_cvcopyto_user_<replaceable>p</replaceable>(const vsip_cvview_<replaceable>p</replaceable> *a, 
                          vsip_scalar_<replaceable>p</replaceable>* const R, vsip_scalar_<replaceable>p</replaceable>* const I);
void vsip_cmcopyto_user_<replaceable>p</replaceable>(const vsip_cmview_<replaceable>p</replaceable> *a, vsip_major major, 
                          vsip_scalar_<replaceable>p</replaceable>* const R, vsip_scalar_<replaceable>p</replaceable>* const I);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>major</term>

                <listitem>
                  <para>The direction of copy, either by rows or by columns,
                  for matrix copies.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>R</term>

                <listitem>
                  <para>Pointer to beginning of output memory. For real views,
                  or complex views where I is not a null pointer then R should
                  point to allocated memory of size
                  [ELEMENTS*sizeof(vsip_scalar_p)]. For complex if I is NULL
                  then R should point to user memory of size
                  [2*ELEMENTS*sizeof(vsip_scalar_p)] and the output of the
                  copy will be interleaved complex.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>I</term>

                <listitem>
                  <para>Pointer to output of imaginary part of complex data or
                  NULL. If I is not a null pointer then it should point to
                  allocated memory of size[ELEMENTS*sizeof(vsip_scalar_p)] and
                  the output of the copy will be split complex.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>It is the responsibility of the user to ensure that
            sufficient memory is available to receive the data copied from the
            input view.</para>

            <para>The major and minor stride of the view object is not
            relevant to the functionality. For this function the major
            argument indicates the direction of copy from matrices and the
            major and minor stride direction of user memory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_dscopyfrom_user_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="copyfrom_user">
      <title>vsip_<replaceable>ds</replaceable>copyfrom_user_<replaceable>p</replaceable></title>

      <para>Copy data from user allocated memory to a VSIPL view.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>The functionality is demonstrated using pseudo C code and
            well-defined VSIPL functionality. The method described indicates
            functionality and not the actual method used by an
            implementation.</para>

            <para>VSIPL considers user data arrays to always have unit stride.
            Copy from user memory implies a major direction for matrices. The
            major argument indicates the major and minor stride in the user
            memory, and the direction of copy into the view. User memory has a
            unit stride in the major direction, and (for matrices) a stride
            the length of the major dimension in the minor direction.</para>

            <para>In the notation below the view object we copy to is a, and
            the memory pointer we copy from is R and possibly I. The memory
            pointer I is used if the input data are split complex.</para>

            <para>The value N is the vector length (vsip_dvgetlength_p(a)) for
            vectors, and for matrices N is the row length
            (vsip_dmgetrowlength_p(a)). The value M is the column length for
            matrices (vsip_dmgetcollength_p(a)). The vector index is k and the
            matrix index is (j,k).</para>

            <para>Using the above notation we have the following functionality
            for the copy to a VSIPL view</para>

            <para>For real vectors:</para>

            <programlisting>for(k=0; k&lt;N; k++)
{
  vsip_scalar_<replaceable>p</replaceable> re = *(R+k);
  vsip_vput_<replaceable>p</replaceable>(a, k, re );
}</programlisting>

            <para>For interleaved-complex vectors:</para>

            <programlisting>for(k=0; k&lt;N; k++)
{
  vsip_scalar_<replaceable>p</replaceable> re = *(R+2*k), im = *(R+2*k+1);
  vsip_cvput_<replaceable>p</replaceable>(a,k,vsip_cmplx_<replaceable>p</replaceable>(re,im));
}</programlisting>

            <para>For split-complex vectors:</para>

            <programlisting>for(k=0; k&lt;N; k++)
{
  vsip_scalar_<replaceable>p</replaceable> re = *(R+k), im = *(I+K);
  vsip_cvput_<replaceable>p</replaceable>(a,k,vsip_cmplx_<replaceable>p</replaceable>(re,im));
}</programlisting>

            <para>For real matrices copied as column major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
  {
    vsip_scalar_<replaceable>p</replaceable> re = *(R+j+k*M);
    vsip_mput_<replaceable>p</replaceable>(a,j,k,re);
  }</programlisting>

            <para>For real matrices copied as row major:</para>

            <programlisting>for(j=0; j&lt;M; j++)
  for(k=0; k&lt;N; k++)
  {
    vsip_scalar_<replaceable>p</replaceable> re = *(R+k+j*N);
    vsip_mput_<replaceable>p</replaceable>(a,j,k,re);
  }</programlisting>

            <para>For interleaved-complex matrices copied as column
            major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
  {
    vsip_scalar_<replaceable>p</replaceable> re = *(R+2*(j+k*M)),
    im = *(R+1+2*(j+k*M));
    vsip_cmput_<replaceable>p</replaceable>(a,j,k,vsip_cmplx_<replaceable>p</replaceable>(re,im));
  }</programlisting>

            <para>For split-complex matrices copied as column major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
  {
    vsip_scalar_<replaceable>p</replaceable> re = *(R+j+k*M), im = *(I+j+k*M);
    vsip_cmput_<replaceable>p</replaceable>(a,j,k,vsip_cmplx_<replaceable>p</replaceable>(re,im));
  }</programlisting>

            <para>For interleaved-complex matrices copied as row major:</para>

            <programlisting>for(j=0; j&lt;M; j++)
  for(k=0; k&lt;N; k++)
  {
    vsip_scalar_<replaceable>p</replaceable> re = *(R+2*(k+j*N)),
    im = *(R+1+2*(k+j*N));
    vsip_cmput_<replaceable>p</replaceable>(a,j,k,vsip_cmplx_<replaceable>p</replaceable>(re,im));
  }</programlisting>

            <para>For split-complex matrices copied as row major:</para>

            <programlisting>for(k=0; k&lt;N; k++)
  for(j=0; j&lt;M; j++)
  {
    vsip_scalar_<replaceable>p</replaceable> re = *(R+k+j*N), im = *(I+k+j*N);
    vsip_cmput_<replaceable>p</replaceable>(a,j,k,vsip_cmplx_<replaceable>p</replaceable>(re,im));
  }</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcopyfrom_user_<replaceable>p</replaceable>(vsip_scalar_<replaceable>p</replaceable>* const R, const vsip_vview_<replaceable>p</replaceable> *a);
void vsip_mcopyfrom_user_<replaceable>p</replaceable>(vsip_scalar_<replaceable>p</replaceable>* const R, vsip_major major, 
                           const vsip_mview_<replaceable>p</replaceable> *a);
void vsip_cvcopyfrom_user_<replaceable>p</replaceable>(vsip_scalar_<replaceable>p</replaceable>* const R, vsip_scalar_<replaceable>p</replaceable>* const I, 
                            const vsip_cvview_<replaceable>p</replaceable> *a);
void vsip_cmcopyfrom_user_<replaceable>p</replaceable>(vsip_scalar_<replaceable>p</replaceable>* const R, vsip_scalar_<replaceable>p</replaceable>* const I, 
                            vsip_major major, const vsip_cmview_<replaceable>p</replaceable> *a);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <para>Note that ELEMENTS is the number of elements of data
            referenced by the view. For vectors this is the vector length and
            for matrices this is the row length times the column
            length.</para>

            <variablelist>
              <varlistentry>
                <term>R</term>

                <listitem>
                  <para>Pointer to input memory holding data. For real views,
                  or complex views where I is not a null pointer then R should
                  point to allocated memory of size
                  [ELEMENTS*sizeof(vsip_scalar_p)]. For complex if I is NULL,
                  then R should point to allocated memory of size
                  [2*ELEMENTS*sizeof(vsip_scalar_p)] and the input data area
                  assumed to be interleaved complex.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>I</term>

                <listitem>
                  <para>Pointer to input memory holding the imaginary part of
                  the complex data or NULL. If I is not a null pointer then it
                  should point to allocated memory of size
                  [ELEMENTS*sizeof(vsip_scalar_p)] and the input data are
                  assumed to be split complex.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>major</term>

                <listitem>
                  <para>The direction of copy, either by rows or by columns,
                  for matrix copies.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of output vector/matrix.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The major and minor stride of the view object is not
            relevant to the functionality. For this function the major
            argument indicates the direction of copy from matrices and the
            major and minor stride direction of user memory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_dscopyfrom_user_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="fill">
      <title>vsip_<replaceable>ds</replaceable>fill_<replaceable>p</replaceable></title>

      <para>Fill a vector/matrix with a constant value.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>α</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mi>α</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vfill_i(vsip_scalar_i alpha, const vsip_vview_i *r);
void vsip_vfill_f(vsip_scalar_f alpha, const vsip_vview_f *r);
void vsip_cvfill_f(vsip_cscalar_f alpha, const vsip_cvview_f *r);
void vsip_mfill_i(vsip_scalar_i alpha, const vsip_mview_i *r);
void vsip_mfill_f(vsip_scalar_f alpha, const vsip_mview_f *r);
void vsip_cmfill_f(vsip_cscalar_f alpha, const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Scalar fill value</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>There are numerous instances of
            <function>vsip_<replaceable>ds</replaceable>fill_<replaceable>p</replaceable></function>
            in other examples. See, the example included with
            <function>vsip_<replaceable>ds</replaceable>expoavg_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_vramp_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="ramp">
      <title>vsip_vramp_<replaceable>p</replaceable></title>

      <para>Computes a vector ramp by starting at an initial value and
      incrementing each successive element by the ramp step size.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>r</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>α</m:mi>

                            <m:mo>+</m:mo>

                            <m:mi>k</m:mi>

                            <m:mo>*</m:mo>

                            <m:mi>β</m:mi>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vramp_i(vsip_scalar_i alpha, vsip_scalar_i beta, const vsip_vview_i *r);
void vsip_vramp_f(vsip_scalar_f alpha vsip_scalar_f beta, const vsip_vview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>alpha</term>

                <listitem>
                  <para>Initial value of vector ramp</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>beta</term>

                <listitem>
                  <para>Ramp increment (decrement if negative)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>There are numerous examples of ramp in other examples. See
            for instance the example included with
            <function>vsip_shypot_p</function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>ds</replaceable>fill_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Manipulation Operations</title>

    <para>These functions operate by copying vectors/matrices, or parts of
    vectors/matrices, from one vector/matrix location to another. In addition,
    functions whose primary job is to convert to or from a complex data type
    from a real or polar data type are included here.</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>vsip_scmplx_p</entry>

            <entry>Vector/Matrix Complex</entry>
          </row>

          <row>
            <entry>vsip_dsgather_p</entry>

            <entry>Vector/Matrix Gather</entry>
          </row>

          <row>
            <entry>vsip_dtgather_p</entry>

            <entry>Tensor Gather</entry>
          </row>

          <row>
            <entry>vsip_simag_p</entry>

            <entry>Vector/Matrix Imaginary</entry>
          </row>

          <row>
            <entry>vsip_spolar_p</entry>

            <entry>Vector/Matrix Polar</entry>
          </row>

          <row>
            <entry>vsip_sreal_p</entry>

            <entry>Vector/Matrix Real</entry>
          </row>

          <row>
            <entry>vsip_srect_p</entry>

            <entry>Vector/Matrix Rectangular</entry>
          </row>

          <row>
            <entry>vsip_dsscatter_p</entry>

            <entry>Vector/Matrix Scatter</entry>
          </row>

          <row>
            <entry>vsip_dtscatter_p</entry>

            <entry>Tensor Scatter</entry>
          </row>

          <row>
            <entry>vsip_dsswap_p</entry>

            <entry>Vector/Matrix Swap</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="scmplx">
      <title>vsip_<replaceable>s</replaceable>cmplx_<replaceable>p</replaceable></title>

      <para>Form a complex vector/matrix from two real
      vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:mrow>
                              <m:mi>Re</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>r</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			<m:mspace width='.5em' />

                          <m:mrow>
                            <m:mrow>
                              <m:mi>Im</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>r</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:mrow>
                              <m:mi>Re</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>r</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>a</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />

                          <m:mrow>
                            <m:mrow>
                              <m:mi>Im</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>r</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>b</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0,1,..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vcmplx_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                   const vsip_cvview_f *r);
void vsip_mcmplx_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                   const vsip_cmview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input vector/matrix which contains the real
                  part</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input vector/matrix which contains the
                  imaginary part</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In-place operation for this function means the input vectors
            (one or both) are either a real view, or an imaginary view, of the
            output vector. No in-place operation is defined for an input
            vector which contains both real and imaginary components of the
            output vector, or which do not exactly overlap a real view or an
            imaginary view of the output vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of complex see example included with
            <function>vsip_cvjdot_<replaceable>p</replaceable></function>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>rect_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="gather">
      <title>vsip_<replaceable>ds</replaceable>gather_<replaceable>p</replaceable></title>

      <para>The gather operation selects elements of a source vector/matrix
      using indices supplied by an index vector. The selected elements are
      placed sequentially in an output vector so that the output vector and
      the index vector are indexed the same.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>y</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:msub>
                                <m:mi>index</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Where N is the index vector length.</para>

            <para>Note that an index vector for a vector contains scalar
            elements suitable for indexing a vector. An index vector for a
            matrix contains elements consisting of pairs of scalars (row index
            and column index) suitable for indexing a matrix. The output of a
            gather is always a vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vgather_i(const vsip_vview_i *x, const vsip_vview_vi *index, 
                    vsip_vview_i *y);
void vsip_mgather_i(const vsip_mview_i *x, const vsip_vview_mi *index, 
                    vsip_vview_i *y);
void vsip_vgather_mi(const vsip_vview_mi *x, const vsip_vview_vi *index, 
                     vsip_vview_mi *y);
void vsip_vgather_f(const vsip_vview_f *x, const vsip_vview_vi *index, 
                    vsip_vview_f *y);
void vsip_mgather_f(const vsip_mview_f *x, const vsip_vview_mi *index, 
                    vsip_vview_f *y);
void vsip_cvgather_f(const vsip_cvview_f *x, const vsip_vview_vi *index, 
                     vsip_cvview_f *y);
void vsip_cmgather_f(const vsip_cmview_f *x, const vsip_vview_mi *index, 
                     vsip_cvview_f *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input source vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>View of input vector/matrix index vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output destination vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The length of the destination vector must be (set to) the
            same size as the index vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The index and output vectors views must be the same
                length.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>Index values in the index vector must be valid indexes
                into the source vector.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The destination vector must be the same size as the index
            vector. If these are not predetermined they should be checked and
            set at runtime.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/gather.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>The function
            <function>vsip_<replaceable>s</replaceable>indexbool</function>
            may be used to produce index vectors from boolean results. The
            function
            <function>vsip_<replaceable>s</replaceable>scatter_<replaceable>p</replaceable></function>
            is an inverse function of gather.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="tgather">
      <title>vsip_<replaceable>d</replaceable>tgather_<replaceable>p</replaceable></title>

      <para>Gather tensor elements into a vector.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Selects values from tensor U to gather (place) into vector
            v, using indices from vector t, such that:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>v</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>u</m:mi>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_tgather_f(const vsip_tview_f *U, const vsip_vview_ti *t, 
                    const vsip_vview_f *v);
void vsip_ctgather_f(const vsip_ctview_f *U, const vsip_vview_ti *t, 
                     const vsip_cvview_f *v);
void vsip_tgather_i(const vsip_tview_i *U, const vsip_vview_ti *t, 
                    const vsip_vview_i *v);
void vsip_ctgather_i(const vsip_ctview_i *U, const vsip_vview_ti *t, 
                     const vsip_cvview_i *v);
void vsip_tgather_bl(const vsip_tview_bl *U, const vsip_vview_ti *t, 
                     const vsip_vview_bl *v);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>U</term>

                <listitem>
                  <para>Input – Tensor view of source</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t</term>

                <listitem>
                  <para>Input - View of index vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Output – Vector view of destination</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>The length of the destination vector must be (set to) the
            same size as the index vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The following cause a VSIPL runtime error in development
            mode; in production mode the results will be implementation
            dependent.</para>

            <orderedlist>
              <listitem>
                <para>The index input vector and the output vector must have
                identical lengths.</para>
              </listitem>

              <listitem>
                <para>Arguments passed to the function must be defined and
                must not be null.</para>
              </listitem>

              <listitem>
                <para>Index values in the index vector must be valid indexes
                into the source tensor.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="simag">
      <title>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></title>

      <para>Extract the imaginary part of a complex vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mi>Im</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mi>Im</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vimag_f(const vsip_cvview_f *a, const vsip_vview_f *r);
void vsip_mimag_f(const vsip_cmview_f *a, const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of complex input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of real output vector(matrix)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If done in-place the output is placed in a real or imaginary
            view of the input. No in-place functionality is defined which
            places the output in a view which encompasses both real and
            imaginary space in the input vector. The output vector for
            in-place must exactly overlap the data space of the real view or
            the imaginary view of the input, and must not be disjoint.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Frequently it would be preferable to use the support
            function
            <function>vsip_imagview_<replaceable>p</replaceable></function>
            instead of
            <function>vsip_imag_<replaceable>p</replaceable></function>. The
            difference is whether a copy of the imaginary portion of the
            vector is made, or just a view of the imaginary portion is
            returned.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/imag.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>imagview_<replaceable>f</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmplx_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>rect_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="spolar">
      <title>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></title>

      <para>Convert a complex vector/matrix from rectangular to polar form.
      The polar data consists of a real vector/matrix containing the radius
      and a corresponding real vector/matrix containing the argument (angle)
      of the complex input data.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />

                          <m:mrow>
                            <m:msub>
                              <m:mi>φ</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mi>arg</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mo>|</m:mo>

                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>|</m:mo>
                            </m:mrow>
                          </m:mrow>

                          <m:mtext>;</m:mtext>
			  <m:mspace width='.5em' />

                          <m:mrow>
                            <m:msub>
                              <m:mi>φ</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mi>arg</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vpolar_f(const vsip_cvview_f *a, 
                   const vsip_vview_f *r, const vsip_vview_f *phi);
void vsip_mpolar_f(const vsip_cmview_f *a, 
                   const vsip_mview_f *r, const vsip_mview_f *phi);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input rectangular form vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of output radius (magnitude) vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>phi</term>

                <listitem>
                  <para>View of output angle (argument), φ,
                  vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In-place operation for this function requires that the
            radius and argument output vectors be placed in a real or
            imaginary view of the input vector. No in-place functionality is
            defined where an output view contains both real and imaginary data
            space. The in-place real or imaginary view must exactly overlap
            the input data space and must not be disjoint.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>For in-place there is no requirement on which view which
            output vector is placed in. So the radius vector could go in
            either the real or imaginary view, and the argument vector would
            go in the view not used by the radius vector.</para>

            <para>In VSIPL, complex numbers are always in rectangular
            (Cartesian) format. The polar form is represented by two real
            vectors/matrices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/polar.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>cmplx_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>rect_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="sreal">
      <title>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></title>

      <para>Extract the real part of a complex vector/matrix.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mi>Re</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>i,j</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:mi>Re</m:mi>

                              <m:mo>⁡</m:mo>

                              <m:mfenced>
                                <m:msub>
                                  <m:mi>a</m:mi>

                                  <m:mi>i,j</m:mi>
                                </m:msub>
                              </m:mfenced>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for i = 0, 1, ..., M-1; for j = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vreal_f(const vsip_cvview_f *a, const vsip_vview_f *r);
void vsip_mreal_f(const vsip_cmview_f *a, const vsip_mview_f *r);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of complex input vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of real output vector(matrix)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If done in-place the output is placed in a real or imaginary
            view of the input. No in-place functionality is defined which
            places the output in a view which encompasses both real and
            imaginary space in the input vector. The output vector for
            in-place must exactly overlap the data space of the real view or
            the imaginary view of the input, and must not be disjoint.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Frequently it would be preferable to use the support
            function
            <function>vsip_<replaceable>s</replaceable>realview_<replaceable>p</replaceable></function>
            instead of
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function>.
            The difference is whether a copy of the imaginary portion of the
            vector is made, or just a view of the imaginary portion is
            returned.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para>For example of
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function>
            see example under
            <function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>realview_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>cmplx_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>rect_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="srect">
      <title>vsip_<replaceable>s</replaceable>rect_<replaceable>p</replaceable></title>

      <para>Convert a pair of real vectors/matrices from complex polar to
      complex rectangular form.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>y</m:mi>

                              <m:mi>k</m:mi>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>r</m:mi>

                                <m:mi>k</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:mrow>
                                <m:mo>(</m:mo>

                                <m:mrow>
                                  <m:mrow>
                                    <m:mi>cos</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:msub>
                                        <m:mi>φ</m:mi>

                                        <m:mi>k</m:mi>
                                      </m:msub>
                                    </m:mfenced>
                                  </m:mrow>

                                  <m:mo>+</m:mo>

                                  <m:mrow>
                                    <m:mi>j</m:mi>

                                    <m:mo>⁢</m:mo>

                                    <m:mrow>
                                      <m:mi>sin</m:mi>

                                      <m:mo>⁡</m:mo>

                                      <m:mfenced>
                                        <m:msub>
                                          <m:mi>φ</m:mi>

                                          <m:mi>k</m:mi>
                                        </m:msub>
                                      </m:mfenced>
                                    </m:mrow>
                                  </m:mrow>
                                </m:mrow>

                                <m:mo>)</m:mo>
                              </m:mrow>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for k = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>k,l</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:msub>
                              <m:mi>r</m:mi>

                              <m:mi>k,l</m:mi>
                            </m:msub>

                            <m:mo>⁢</m:mo>

                            <m:mrow>
                              <m:mo>(</m:mo>

                              <m:mrow>
                                <m:mrow>
                                  <m:mi>cos</m:mi>

                                  <m:mo>⁡</m:mo>

                                  <m:mfenced>
                                    <m:msub>
                                      <m:mi>φ</m:mi>

                                      <m:mi>k,l</m:mi>
                                    </m:msub>
                                  </m:mfenced>
                                </m:mrow>

                                <m:mo>+</m:mo>

                                <m:mrow>
                                  <m:mi>j</m:mi>

                                  <m:mo>⁢</m:mo>

                                  <m:mrow>
                                    <m:mi>sin</m:mi>

                                    <m:mo>⁡</m:mo>

                                    <m:mfenced>
                                      <m:msub>
                                        <m:mi>φ</m:mi>

                                        <m:mi>k,l</m:mi>
                                      </m:msub>
                                    </m:mfenced>
                                  </m:mrow>
                                </m:mrow>
                              </m:mrow>

                              <m:mo>)</m:mo>
                            </m:mrow>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for k = 0, 1, ..., M-1; for l = 0, 1, ...,
                        N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vrect_f(const vsip_vview_f *r, const vsip_vview_f *phi, 
                  const vsip_cvview_f *y);
void vsip_mrect_f(const vsip_mview_f *r, const vsip_mview_f *phi, 
                  const vsip_cmview_f *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>r</term>

                <listitem>
                  <para>View of input radius (magnitude) vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>phi</term>

                <listitem>
                  <para>View of input radius (magnitude) vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output rectangular form vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>In-place operation for this function requires that the
            radius and argument input vectors be in a real or imaginary view
            of the output vector. No in-place functionality is defined where
            an input view contains both real and imaginary data space of the
            output view. For in-place the data in the views must exactly
            overlap and not be disjoint.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>For in-place there is no requirement on which view which
            output vector is placed in. So the radius vector could go in
            either the real or imaginary view, and the argument vector would
            go in the view not used by the radius vector.</para>

            <para>In VSIPL, complex numbers are always in rectangular
            (Cartesian) format. The polar form is represented by two real
            vectors/matrices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/rect.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>cmplx_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>imag_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>polar_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>real_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="scatter">
      <title>vsip_<replaceable>ds</replaceable>scatter_<replaceable>p</replaceable></title>

      <para>The scatter operation sequentially utilizes elements of a source
      vector and an index vector. The element of the vector index (matrix
      index) is used to select a storage location in the output vector/matrix
      to store the element from the source vector.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>y</m:mi>

                              <m:msub>
                                <m:mi>index</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>x</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>Where N is the index vector length.</para>

            <para>Note that an index vector for a vector contains scalar
            elements suitable for indexing a vector. An index vector for a
            matrix contains elements consisting of pairs of scalars (row index
            and column index) suitable for indexing a matrix. The input of a
            scatter is always a vector.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vscatter_i(const vsip_vview_i *x, const vsip_vview_i *y, 
                     const vsip_vview_vi *index);
void vsip_mscatter_i(const vsip_vview_i *x, const vsip_mview_i *y, 
                     const vsip_vview_mi *index);
void vsip_vscatter_mi(const vsip_vview_mi *x, const vsip_vview_mi *y, 
                      const vsip_vview_vi *index);
void vsip_vscatter_f(const vsip_vview_f *x, const vsip_vview_f *y, 
                     const vsip_vview_vi *index);
void vsip_mscatter_f(const vsip_vview_f *x, const vsip_mview_f *y, 
                     const vsip_vview_mi *index);
void vsip_cvscatter_f(const vsip_vview_f *x, const vsip_vview_f *y, 
                      const vsip_vview_vi *index);
void vsip_cmscatter_f(const vsip_cvview_f *x, const vsip_cmview_f *y, 
                      const vsip_vview_mi *index);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>View of input source vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>View of output destination vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>View of input vector/matrix index vector</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If the index vector contains duplicate entries, the value
            stored in the destination will be from the source vector, but
            which value is not defined.</para>

            <para>There is no in-place functionality for this function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>The index and input vectors views must be the same
                length.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>Index values in the index vector must be valid indexes
                into the output.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>The attributes of the destination vector/matrix are not
            modified. Values in the destination not indexed are not
            modified.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/scatter.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para>The function
            <function>vsip_<replaceable>s</replaceable>indexbool</function>
            may be used to produce index vectors from boolean results.</para>

            <para>The function
            <function>vsip_<replaceable>ds</replaceable>gather_<replaceable>p</replaceable></function>
            is an inverse function of scatter only if the index vector
            contains no duplicate entries.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="tscatter">
      <title>vsip_<replaceable>d</replaceable>tscatter_<replaceable>p</replaceable></title>

      <para>Scatter the elements of a vector into a tensor.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Selects locations in tensor V to scatter (place) the values
            from vector u using tensor indices from vector t such that:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mrow>
                            <m:msub>
                              <m:mi>v</m:mi>

                              <m:msub>
                                <m:mi>t</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:msub>

                            <m:mo>←</m:mo>

                            <m:msub>
                              <m:mi>u</m:mi>

                              <m:mi>j</m:mi>
                            </m:msub>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_tscatter_f(const vsip_vview_f *u, const vsip_vview_ti *t, 
                     const vsip_tview_f *V);
void vsip_ctscatter_f(const vsip_cvview_f *u, const vsip_cvview_ti *t, 
                      const vsip_ctview_f *V);
void vsip_tscatter_i(const vsip_vview_i *u, const vsip_vview_ti *t, 
                     const vsip_tview_i *V);
void vsip_ctscatter_i(const vsip_cvview_i *u, const vsip_cvview_ti *t,
                      const vsip_ctview_i *V);
void vsip_tscatter_bl(const vsip_vview_bl *u, const vsip_vview_ti *t,
                      const vsip_tview_bl *V);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>u</term>

                <listitem>
                  <para>Input – Tensor view of source</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>t</term>

                <listitem>
                  <para>Input - View of index vector</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>V</term>

                <listitem>
                  <para>Output – Tensor view of destination</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>If the index vector contains duplicate entries the value
            stored in the destination will be from the source vector but which
            value is not defined.</para>

            <para>There is no in-place functionality for this function.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The following cause a VSIPL runtime error in development
            mode; in production mode the results will be implementation
            dependent.</para>

            <orderedlist>
              <listitem>
                <para>The index input vector and the output vector must have
                identical lengths.</para>
              </listitem>

              <listitem>
                <para>Arguments passed to the function must be defined and
                must not be null.</para>
              </listitem>

              <listitem>
                <para>Index values in the index vector must be valid indexes
                into the source tensor.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="swap">
      <title>vsip_<replaceable>ds</replaceable>swap_<replaceable>p</replaceable></title>

      <para>Swap elements between two vectors/matrices.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left" columnlines="solid">
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:mi>τ</m:mi>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mtext>for j = 0, 1, ..., N-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:mi>τ</m:mi>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="1em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>τ</m:mi>
                        </m:mrow>
                      </m:mtd>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>b</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd/>

                      <m:mtd>
                        <m:mspace depth="1ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:msub>
                            <m:mi>a</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mi>τ</m:mi>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vswap_i(const vsip_vview_i *a, const vsip_vview_i *b);
void vsip_vswap_f(const vsip_vview_f *a, const vsip_vview_f *b);
void vsip_cvswap_f(const vsip_cvview_f *a, const vsip_cvview_f *b);
void vsip_mswap_i(const vsip_mview_i *a, const vsip_mview_i *b);
void vsip_mswap_f(const vsip_mview_f *a, const vsip_mview_f *b);
void vsip_cmswap_f(const vsip_cmview_f *a, const vsip_cmview_f *b);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>a</term>

                <listitem>
                  <para>View of input/output vector/matrix</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>b</term>

                <listitem>
                  <para>View of input/output vector/matrix</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>This function may not be done in-place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <programlisting><xi:include href="examples/swap.c" parse="text"/></programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>User-Specified By Element Functions</title>

    <para>This sub clause describes a set of functions that allows the user to
    specify a function to be applied by element to a set of
    vector/matrix/tensors view objects, and simple by element “get” and
    “put.”</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry><function>vsip_<replaceable>s</replaceable>binary_<replaceable>p</replaceable></function></entry>

            <entry>User-Specified Binary Function</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>bool_<replaceable>p</replaceable></function></entry>

            <entry>User-Specified Boolean Binary Function</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>mary_<replaceable>p</replaceable></function></entry>

            <entry>User-Specified M-ary Vector Function</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>nary_<replaceable>p</replaceable></function></entry>

            <entry>User-Specified Stream Function</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>serialmary_<replaceable>p</replaceable></function></entry>

            <entry>User-Specified Serial M-ary Function</entry>
          </row>

          <row>
            <entry><function>vsip_<replaceable>s</replaceable>unary_<replaceable>p</replaceable></function></entry>

            <entry>User-Specified Unary Function</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <section xml:id="binary">
      <title>vsip_<replaceable>s</replaceable>binary_<replaceable>p</replaceable></title>

      <para>Computes a user-specified binary scalar function, by element, of
      two vectors/matrices/tensors.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the binary vector/matrix/tensor function</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>z</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>z</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>z</m:mi>

                            <m:mi>h,i,j</m:mi>
                          </m:msub>

                          <m:mo>=</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:msub>
                                <m:mi>x</m:mi>

                                <m:mi>h,i,j</m:mi>
                              </m:msub>

                              <m:msub>
                                <m:mi>y</m:mi>

                                <m:mi>h,i,j</m:mi>
                              </m:msub>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>element by element. The exact order of computation is
            undefined. The user specifies a binary function of two scalars
            that returns a scalar result.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vbinary_f(vsip_scalar_f (*f)(vsip_scalar_f, vsip_scalar_f), 
                    const vsip_vview_f *x, const vsip_vview_f *y, 
                    const vsip_vview_f *z);
void vsip_vbinary_i(vsip_scalar_i (*f)(vsip_scalar_i, vsip_scalar_i),
                    const vsip_vview_i *x, const vsip_vview_i *y, 
                    const vsip_vview_i *z);
void vsip_vbinary_vi(vsip_scalar_vi (*f)(vsip_scalar_vi, vsip_scalar_vi),
                     const vsip_vview_vi *x, const vsip_vview_vi *y, 
                     const vsip_vview_vi *z);
void vsip_vbinary_mi(vsip_scalar_mi (*f)(vsip_scalar_mi, vsip_scalar_mi),
                     const vsip_vview_mi *x, const vsip_vview_mi *y, 
                     const vsip_vview_mi *z);
void vsip_vbinary_ti(vsip_scalar_ti (*f)(vsip_scalar_ti, vsip_scalar_ti),
                     const vsip_vview_ti *x, const vsip_vview_ti *y, 
                     const vsip_vview_ti *z);
void vsip_mbinary_f(vsip_scalar_f (*f)(vsip_scalar_f, vsip_scalar_f),
                    const vsip_mview_f *x, const vsip_mview_f *y, 
                    const vsip_mview_f *z);
void vsip_mbinary_i(vsip_scalar_i (*f)(vsip_scalar_i, vsip_scalar_i),
                    const vsip_mview_i *x, const vsip_mview_i *y, 
                    const vsip_mview_i *z);
void vsip_mbinary_bl(vsip_scalar_bl (*f)(vsip_scalar_bl, vsip_scalar_bl),
                     const vsip_mview_bl *x, const vsip_mview_bl *y, 
                     const vsip_mview_bl *z);
void vsip_tbinary_f(vsip_scalar_f (*f)(vsip_scalar_f, vsip_scalar_f),
                    const vsip_tview_f *x, const vsip_tview_f *y, 
                    const vsip_tview_f *z);
void vsip_tbinary_i(vsip_scalar_i (*f)(vsip_scalar_i, vsip_scalar_i),
                    const vsip_tview_i *x, const vsip_tview_i *y, 
                    const vsip_tview_i *z);
void vsip_tbinary_bl(vsip_scalar_bl (*f)(vsip_scalar_bl, vsip_scalar_bl),
                     const vsip_tview_bl *x, const vsip_tview_bl *y, 
                     const vsip_tview_bl *z);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>f</term>

                <listitem>
                  <para>Pointer to user-specified binary function of two
                  scalars</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Vector/matrix/tensor view object of source1
                  operand</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Vector/matrix/tensor view object of source2
                  operand</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>z</term>

                <listitem>
                  <para>Vector/matrix/tensor view object of result</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para>This function may not be done in-place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>

              <listitem>
                <para>The pointer to the user-specified function must be valid
                – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>There are no complex versions of this function. This is a
            consequence of supporting the implementation of complex blocks
            with split storage, which is not compatible with a
            <function>vsip_cscalar_<replaceable>p</replaceable></function>
            data type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>bool_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>mary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>nary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>serialmary_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>unary_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="mary">
      <title>vsip_<replaceable>s</replaceable>mary_<replaceable>p</replaceable></title>

      <para>Computes a user-specified specified m-ary scalar function, by
      element, of m vectors/matrices/tensors. The order of evaluation is not
      specified.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This function applies the scalar function</para>

            <variablelist>
              <varlistentry>
                <term>Vector</term>

                <listitem>
                  <synopsis>void (*f)(vsip_scalar_p *p[], vsip_length m, vsip_scalar_vi index);</synopsis>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Matrix</term>

                <listitem>
                  <synopsis>void (*f)(vsip_scalar_p *p[], vsip_length m, vsip_scalar_mi index);</synopsis>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Tensor</term>

                <listitem>
                  <synopsis>void (*f)(vsip_scalar_p *p[], vsip_length m, vsip_scalar_ti index);</synopsis>
                </listitem>
              </varlistentry>
            </variablelist>

            <para>with</para>

            <variablelist>
              <varlistentry>
                <term>p</term>

                <listitem>
                  <para>Pointer to array of m+1 pointers to scalars</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>m</term>

                <listitem>
                  <para>array length</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>vector/matrix/tensor index.</para>
                </listitem>
              </varlistentry>
            </variablelist>

            <para>by element to the elements of an m+1 array of
            vector/matrix/tensor view objects. Typical application is an m-ary
            scalar function that produces a single scalar output.</para>

            <para>Since the user function takes an argument of a pointer to an
            array of m+1 pointers to scalars, it is free to treat any of the
            scalars as input, outputs, or inputs-outputs.</para>

            <para>The exact order of computation is undefined.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vmary_f(void (*f)(vsip_scalar_f *[], vsip_length m, vsip_scalar_vi i),
                  const vsip_vview_f *v[], vsip_length m);
void vsip_vmary_i(void (*f)(vsip_scalar_i *[], vsip_length m, vsip_scalar_vi i),
                  const vsip_vview_i *v[], vsip_length m);
void vsip_vmary_bl(void (*f)(vsip_scalar_bl *[], vsip_length m, vsip_scalar_vi i),
                   const vsip_vview_bl *v[], vsip_length m);
void vsip_vmary_vi(void (*f)(vsip_scalar_vi *[], vsip_length m, vsip_scalar_vi i),
                   const vsip_vview_vi *v[], vsip_length m);
void vsip_vmary_mi(void (*f)(vsip_scalar_mi *[], vsip_length m, vsip_scalar_vi i),
                   const vsip_vview_mi *v[], vsip_length m);
void vsip_vmary_ti(void (*f)(vsip_scalar_ti *[], vsip_length m, vsip_scalar_vi i),
                   const vsip_vview_ti *v[], vsip_length m);
void vsip_mmary_f(void (*f)(vsip_scalar_f *[], vsip_length m, vsip_scalar_mi i),
                  const vsip_mview_f *v[], vsip_length m);
void vsip_mmary_i(void (*f)(vsip_scalar_i *[], vsip_length m, vsip_scalar_mi i),
                  const vsip_mview_i *v[], vsip_length m);
void vsip_mmary_bl(void (*f)(vsip_scalar_bl *[], vsip_length m, vsip_scalar_mi i),
                   const vsip_mview_bl *v[], vsip_length m);
void vsip_tmary_f(void (*f)(vsip_scalar_f *[], vsip_length m, vsip_scalar_ti i),
                  const vsip_tview_f *v[], vsip_length m);
void vsip_tmary_i(void (*f)(vsip_scalar_i *[], vsip_length m, vsip_scalar_ti i),
                  const vsip_tview_i *v[], vsip_length m);
void vsip_tmary_bl(void (*f)(vsip_scalar_bl *[], vsip_length m, vsip_scalar_ti i),
                   const vsip_tview_bl *v[], vsip_length m);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>f</term>

                <listitem>
                  <para>Pointer to user-specified function of an array of
                  pointers to vector/matrix/tensor view objects, the length of
                  the array, and the current element i; returning void.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Array of m+1 pointers to vector/matrix/tensor view
                  objects</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>m</term>

                <listitem>
                  <para>One less than the number of elements in the array v.
                  (m-ary order of the user-specified function.)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>

              <listitem>
                <para>The pointer to the user-specified function must be valid
                – non-null.</para>
              </listitem>

              <listitem>
                <para>m must be positive</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>There are no complex versions of this function. This is a
            consequence of supporting the implementation of complex blocks
            with split storage, which is not compatible with a vsip_cscalar_p
            data type.</para>

            <para>By convention, the vector of pointers to view objects is
            ordered: inputs, input/outputs, and last outputs.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <orderedlist>
              <listitem>
                <para>To implement the common vector function VMMA:
                <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:msub>
                          <m:mi>y</m:mi>

                          <m:mi>j</m:mi>
                        </m:msub>

                        <m:mo>=</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>

                          <m:mo>+</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>c</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>d</m:mi>

                                <m:mi>j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mrow>
                    </m:math>
                  </inlineequation></para>

                <para>[Static is just to limit the scope of the function
                name.]</para>

                <programlisting>static void mma_f(vsip_scalar_f *q [], unsigned int m, vsip_index i)
{
  *q[4] = (*q[0] * *q[1]) + (*q[2] * *q[3]);
}

void user_vmma_f(const vsip_vview_f *a, const vsip_vview_f *b, 
                 const vsip_vview_f *c, const vsip_vview_f *d, 
                 const vsip_vview_f *y)
{
  const vsip_vview_f *qnary[5];
  qnary[0] = a; qnary[1] = b; qnary[2] = c; qnary[3] = d; qnary[4] = y;
  vsip_vmary_f(mma_sp, qnary, 4);
}</programlisting>
              </listitem>

              <listitem>
                <para>To sum four vectors together:</para>

                <programlisting>static void vmsum_d(vsip_scalar_d *v [], unsigned int M, vsip_index i)
{
  int i;
  *v[M-1] = *v[0];
  for(i=1; i&lt;M-1; i++)*v[M-1] += *v[i];
}
void user_vsum4_d(const vsip_vview_d *a, const vsip_vview_d *b, 
                  const vsip_vview_d *c, const vsip_vview_d *d, 
                  const vsip_vview_d *y)
{
  const vsip_vview_d *qnary[5];
  qnary[0] = a; qnary[1] = b; qnary[2] = c; qnary[3] = d; qnary[4] = y;
  vsip_vmary_d(vmsum_d, qnary, 4);
}</programlisting>
              </listitem>

              <listitem>
                <para>To implement the common matrix function MMMA:
                <inlineequation>
                    <m:math display="inline">
                      <m:mrow>
                        <m:msub>
                          <m:mi>y</m:mi>

                          <m:mi>i,j</m:mi>
                        </m:msub>

                        <m:mo>=</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>a</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>b</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>

                          <m:mo>+</m:mo>

                          <m:mrow>
                            <m:mo>(</m:mo>

                            <m:mrow>
                              <m:msub>
                                <m:mi>c</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>

                              <m:mo>⁢</m:mo>

                              <m:msub>
                                <m:mi>d</m:mi>

                                <m:mi>i,j</m:mi>
                              </m:msub>
                            </m:mrow>

                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:mrow>
                      </m:mrow>
                    </m:math>
                  </inlineequation></para>

                <programlisting>static void mma_f(vsip_scalar_f *qary[], vsip_length m, vsip_scalar_mi index)
{
  *qary[4] = (*qary[0] * *qary[1]) + (*qary[2] * *qary[3]);
}
void user_mmma_f(const vsip_mview_f *a, const vsip_mview_f *b, 
                 const vsip_mview_f *c, const vsip_mview_f *d, 
                 const vsip_mview_f *y)
{
  const vsip_mview_f *X[5];
  X[0] = a; X[1] = b; X[2] = c; X[3] = d; X[4] = y;
  vsip_mrandom_f(mma_sp, X, 4);
}</programlisting>

                <para>[Of course you should use a more efficient method for
                such lightweight functions.]</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>bool_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>binary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>nary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>serialmary_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>unary_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="nary">
      <title>vsip_<replaceable>s</replaceable>nary_<replaceable>p</replaceable></title>

      <para>Computes a user-specified scalar function that takes the
      vector/matrix/tensor index of the element and returns a scalar, by
      element, of a vector/matrix/tensor.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the “null-ary” (no element value arguments)
            vector/matrix/tensor function</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>i</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>i</m:mi>

                              <m:mi>j</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>h,i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>h</m:mi>

                              <m:mi>i</m:mi>

                              <m:mi>j</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>element by element. The exact order of computation is
            undefined The user specifies a function of one/two/three indices
            that returns a scalar result.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vnary_f(vsip_scalar_f (*f)( vsip_index), const vsip_vview_f *y);
void vsip_vnary_i(vsip_scalar_i (*f)( vsip_index), const vsip_vview_i *y);
void vsip_vnary_bl(vsip_scalar_bl (*f)(vsip_index), const vsip_vview_bl *y);
void vsip_vnary_vi(vsip_scalar_vi (*f)(vsip_index), const vsip_vview_vi *y);
void vsip_vnary_mi(vsip_scalar_mi (*f)( vsip_index), const vsip_vview_mi *y);
void vsip_vnary_ti(vsip_scalar_ti (*f)( vsip_index), const vsip_vview_ti *y);
void vsip_mnary_f(vsip_scalar_f (*f)(vsip_index, vsip_index), 
                  const vsip_mview_f *y);
void vsip_mnary_i(vsip_scalar_i (*f)(vsip_index, vsip_index), 
                  const vsip_mview_i *y);
void vsip_mnary_bl(vsip_scalar_bl (*f)(vsip_index, vsip_index), 
                   const vsip_mview_bl *y);
void vsip_tnary_f(vsip_scalar_f (*f)(vsip_index, vsip_index, vsip_index), 
                  const vsip_tview_f *y);
void vsip_tnary_i(vsip_scalar_i (*f)(vsip_index, vsip_index, vsip_index), 
                  const vsip_tview_i *y);
void vsip_tnary_bl(vsip_scalar_bl (*f)(vsip_index,vsip_index,vsip_index),
                   const vsip_tview_bl *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>f</term>

                <listitem>
                  <para>User specified null-ary function of one/two/three
                  indices</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>y</term>

                <listitem>
                  <para>Vector/matrix/tensor view object of result</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the user-specified function must be valid
                – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>There are no complex versions of this function. This is a
            consequence of supporting the implementation of complex blocks
            with split storage, which is not compatible with a
            <type>vsip_cscalar_<replaceable>p</replaceable></type> data
            type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>bool_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>binary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>mary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>serialmary_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>unary_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="serialmary">
      <title>vsip_<replaceable>s</replaceable>serialmary_<replaceable>p</replaceable></title>

      <para>Computes a user-specified specified m-ary scalar function, by
      element, of m vectors/matrices/tensors. The order of evaluation is
      serial.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>This function applies the scalar function</para>

            <variablelist>
              <varlistentry>
                <term>Vector</term>

                <listitem>
                  <synopsis>void (*f)(vsip_scalar_p *p[], vsip_length m, vsip_scalar_vi index);</synopsis>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Matrix</term>

                <listitem>
                  <synopsis>void (*f)(vsip_scalar_p *p[], vsip_length m, vsip_scalar_mi index);</synopsis>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Tensor</term>

                <listitem>
                  <synopsis>void (*f)(vsip_scalar_p *p[], vsip_length m, vsip_scalar_ti index);</synopsis>
                </listitem>
              </varlistentry>
            </variablelist>

            <para>with</para>

            <variablelist>
              <varlistentry>
                <term>p</term>

                <listitem>
                  <para>Pointer to array of m+1 pointers to scalars</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>m</term>

                <listitem>
                  <para>array length</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>index</term>

                <listitem>
                  <para>vector/matrix/tensor index.</para>
                </listitem>
              </varlistentry>
            </variablelist>

            <para>by element to the elements of an m+1 array of
            vector/matrix/tensor view objects. Typical application is an m-ary
            scalar function that produces a single scalar output.</para>

            <para>Since the user function takes an argument of a pointer to an
            array of m+1 pointers to scalars, it is free to treat any of the
            scalars as input, outputs, or inputs-outputs.</para>

            <para>The semantics of the order of evaluation is serial from
            smallest to largest index. For matrices and tensors, this means
            that the index with the smallest intra-indices stride varies the
            fastest and the index with the largest intra-indices stride varies
            the slowest. For example, a matrix where the stride between
            successive elements of a row is one element is evaluated in the
            order:</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable columnalign="left">
                    <m:mtr>
                      <m:mtd>
                        <m:mtext>for i = 0 to M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="1ex" width="1em"/>

                        <m:mtext>for i = 0 to M-1</m:mtext>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mspace depth="0ex" height="1ex" width="2em"/>

                        <m:mrow>
                          <m:mi>...</m:mi>

                          <m:mo>←</m:mo>

                          <m:mi>f</m:mi>

                          <m:mo>⁡</m:mo>

                          <m:mfenced>
                            <m:mi>v</m:mi>

                            <m:mi>m</m:mi>

                            <m:mrow>
                              <m:mfenced>
                                <m:mi>i</m:mi>

                                <m:mi>j</m:mi>
                              </m:mfenced>
                            </m:mrow>
                          </m:mfenced>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void 
vsip_vserialmary_f(void (*f)(vsip_scalar_f *[], vsip_length m, vsip_scalar_vi i), 
                   const vsip_vview_f *v[], vsip_length m);
void 
vsip_vserialmary_i(void (*f)(vsip_scalar_i *[], vsip_length m, vsip_scalar_vi i),
                   const vsip_vview_i *v[], vsip_length m);
void
vsip_vserialmary_bl(void (*f)(vsip_scalar_bl *[], vsip_length m, vsip_scalar_vi i),
                    const vsip_vview_bl *v[], vsip_length m);
void 
vsip_vserialmary_vi(void (*f)(vsip_scalar_vi *[], vsip_length m, vsip_scalar_vi i),
                    const vsip_vview_vi *v[], vsip_length m);
void 
vsip_vserialmary_mi(void (*f)(vsip_scalar_mi *[], vsip_length m, vsip_scalar_vi i),
                    const vsip_vview_mi *v[], vsip_length m);
void 
vsip_vserialmary_ti(void (*f)(vsip_scalar_ti *[], vsip_length m, vsip_scalar_vi i),
                    const vsip_vview_ti *v[], vsip_length m);
void 
vsip_mserialmary_f(void (*f)(vsip_scalar_f *[], vsip_length m, vsip_scalar_mi i),
                   const vsip_mview_f *v[], vsip_length m);
void
vsip_mserialmary_i(void (*f)(vsip_scalar_i *[], vsip_length m, vsip_scalar_mi i),
                   const vsip_mview_i *v[], vsip_length m);
void 
vsip_mserialmary_bl(void (*f)(vsip_scalar_bl *[], vsip_length m, vsip_scalar_mi i),
                    const vsip_mview_bl *v[], vsip_length m);
void 
vsip_tserialmary_f(void (*f)(vsip_scalar_f *[], vsip_length m, vsip_scalar_ti i),
                   const vsip_tview_f *v[], vsip_length m);
void 
vsip_tserialmary_i(void (*f)(vsip_scalar_i *[], vsip_length m, vsip_scalar_ti i),
                   const vsip_tview_i *v[], vsip_length m);
void 
vsip_tserialmary_bl(void (*f)(vsip_scalar_bl *[], vsip_length m, vsip_scalar_ti i),
                    const vsip_tview_bl *v[], vsip_length m);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>f</term>

                <listitem>
                  <para>User specified function of an array of pointers to
                  vector/matrix/tensor view objects, the length of the array,
                  and the current element i; returning void.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>v</term>

                <listitem>
                  <para>Array of m+1 pointers to vector/matrix/tensor view
                  objects</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>m</term>

                <listitem>
                  <para>One less than the number of elements in the array v.
                  (m-ary order of the user-specified function.)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input/output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The pointer to the user-specified function must be valid
                – non-null.</para>
              </listitem>

              <listitem>
                <para>The arity, m, of the function must be positive.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>Since the order of evaluation is specified, it is allowed
            for the input and output to overlap. There are no complex versions
            of this function. This is a consequence of supporting the
            implementation of complex blocks with split storage, which is not
            compatible with a
            <type>vsip_cscalar_<replaceable>p</replaceable></type> data
            type.</para>

            <para>By convention, the vector of pointers to view objects is
            ordered: inputs, input/outputs, and last outputs.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>bool_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>binary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>mary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>nary_<replaceable>p</replaceable></function>,
            and
            <function>vsip_<replaceable>s</replaceable>unary_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="unary">
      <title>vsip_<replaceable>s</replaceable>unary_<replaceable>p</replaceable></title>

      <para>Computes a user-specified unary scalar function, by element, of a
      vector/matrix/tensor.</para>

      <variablelist>
        <varlistentry>
          <term>Functionality</term>

          <listitem>
            <para>Computes the unary tensor function <inlineequation>
                <m:math display="inline">
                  <m:mrow>
                    <m:msub>
                      <m:mi>x</m:mi>

                      <m:mi>h,i,j</m:mi>
                    </m:msub>

                    <m:mo>=</m:mo>

                    <m:mrow>
                      <m:mi>f</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>h</m:mi>

                        <m:mi>i</m:mi>

                        <m:mi>j</m:mi>
                      </m:mfenced>
                    </m:mrow>
                  </m:mrow>
                </m:math>
              </inlineequation> element by element where the exact order of
            computation is undefined. The user-specified function is a
            function of a scalar tensor index and returns a result
            scalar.</para>

            <para>This function computes the unary vector/matrix/tensor
            function</para>

            <para><inlineequation>
                <m:math display="inline">
                  <m:mtable>
                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>i</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>i</m:mi>

                              <m:mi>j</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>

                    <m:mtr>
                      <m:mtd>
                        <m:mrow>
                          <m:msub>
                            <m:mi>y</m:mi>

                            <m:mi>h,i,j</m:mi>
                          </m:msub>

                          <m:mo>←</m:mo>

                          <m:mrow>
                            <m:mi>f</m:mi>

                            <m:mo>⁡</m:mo>

                            <m:mfenced>
                              <m:mi>h</m:mi>

                              <m:mi>i</m:mi>

                              <m:mi>j</m:mi>
                            </m:mfenced>
                          </m:mrow>
                        </m:mrow>
                      </m:mtd>
                    </m:mtr>
                  </m:mtable>
                </m:math>
              </inlineequation></para>

            <para>element by element. The exact order of computation is
            undefined. The user specifies a unary function of a scalar that
            returns a scalar result.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Prototypes</term>

          <listitem>
            <synopsis>void vsip_vunary_f(vsip_scalar_f (*f)(vsip_scalar_f), 
                   const vsip_vview_f *x, const vsip_vview_f *y);
void vsip_vunary_i(vsip_scalar_i (*f)(vsip_scalar_i), 
                   const vsip_vview_i *x, const vsip_vview_i *y);
void vsip_vunary_vi(vsip_scalar_vi (*f)(vsip_scalar_vi), 
                    const vsip_vview_vi *x, const vsip_vview_vi *y);
void vsip_vunary_mi(vsip_scalar_mi (*f)(vsip_scalar_mi), 
                    const vsip_vview_mi *x, const vsip_vview_mi *y);
void vsip_vunary_ti(vsip_scalar_ti (*f)(vsip_scalar_ti), 
                    const vsip_vview_ti *x, const vsip_vview_ti *y);
void vsip_munary_f(vsip_scalar_f (*f)(vsip_scalar_f), 
                   const vsip_mview_f *x, const vsip_mview_f *y);
void vsip_munary_i(vsip_scalar_i (*f)(vsip_scalar_i), 
                   const vsip_mview_i *x, const vsip_mview_i *y);
void vsip_tunary_f(vsip_scalar_f (*f)(vsip_scalar_f), 
                   const vsip_tview_f *x, const vsip_tview_f *y);
void vsip_tunary_i(vsip_scalar_i (*f)(vsip_scalar_i), 
                   const vsip_tview_i *x, const vsip_tview_i *y);</synopsis>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Arguments</term>

          <listitem>
            <variablelist>
              <varlistentry>
                <term>f</term>

                <listitem>
                  <para>User specified null-ary function of one/two/three
                  scalar indices</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>x</term>

                <listitem>
                  <para>Vector/matrix/tensor view object of result</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Return value</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Restrictions</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Errors</term>

          <listitem>
            <para>The arguments must conform to the following:</para>

            <orderedlist>
              <listitem>
                <para>Input and output views must all be the same size.</para>
              </listitem>

              <listitem>
                <para>All view objects must be valid.</para>
              </listitem>

              <listitem>
                <para>The input and output views must be identical views of
                the same block (in-place), or must not overlap.</para>
              </listitem>

              <listitem>
                <para>The pointer to the user-specified function must be valid
                – non-null.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Notes/References</term>

          <listitem>
            <para>There are no complex versions of this function. This is a
            consequence of supporting the implementation of complex blocks
            with split storage, which is not compatible with a
            <type>vsip_cscalar_p</type> data type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Examples</term>

          <listitem>
            <para/>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>See Also</term>

          <listitem>
            <para><function>vsip_<replaceable>s</replaceable>bool_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>binary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>mary_<replaceable>p</replaceable></function>,
            <function>vsip_<replaceable>s</replaceable>nary_<replaceable>p</replaceable></function>,
            <function>and
            vsip_<replaceable>s</replaceable>serialmary_<replaceable>p</replaceable></function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</chapter>
